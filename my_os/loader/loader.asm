%include "../include/macro.inc"
%include "../include/pm.inc"
%include "../include/gdt.inc"
section LOADER_ENTRY
start:
[BITS	16]
	; 初始化段寄存器，此时cs为0x0800，ip为0， 并且分配0x100的栈空间
	mov	ax, cs
	mov	ds, ax
	mov	es, ax
	mov	ss, ax
	mov	sp, 0100h

;#################################################################
; 加载内核到内存0x10000中
;#################################################################
LoadKernel:
    ;内核位于逻辑扇区号为54-72的位置：
	;从第 ax 个 Sector 开始, 将 cl 个 Sector 读入 es:bx 中
	push es
	mov ax,kernel_code_segment ;段地址 ; 存放数据的内存基地址
	mov es,ax                ;设置段地址（不能直接mov es,段地址）
	mov bx,0 				;偏移地址; 存放数据的内存偏移地址
	mov ax, 54
	mov cl, 18
	call ReadSector
	pop es

;#################################################################
; 加载GDT表到内存0x1000中
;#################################################################
LoadGDT:
    ;内核位于逻辑扇区号为54-72的位置：
	;从第 ax 个 Sector 开始, 将 cl 个 Sector 读入 es:bx 中
	push es
	mov ax,GDT_segment ;段地址 ; 存放数据的内存基地址
	mov es,ax                ;设置段地址（不能直接mov es,段地址）
	mov bx,0 				;偏移地址; 存放数据的内存偏移地址
	mov ax, 35
	mov cl, 1
	call ReadSector
	pop es

;#################################################################
; 加载用户程序1到内存0x50000中
;#################################################################
; LoadUserProgram1:
;     ;内核位于逻辑扇区号为54-72的位置：
; 	;从第 ax 个 Sector 开始, 将 cl 个 Sector 读入 es:bx 中
; 	mov ax,kernel_code_segment ;段地址 ; 存放数据的内存基地址
; 	mov es,ax                ;设置段地址（不能直接mov es,段地址）
; 	mov bx,0 				;偏移地址; 存放数据的内存偏移地址
; 	mov ax, 54
; 	mov cl, 18
; 	call ReadSector


;#################################################################
; 进入保护模式前的初始化工作
;#################################################################
	; 段表已经提前加载到内存中了，这里只需要指定地址就好
	; 加载 GDTR
	lgdt	[GdtPtr]

	; 关中断
	cli

	; 打开地址线A20
	in	al, 92h
	or	al, 00000010b
	out	92h, al

	; 准备切换到保护模式
	mov	eax, cr0
	or	eax, 1
	mov	cr0, eax

	; 真正进入保护模式
	; 此处为16位保护模式，为了保证能够修改32位的eip，必须使用dword
	jmp	dword SelectorKernel:0

;##############################################################
; 在加载器中使用的公共例程
;##############################################################
;----------------------------------------------------------------------------
; 函数名: ReadSector
; http://blog.csdn.net/littlehedgehog/article/details/2147361
;----------------------------------------------------------------------------
; 作用:
;    从第 ax 个 Sector 开始, 将 cl 个 Sector 读入 es:bx 中
;    从0开始算
ReadSector:
    ; -----------------------------------------------------------------------
    ; 怎样由扇区号求扇区在磁盘中的位置 (扇区号 -> 柱面号, 起始扇区, 磁头号)
    ; -----------------------------------------------------------------------
    ; 设扇区号为 x
    ;                           ┌ 柱面号 = y >> 1
    ;       x           ┌ 商 y ┤
    ; -------------- => ┤      └ 磁头号 = y & 1
    ;  每磁道扇区数     │
    ;                   └ 余 z => 起始扇区号 = z + 1
    push   bp
    mov    bp, sp
    sub    sp, 2            ; 辟出两个字节的堆栈区域保存要读的扇区数: byte [bp-2]

    mov    byte [bp-2], cl
    push   bx            ; 保存 bx
    mov    bl, 18    ; bl: 除数  [每磁道扇区数]
    div    bl            ; y 在 al 中, z 在 ah 中
    inc    ah            ; z ++
    mov    cl, ah            ; cl <- 起始扇区号
    mov    dh, al            ; dh <- y
    shr    al, 1            ; y >> 1 (其实是 y/BPB_NumHeads, 这里BPB_NumHeads=2)
    mov    ch, al            ; ch <- 柱面号
    and    dh, 1            ; dh & 1 = 磁头号
    pop    bx            ; 恢复 bx
    ; 至此, "柱面号, 起始扇区, 磁头号" 全部得到 ^^^^^^^^^^^^^^^^^^^^^^^^
    mov    dl, 0        ; [驱动器号 (0 表示 A 盘)]
.GoOnReading:
    mov    ah, 2            ; 读
    mov    al, byte [bp-2]        ; 读 al 个扇区
    int    13h
    jc    .GoOnReading        ; 如果读取错误 CF 会被置为 1, 这时就不停地读, 直到正确为止
    add    sp, 2
    pop    bp
    ret



;##############################################################
; GDT段表信息
;##############################################################
GdtPtr		dw	GDT_bound	; GDT界限
			dd  GDT_address		; GDT基地址

