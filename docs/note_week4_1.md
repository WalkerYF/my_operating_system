# 第四周的开发日志



## tty开发记录

将代码转移到tty.c的时候，发现代码像出了问题，每一次运行的结果都不同。
后来发现是自己分配的栈指针太小，修改了代码段。将kernel中的`mov sp 0x400`改成`mov sp 0x2000`就好了。

感觉还是蛮好写的，毕竟自己以前封装写的函数都很好用。
就是在回退删除内容那一块一时半会没有解决，后来灵机一动，改了一点点代码，搞定了！


### 中断系统

想法：
改写一个int 40中断，让该中断指向一个内核自定义的程序。
该程序能够保存终端状态，并且跳转到一个指定的程序运行。
（该指定程序由一个索引寄存器索引到一个表中，该表存有各自定义中断例程的地址。

### 问题来了

这个中断会调用一个call far 修改 cs和ip寄存器，然后跳转到指定函数。
该函数是用c写的，汇编之后，似乎只能生成ret，而不能生成retf

暂时将这个中断系统做成只取偏移量，不取段地址的形式。
还是无法解决C中调用函数无法实现段的跳转的问题。

事实上，c中无法实现段间的跳转是很正常的。在orange中，他是通过创建页表的方式修改地址的映射，以实现内存分段管理，而c程序无需关心自己在那个段，也无需关心自己调用的中断的代码是否处在这个段。

不修改段！

### C与汇编的相互调用

汇编调用C ： 使用call dword XXXX
（注意！不能直接在前面加66，因为这样的话，call后面接的地址的偏移量不对）
从C返回到汇编：retl

C调用汇编：直接调用
汇编调用c：retl

### 中断系统完成，现在实现用户程序的执行和返回

使用一个中断来实现返回到操作系统内核。
如果想保存终端的状态，需要怎么做？ 

刚刚遇到一个很奇怪的问题，我删掉了一些代码，命令行运行正常了？？？？？？？

问题来了，如何调用用户程序呢？
1. 向文件系统传送文件名，由文件系统加载到指定地址，然后向内核返回错误码，至此，文件加载完成，加载完成后，跳转到用户程序执行。
1. 用户程序执行执行，当执行完之后，调用int40h中断返回到内核tty。

刚刚有一个很奇怪的事情，就是我注释掉一段代码之后就少了一些显示的内容，但是功能却还是正常的！
![](https://i.loli.net/2018/03/31/5abf256f1536e.png)

后来debug的时候发现，原本应该在内存中存在的值，在debug的时候这些值都神奇的全部变成了0，为什么！！
后来发现，在运行的时候，这些值全部都是0.
![](https://i.loli.net/2018/03/31/5abf25fb40942.png)

大概的原因就猜到了，我只加载了10个扇区，每个扇区512字节（0x200）的话，其实在十六进制上，就只能加载到0x1400,因此后面的内容全部变成了0.

为了解决这个问题，我就在boot中加载多了8个扇区。问题就解决了。

其实要想完全解决这个问题，还得实现文件系统，由文件系统负责加载文件，并保证文件的完全加载。

### 现在实现显示文件信息的函数

目前要实现的功能：

1. 编写BPB
1. 编写根目录表
1. 获取根目录文件名

1. 补充一个函数，这个函数将逻辑扇区号对应的扇区加载到指定内存地址处。搞定！
1. 写一个函数，这个函数会从根目录区中读取数据，并放到一个结构体数据中。
    1. 加载一个扇区到临时空间
    1. 从临时空间中将根目录表复制到结构体中。
    1. 读取结构体，找到相应参数并返回，若无，则返回错误码。

这个暂时是实现了，不顾有一个问题，结构体读取到的文件名可以以short数组的形式读取，然后我要写一个函数用来做文件名的比较。
想了想，还是可以用strcmp来比较的，或者说，我用自己写的strncmp来比较可能会更好一些！

1. 还有一个函数，根据起始簇号，加载扇区到指定地址中。
    1. 簇号与扇区号的对应关系？？
    1. 可以由BPB表中的信息计算得来。

我现在差不多搞定文件系统了，但是有一个问题没有解决：

我的终端如何与我的文件系统相联系起来？？
比如说，留一个操作码，一个字符串给我的文件系统，文件系统给我返回错误码。这样的事情可以做到吗？

终端接受命令，进行分析后，它会得到一些需要发往文件系统的消息。
消息要通过怎样的机制才能够进入到内核呢？
将信息放到内存中的一处特定的位置，然后调用中断进入内核处理，最后将错误码放在内存中一处特定的位置，返回到终端，终端获取信息后就继续执行下面的指令。

debug:在编写一个获取内存指定地址处内容的函数的时候，发现了basic模块中的一个bug：应该让ax作为返回值，但是我却在函数中，将ax保存在栈中，之后恢复，这样子就不可能将ax作为参数传递给调用者。

### 文件系统实现。

很多需要的函数已经写好了，可以去设计文件系统的交互框架了。

1. 总体思路：使用中断，调用内核函数，内核函数处理完，输出相关信息，完成相关任务后，回到终端。

关键问题是：文件系统如何与终端结合？？，两者如何进行沟通？？
再扩展一下，是当用户程序调用系统调用的时候，一些信息如何从用户程序交给系统调用？

考虑将整个系统转为平摊内存空间模型，不然太多段弄在一起，真的很难弄。
原来啊，用户程序在另一个段跑，然后内核在这个段跑。不同段间信息的交流用c的话就很困难，因为按我观察的情况，gcc是将段寄存器都当成相同的来进行编译的，里面基本上没有涉及到对段寄存器的操作。
目前我的内核是在一个段中的，如何做到内核，系统中断，用户程序，都放在一个段中呢？

1. 空间问题
    1. 内核不能超过64k，这个不担心
    1. 后期实现文件系统，也能够实现加载多个扇区而不用考虑一个柱面只有18个扇区，这个也不担心。
1. tty已经在kernel中，保证是同一个段的，那么tty如何调用文件系统的接口呢？
1. 文件系统应该有什么接口？
1. 接口大概是确定好了，下面想想终端应该要怎样？
    1. 加载用户程序：
        1. 先得到文件大小（若为0表示文件不存在）
        1. 在内存中分配空间（维护一个指针即可）
        1. 加载到指定函数指针处
        1. 执行文件
    1. 打印文件信息
        1. 直接调用来打印

暂时的解决方法是：


### 下面让命令行支持一些指令

命令行如何调用各种功能呢？

1. 创建一个表，记录存储安排
1. 控制台支持命令 mem 获取用户程序信息及位置
1. 控制台支持命令 run 运行指定程序



### 文件系统如何做

1. 编写引导扇区的BPB表
1. 硬编码FAT表
1. 硬编码根目录区
1. 实现一个服务：输入名字，返回错误码，由错误码可知是否加载成功。
    1. 参数类型，放入系统调用缓冲区中。
        1. file_name
        1. es:bx
    1. 根据参数的不同，提供以下功能
        1. error_code load_com_file(file_name, ex:bx) {0 if normal，1 if not found, 2 if file_header corrupted}
        1. init_kernel()
    1. 有以下子过程
        1. 转换：逻辑扇区号->(磁头号，柱面号，扇区号)
        1. 起始簇号 search_file(file_name)  加载跟目录区到缓冲区，在根目录区搜索条目，找到后，返回指定偏移量处的起始簇号
        1. void load_file(起始簇号，es:bx)  {根据簇号，加载指定fat表所在扇区（若同一个扇区就不加载），加载指定簇，获取下一个簇，更新bx} loop

