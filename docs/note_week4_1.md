# 第四周的开发日志





## 日志

将代码转移到tty.c的时候，发现代码像出了问题，每一次运行的结果都不同。
后来发现是自己分配的栈指针太小，修改了代码段。将kernel中的`mov sp 0x400`改成`mov sp 0x2000`就好了。

### tty开发记录

感觉还是蛮好写的，毕竟自己以前封装写的函数都很好用。
就是在回退删除内容那一块一时半会没有解决，后来灵机一动，改了一点点代码，搞定了！


### 中断系统

想法：
改写一个int 40中断，让该中断指向一个内核自定义的程序。
该程序能够保存终端状态，并且跳转到一个指定的程序运行。
（该指定程序由一个索引寄存器索引到一个表中，该表存有各自定义中断例程的地址。

### 问题来了

这个中断会调用一个call far 修改 cs和ip寄存器，然后跳转到指定函数。
该函数是用c写的，汇编之后，似乎只能生成ret，而不能生成retf

暂时将这个中断系统做成只取偏移量，不取段地址的形式。
还是无法解决C中调用函数无法实现段的跳转的问题。

事实上，c中无法实现段间的跳转是很正常的。在orange中，他是通过创建页表的方式修改地址的映射，以实现内存分段管理，而c程序无需关心自己在那个段，也无需关心自己调用的中断的代码是否处在这个段。

不修改段！

### C与汇编的相互调用

汇编调用C ： 使用call dword XXXX
（注意！不能直接在前面加66，因为这样的话，call后面接的地址的偏移量不对）
从C返回到汇编：retl

C调用汇编：直接调用
汇编调用c：retl

### 中断系统完成，现在实现用户程序的执行和返回

使用一个中断来实现返回到操作系统内核。
如果想保存终端的状态，需要怎么做？

### 下面让命令行支持一些指令

命令行如何调用各种功能呢？

1. 创建一个表，记录存储安排
1. 控制台支持命令 mem 获取用户程序信息及位置
1. 控制台支持命令 run 运行指定程序

### 文件系统如何做

1. 编写引导扇区的BPB表
1. 硬编码FAT表
1. 硬编码根目录区
1. 实现一个服务：输入名字，返回错误码，由错误码可知是否加载成功。
    1. 参数类型，放入系统调用缓冲区中。
        1. file_name
        1. es:bx
    1. 根据参数的不同，提供以下功能
        1. error_code load_com_file(file_name, ex:bx) {0 if normal，1 if not found, 2 if file_header corrupted}
        1. init_kernel()
    1. 有以下子过程
        1. 转换：逻辑扇区号->(磁头号，柱面号，扇区号)
        1. 起始簇号 search_file(file_name)  加载跟目录区到缓冲区，在根目录区搜索条目，找到后，返回指定偏移量处的起始簇号
        1. void load_file(起始簇号，es:bx)  {根据簇号，加载指定fat表所在扇区（若同一个扇区就不加载），加载指定簇，获取下一个簇，更新bx} loop

