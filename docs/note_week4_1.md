# 第四周的开发日志


其实我发现现在我还不清楚各部件的分工，还有内存的安排，内核放哪？
这里先明确一下。

|模块|软盘位置(磁头,柱面,扇区号):逻辑扇区号,扇区数量|内存位置|功能说明|
|-|-|-|-|
|boot.bin|(0,0,1):0,1|0x7c00-0x7e00|在软盘中搜索loader.bin，并加载到内存0x0800:0x0000处|
<!-- |loader.bin|(0,2,1):72,4|0x8000-0xFFFF|在软盘中搜索kernel.bin，并加载到内存0x1000:0x0000处| -->
|kernel.bin|(0,2,1):72,16|0x10000-0x2FFFF|在内核下，初始化各种东西后，自动加载tty|
|tty.bin|():?,?|0x20000-0x25000|显示终端，调用各种功能|
|fsystem.bin|(?,?,?):?,4|||在内存中，作为访问文件的接口|


## kernel.bin

0x1000:0x0000

正常显示所有东西
按键-t -> 运行终端

## tty.bin
 
那就是tty我想怎么写就怎么写咯。

1. 安装键盘驱动，然后我才能使用键盘控制光标和显示缓冲区。

写显存，在终端里调用 `int 0x80`，并且传一些值，然后回到内核，内核发送消息给fsystem,返回值通过内核放到用户程序的数据缓冲区中。用户程序一旦检测到缓冲区的更新，取出数据，缓冲区清零，继续运行。


缓冲区0：输入缓冲区   
缓冲区1：接收消息缓冲区
缓冲区2：发送消息缓冲区

更新显示：将缓冲区的内容放到当前屏幕上指定位置后的区域

循环机制更新：
1. 读取当前键盘输入
    1. 当。。。时，修改显示缓冲区，更新开头索引。
    1. 当enter时,将输入缓冲区内容打包送往paser，由paser执行对应指令。
1. 更新输入缓冲区内容及长度到显存（根据开头索引）

显示新的一行。

## tty.bin 





## fsystem.bin

我的想法是始终将这个放到内存的某一个区域（如0x1000-0x2FFF）
内存中有一块作为缓冲区 0x3000-0x4000

1. 给寄存器传递一些参数，然后调用中断，通过某个寄存器索引到该项调用
1. 参数类型
    1. file_name
    1. es:bx
1. 根据参数的不同，提供以下功能
    1. error_code load_com_file(file_name, ex:bx) {0 if normal，1 if not found, 2 if file_header corrupted}
    1. init_kernel()
1. 有以下子过程
    1. 转换：逻辑扇区号->(磁头号，柱面号，扇区号)
    1. 起始簇号 search_file(file_name)  加载跟目录区到缓冲区，在根目录区搜索条目，找到后，返回指定偏移量处的起始簇号
    1. void load_file(起始簇号，es:bx)  {根据簇号，加载指定fat表所在扇区（若同一个扇区就不加载），加载指定簇，获取下一个簇，更新bx} loop
    1. TODO:删除文件，（在目录区删除指定条目）
    1. TODO:根据参数，将指定格式的文件加载
    1. TODO:分配空闲簇号，根据es:bx, length两个参数，将内存内容写到扇区中，并更新条目

## 中断系统

安装中断的时候，将函数指针传到一个数组中。
调用一个指定中断。
该中断会先执行一些代码，然后根据ax的值，调用用户自定义过程，然后返回。


## 这周的目的

1. 实现一个键盘驱动，留好足够的键盘缓冲区
1. 如何设计终端
    1. 使用一些结构体，存好终端的全局变量（包括显示范围，当前显示位置，终端缓冲区等）
    1. 轮询键盘缓冲区
        1. 字符：将字符放到终端显示缓冲区
        1. backspace：光标回退
        1. enter：读取终端内容，将字符串交给一个程序处理
    1. 命令解析处理，可能会调用内核代码：
        1. man
        1. ls：打开根目录
        1. clean：