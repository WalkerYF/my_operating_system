# 第四周的开发日志



## tty开发记录

将代码转移到tty.c的时候，发现代码像出了问题，每一次运行的结果都不同。
后来发现是自己分配的栈指针太小，修改了代码段。将kernel中的`mov sp 0x400`改成`mov sp 0x2000`就好了。

感觉还是蛮好写的，毕竟自己以前封装写的函数都很好用。
就是在回退删除内容那一块一时半会没有解决，后来灵机一动，改了一点点代码，搞定了！


### 中断系统

想法：
改写一个int 40中断，让该中断指向一个内核自定义的程序。
该程序能够保存终端状态，并且跳转到一个指定的程序运行。
（该指定程序由一个索引寄存器索引到一个表中，该表存有各自定义中断例程的地址。

### 问题来了

这个中断会调用一个call far 修改 cs和ip寄存器，然后跳转到指定函数。
该函数是用c写的，汇编之后，似乎只能生成ret，而不能生成retf

暂时将这个中断系统做成只取偏移量，不取段地址的形式。
还是无法解决C中调用函数无法实现段的跳转的问题。

事实上，c中无法实现段间的跳转是很正常的。在orange中，他是通过创建页表的方式修改地址的映射，以实现内存分段管理，而c程序无需关心自己在那个段，也无需关心自己调用的中断的代码是否处在这个段。

不修改段！

### C与汇编的相互调用

汇编调用C ： 使用call dword XXXX
（注意！不能直接在前面加66，因为这样的话，call后面接的地址的偏移量不对）
从C返回到汇编：retl

C调用汇编：直接调用
汇编调用c：retl

### 中断系统完成，现在实现用户程序的执行和返回

使用一个中断来实现返回到操作系统内核。
如果想保存终端的状态，需要怎么做？ 

刚刚遇到一个很奇怪的问题，我删掉了一些代码，命令行运行正常了？？？？？？？

问题来了，如何调用用户程序呢？
1. 向文件系统传送文件名，由文件系统加载到指定地址，然后向内核返回错误码，至此，文件加载完成，加载完成后，跳转到用户程序执行。
1. 用户程序执行执行，当执行完之后，调用int40h中断返回到内核tty。

刚刚有一个很奇怪的事情，就是我注释掉一段代码之后就少了一些显示的内容，但是功能却还是正常的！
![](https://i.loli.net/2018/03/31/5abf256f1536e.png)

后来debug的时候发现，原本应该在内存中存在的值，在debug的时候这些值都神奇的全部变成了0，为什么！！
后来发现，在运行的时候，这些值全部都是0.
![](https://i.loli.net/2018/03/31/5abf25fb40942.png)

大概的原因就猜到了，我只加载了10个扇区，每个扇区512字节（0x200）的话，其实在十六进制上，就只能加载到0x1400,因此后面的内容全部变成了0.

为了解决这个问题，我就在boot中加载多了8个扇区。问题就解决了。

其实要想完全解决这个问题，还得实现文件系统，由文件系统负责加载文件，并保证文件的完全加载。

### 现在实现显示文件信息的函数

目前要实现的功能：

1. 编写BPB
1. 编写根目录表
1. 获取根目录文件名

1. 补充一个函数，这个函数将逻辑扇区号对应的扇区加载到指定内存地址处。
1. 可以再套一层，
1. 写一个函数，这个函数会从根目录区中读取数据，并放到一个结构体数据中
    1. 加载一个扇区到临时空间
    1. 从临时空间中将根目录表复制到结构体中。
    1. 读取结构体，找到相应参数并返回，若无，则返回错误码。
1. 还有一个函数，根据起始簇号，加载扇区到指定地址中。

### 下面让命令行支持一些指令

命令行如何调用各种功能呢？

1. 创建一个表，记录存储安排
1. 控制台支持命令 mem 获取用户程序信息及位置
1. 控制台支持命令 run 运行指定程序



### 文件系统如何做

1. 编写引导扇区的BPB表
1. 硬编码FAT表
1. 硬编码根目录区
1. 实现一个服务：输入名字，返回错误码，由错误码可知是否加载成功。
    1. 参数类型，放入系统调用缓冲区中。
        1. file_name
        1. es:bx
    1. 根据参数的不同，提供以下功能
        1. error_code load_com_file(file_name, ex:bx) {0 if normal，1 if not found, 2 if file_header corrupted}
        1. init_kernel()
    1. 有以下子过程
        1. 转换：逻辑扇区号->(磁头号，柱面号，扇区号)
        1. 起始簇号 search_file(file_name)  加载跟目录区到缓冲区，在根目录区搜索条目，找到后，返回指定偏移量处的起始簇号
        1. void load_file(起始簇号，es:bx)  {根据簇号，加载指定fat表所在扇区（若同一个扇区就不加载），加载指定簇，获取下一个簇，更新bx} loop

