# 操作系统week3-2

之前花了挺长时间弄清楚了如何将C和汇编混合编译并放入扇区使用虚拟机运行。
现在先看看这个周末要把这个操作系统开发到什么程度吧。

## 想法

一开始弄了很久想尝试保护模式，发现巨坑，果断退坑，投入实模式的怀抱。

### 各部件分工l

其实我发现现在我还不清楚各部件的分工，还有内存的安排，内核放哪？gdt表放哪？在进入保护模式前
这里先明确一下。

boot：0x7c00-0x7e00
    只做引导功能，将内核加载进内存的0x10000的区域。
    放到(0,1,1-18) 实际上只有9KB

kernel:加载到0x10000 - 0x50000

用户程序：指定加载到0x50000处
    命令行终端，属于一个用户程序（可以说是root级别）。
    通过包含库文件，里面可以通过调用各种系统调用，实现各种功能。

### 软盘位置安排

(1,2,3):X 表示1面2道3扇区,逻辑扇区号为X

(0,0,1):0:主引导扇区
(0,0,2-18)
(1,0,1):(1-18):FAT表？？

(0,1,1-18):(36-53):内核

(1,1,1-18):(54-71):用户程序

### 要实现的是？

1. stdio.h
    1. sprintf
    1. printf
1. string.h
    1. .....
1. type.h
    1. 

### 如何让内核与C结合起来？？

先要弄清楚boot进入内核后的环境吧。

### 正在编写C库

这里记一下我遇到的bug.

1. 在汇编过程里，一个读端口的函数，我已经将返回值给ax 了，但是我却傻乎乎的push ax， pop ax。
1. 获取光标位置的函数似乎出现了bug，为什么？
    1. 可能的原因：移位运算，忽略的操作数的大小，对8位的l数据左移8位，错了
    1. 改完之后好像还有问题，似乎总是get到0，为什么？
    1. 通过bochs调试，查看汇编代码，看到了诡异的一行`add eax,0x08`,但是代码里没有给这个值加8呀，猛然惊醒，移位的优先级比加号低。`cursor_index = (cursor_index << 8) + low_eight;`
1. 至此，读写端口和输出字符以及光标处输出字符并且光标自动推进换行完成。（没有做自动换页）


1. 显示数字的函数
    1. 一测试这个函数，前面的过程也出现问题了？
    1. 加上-O选项，就没有问题了？？
    1. 还会出问题，暂时没弄清楚是什么情况。有时好有时bug，dibug一下？很奇怪的，注释掉一些无关的代码，似乎就这正常运行，如果再释放刚刚注释的代码，就变奇怪了，只能输出一个2。
    1. 一开始怀疑是不是太大了，导致没有加载进内存中。
    1. 是下面的那一个bug，已经解决ok.

1. 显示字符串的函数
    1. 就没显示成功过，为什么？
    1. 注释掉前面的代码之后，显示出了乱码。
    1. bochs单步调试，发现0x1038f之后的指令全都乱了，和我的二进制文件不同，似乎内存被篡改了。之后调试：不断查看0x10393内存内容，检查是否与反汇编文件一致。
    1. 在运行到0x10000的时候，0x10393的内容是正确的
    1. 运行到0x1007b的时候，神秘变成0！！![](https://i.loli.net/2018/03/24/5ab653c6c30ae.png)
    1. 进一步缩小，0x1001c-0x10036
    1. 0x10036处调用的函数，覆盖了0x10393所在的内存，定位来看是putc函数
    1. 大概明白了，我在boot给kernel初始化的sp太小，我的代码已经超过了栈段，当我对栈进行操作时，便修改了内存。
    1. 现在至少是正常显示了一些乱码，而不是死机了。
    1. 问题来了
        1. ![](https://i.loli.net/2018/03/24/5ab65a613971d.png)
        1. ds是0x1000，而内存地址为0x103b7，一旦加起来，就不是预想的值了。
        1. 这是一个很大的问题，我还没有想好怎么总结这一个bug
        1. 想来，对C代码运行的环境仍没有一个很好的理解，就像是，与gcc合作却又没有遵守它的约定。
        1. 两个问题，1. 连接器产生的地址加上ds，将连接器参数改掉，从0开始。  2. basic.asm中的函数write_menory没有保存ds寄存器。
    1. 正常显示！

1. sprintf函数
    1. 问题主要在变长参数的处理上
    1. 对int * a, a = a+1,实际上a是加了4的，以便于多个32位数据的寻址。

1. printf函数
    1. 新的问题出现了，sprintf支持变长参数，但是printf如何调用他呢？
    1. https://www.zhihu.com/question/51102741 知乎学习，指日可待
    1. TODO:暂且将sprintf的代码复制到printf吧，有点难懂。va_list啥的
    1. 


## 记录

### 一个问题：

call时，地址会push进栈中，这个时候是如何进栈的？是高字节先进吗，还是低字节先进？
小实验：![](https://i.loli.net/2018/03/24/5ab6170946f8b.png),一眼看到，高字节先push进栈中，低字节后push进栈中。


### 关于数据段寄存器

```c
    char * a = 0xa8000;
    *a = 'a';
```
这一段很简单的代码，可以直接操控显存。
为什么不是B8000呢，因为我的ds被初始化为0x1000了。
这也是段寄存器在c语言中起作用的典型例子，之前一直没搞清楚c语言中段寄存器如何起作用。
通过反汇编也能够看出来。

### x86函数调用约定

和gcc合作，当然要遵循gcc所遵守的cdecl约定了。
之前看过，不过对于enter和leave指令而言，仍然有些疑惑。
对enter的解释：https://x86.puri.sm/html/file_module_x86_id_78.html
leave：https://x86.puri.sm/html/file_module_x86_id_154.html

关于函数参数的调用，注意是字节地址，字节地址！！


### 再整理一个问题

```
char * a;
&a+1// 到底会加多少！
```
![](https://i.loli.net/2018/03/25/5ab71d37ab035.png)

https://www.jianshu.com/p/b5d8e52e5836
解释通了，注意+1操作与操作数的类型相关。
如果是数组指针+1，会加整个数组
如果是普通指针，会加该类型对应的值（如int就+4个字节诸如此类）


### 一个大坑

如何将一个函数的可变参数传递给另一个函数的可变参数