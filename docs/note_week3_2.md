# 操作系统week3-2

之前花了挺长时间弄清楚了如何将C和汇编混合编译并放入扇区使用虚拟机运行。
现在先看看这个周末要把这个操作系统开发到什么程度吧。

## 想法

一开始弄了很久想尝试保护模式，发现巨坑，果断退坑，投入实模式的怀抱。

### 各部件分工l

其实我发现现在我还不清楚各部件的分工，还有内存的安排，内核放哪？gdt表放哪？在进入保护模式前
这里先明确一下。

boot：0x7c00-0x7e00
    只做引导功能，将内核加载进内存的0x10000的区域。
    放到(0,1,1-18) 实际上只有9KB

kernel:加载到0x10000 - 0x50000

用户程序：指定加载到0x50000处
    命令行终端，属于一个用户程序（可以说是root级别）。
    通过包含库文件，里面可以通过调用各种系统调用，实现各种功能。

### 软盘位置安排

(1,2,3):X 表示1面2道3扇区,逻辑扇区号为X

(0,0,1):0:主引导扇区
(0,0,2-18)
(1,0,1):(1-18):FAT表？？

(0,1,1-18):(36-53):内核

(1,1,1-18):(54-71):用户程序

### 要实现的是？

1. stdio.h
    1. sprintf
    1. printf
1. string.h
    1. .....
1. type.h
    1. 

### 如何让内核与C结合起来？？

先要弄清楚boot进入内核后的环境吧。


内核功能：
1. 显示菜单
1. 加载用户程序

1. 初始化内核
    1. 安装int40，int8中断
    1. 


## 记录

### 一个问题：

call时，地址会push进栈中，这个时候是如何进栈的？是高字节先进吗，还是低字节先进？
小实验：![](https://i.loli.net/2018/03/24/5ab6170946f8b.png),一眼看到，高字节先push进栈中，低字节后push进栈中。


### 关于数据段寄存器

```c
    char * a = 0xa8000;
    *a = 'a';
```
这一段很简单的代码，可以直接操控显存。
为什么不是B8000呢，因为我的ds被初始化为0x1000了。
这也是段寄存器在c语言中起作用的典型例子，之前一直没搞清楚c语言中段寄存器如何起作用。
通过反汇编也能够看出来。

### x86函数调用约定

和gcc合作，当然要遵循gcc所遵守的cdecl约定了。
之前看过，不过对于enter和leave指令而言，仍然有些疑惑。
对enter的解释：https://x86.puri.sm/html/file_module_x86_id_78.html
leave：https://x86.puri.sm/html/file_module_x86_id_154.html

关于函数参数的调用，注意是字节地址，字节地址！！