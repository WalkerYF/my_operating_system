# 操作系统week3-2

之前花了挺长时间弄清楚了如何将C和汇编混合编译并放入扇区使用虚拟机运行。
现在先看看这个周末要把这个操作系统开发到什么程度吧。

## 想法

一开始弄了很久想尝试保护模式，发现巨坑，果断退坑，投入实模式的怀抱。

### 各部件分工l

其实我发现现在我还不清楚各部件的分工，还有内存的安排，内核放哪？gdt表放哪？在进入保护模式前
这里先明确一下。

boot：0x7c00-0x7e00
    只做引导功能，将内核加载进内存的0x10000的区域。
    放到(0,1,1-18) 实际上只有9KB

kernel:加载到0x10000 - 0x50000

用户程序：指定加载到0x50000处
    命令行终端，属于一个用户程序（可以说是root级别）。
    通过包含库文件，里面可以通过调用各种系统调用，实现各种功能。

### 软盘位置安排

(1,2,3):X 表示1面2道3扇区,逻辑扇区号为X

(0,0,1):0:主引导扇区
(0,0,2-18)
(1,0,1):(1-18):FAT表？？

(0,1,1-18):(36-53):内核

(1,1,1-18):(54-71):用户程序

### 要实现的是？

1. stdio.h
    1. sprintf
    1. printf
1. string.h
    1. .....
1. type.h
    1. 

### 如何让内核与C结合起来？？

先要弄清楚boot进入内核后的环境吧。

### 正在编写C库

这里记一下我遇到的bug.

1. 在汇编过程里，一个读端口的函数，我已经将返回值给ax 了，但是我却傻乎乎的push ax， pop ax。
1. 获取光标位置的函数似乎出现了bug，为什么？
    1. 可能的原因：移位运算，忽略的操作数的大小，对8位的数据左移8位，错了
    1. 改完之后好像还有问题，似乎总是get到0，为什么？
    1. 通过bochs调试，查看汇编代码，看到了诡异的一行`add eax,0x08`,但是代码里没有给这个值加8呀，猛然惊醒，移位的优先级比加号低。`cursor_index = (cursor_index << 8) + low_eight;`
1. 至此，读写端口和输出字符以及光标处输出字符并且光标自动推进换行完成。（没有做自动换页）


1. 显示数字的函数
    1. 一测试这个函数，前面的过程也出现问题了？
    1. 加上-O选项，就没有问题了？？



## 记录

### 一个问题：

call时，地址会push进栈中，这个时候是如何进栈的？是高字节先进吗，还是低字节先进？
小实验：![](https://i.loli.net/2018/03/24/5ab6170946f8b.png),一眼看到，高字节先push进栈中，低字节后push进栈中。


### 关于数据段寄存器

```c
    char * a = 0xa8000;
    *a = 'a';
```
这一段很简单的代码，可以直接操控显存。
为什么不是B8000呢，因为我的ds被初始化为0x1000了。
这也是段寄存器在c语言中起作用的典型例子，之前一直没搞清楚c语言中段寄存器如何起作用。
通过反汇编也能够看出来。

### x86函数调用约定

和gcc合作，当然要遵循gcc所遵守的cdecl约定了。
之前看过，不过对于enter和leave指令而言，仍然有些疑惑。
对enter的解释：https://x86.puri.sm/html/file_module_x86_id_78.html
leave：https://x86.puri.sm/html/file_module_x86_id_154.html

关于函数参数的调用，注意是字节地址，字节地址！！