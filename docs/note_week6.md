# week6打码日志

我的心很小，一次只能容纳一个项目，事实上这周，心里只有计网项目，几乎没有动过操作系统，可能要gg了。

## 实现需求：

1. 实现一些中断，将这些中断包装成函数，这些包含中断的函数可以被用户直接调用，用作从用户态转入内核态干活的方法。
1. 使用C程序写一个用户程序，调用这一些类似于系统调用的函数
1. 将这个新的用户程序放到软盘的不同位置处
1. 将以前写的几个跳动的A的程序放到用户程序处
1. 加载程序部分，能够加载多个用户程序进内存中（维护一个地址和对应的标签，标签表示该地址有没有被用过）
    1. 每次加载一个程序，就从这个数据中取一个没有用过的地址，加载进去然后运行
1. 实现进程控制块，两个用户程序交替运行
1. 实现一个命令，这个命令会触发进程交换
    1. 先将两个进程对应的信息写进进程控制块表
    1. 将时钟中断改成进程切换
    1. 再写一个启动函数，加载进程控制块其中一块


## 修一个bug

原来的时钟中断没有保存时钟中断没有用的寄存器，会导致一种情况：在终端输入的时候，可能会随机出现卡死的情况。
这种情况的来源，是因为时钟中断会随时发生，如果发生在下面的两条语句中间，还修改了ax，可能会崩掉：
```
mov ax, cs
mov ds, ax
```

在int 16h中断中，有这样的语句：
```
push ds
mov ds, 0x40
;恢复ds的值
```
一旦时钟中断在ds改变后发生,时钟中断还依赖于数据段寄存器的正确取值，就会可能出现问题，这个问题来源于时钟中断的独立性没有保证。
时钟中断作为一个可能随时都会发生的一个过程，必须保证绝对不会修改任何寄存器，同时也要尽可能的减少对寄存器的依赖。在我的实现中，时钟中断后来修改成只依赖cs在内核态的正确取值。这也是我第一次接触到pusha和popa这一类指令，极大地方便了我保存状态。

在将我的int8中断头尾加上如下内容之后，经过暴力测试，没有出现卡死的情况。

```
    push es
    push ds
    push ss
    pusha

    ;时钟中断具体内容

    popa
    pop ss
    pop ds
    pop es
```

## 整理用户程序，多个弹跳的用户程序需要放回到软盘中

将以前的四个用户程序移动到user文件夹下，并为了新内核的实现做了一点点修改（这个修改主要是增加了org 0x4000， 还有删掉了vstart语句）

然后将四个用户程序放到软盘里面,并修改相应的脚本文件。

增加完四个用户程序，也成功加载了，但是运行似乎出了问题？卡死了，并且回不去？
![](figure/2018-04-13-01-10-55.png)

先考虑检查用户程序的段对不对?
先对照了一下能跑的用户程序与会宕机的用户程序，发现了一个区别
![](figure/2018-04-13-01-13-44.png)

的确，如果将栈改了，的确会使程序的返回出现问题，但是现在的问题不在这里，在于运行的时候就出了问题。不过考虑到显示了笑脸，因此程序的加载地址是没问题的。

问题来了，即使我直接将用户程序1的代码复制过来也跑不了？排除用户程序的问题，开始寻找加载的问题。
排除了多次加载会出现问题（测试run stone1 与run u_e1)

通过bochs，发现加载stone2的时候，内存对应内容是0？后来发现，自己的程序被加载到了0x14800中，开始思考，是加载的时候扇区没有对上吗？错位了4个扇区？
![](figure/2018-04-13-01-43-55.png)

定位到自己的makefile，发现我算错数了，126+18=144才对。
![](figure/2018-04-13-01-45-33.png)

### 又出现问题，stone3用户程序退出会崩溃

历史遗留问题，我自己实现的int40h要补充参数，以前的没有移参数到ax中

## ouch！的实现

编写一个用户程序，用于实现ouch！

原理是轮询键盘缓冲区，一旦有按键就在随机位置输出ouch。

现在想用C程序写用户程序了，总觉得会遇到问题。
内核如何跳到我的ouch用户程序？
直接函数调用，不会改段，于是通过修改ip，我直接跳到ouch程序，这就与我用户程序的加载位置有关。如果我的加载位置放到内核段内，可以，和我其他的用户程序没什么区别，只要和内核链接到一起就行了。

但如果我想让我的ouch程序独立开来，就必须切换栈段，还需要换段，让我的用户程序独立编译。我的用户程序使用的是同一段，gcc默认我四个段寄存器都是相同的。要让我的内核跳转到用户程序，就需要写一个restart()函数，从进程控制块中读取对应的信息，然后保证环境配置完毕后，将栈切换到用户栈，将对应的信息放到用户栈中，通过一个iret去到用户程序内运行。

用户程序如何退出呢？退出有两种：保存现场的退出和不保存现场的退出。

对于不保存现场的退出，我应该是直接jmp 到内核的初始化部分就好，我要写一个中断，这个中断能够实现修改栈段为内核的当前栈段，然后读取cs,ip然后回来。
其实也就是说，我要为内核专门实现一个进程控制块，这个块的地址可以直接访问，然后还需要实现一个中断，这个中断，不会管用户程序怎样，只会从内核进程控制块中读取信息，然后跳到进程控制块对应的位置。

对于保存现场的退出，我应该是在时钟中断中实现。这个时钟中断我可以根据全局变量（当前进程号），将这个进程的信息存到指定的结构体中，然后在内核中实现调度，然后加载指定控制块的信息到环境中，然后iret进行切换。


### 先将ouch放到内核中

其实实现还是很简单的，不过出现了一些问题
1. gcc生成的用户文件似乎有点大
1. 加载fat表的函数参数设置得不好，太小了，可能没有将对应的表项加载进来。

现在我的操作系统有一个比较严重的问题：各个部分的内存分配有点乱，可能会相互覆盖，没有控制好。放一个todo