# week打码日志

我的心很小，一次只能容纳一个项目，事实上这周，心理只有计网项目，几乎没有动过操作系统，可能要gg了。

## 实现需求：

1. 实现一些中断，将这些中断包装成函数，这些包含中断的函数可以被用户直接调用，用作从用户态转入内核态干活的方法。
1. 使用C程序写一个用户程序，调用这一些类似于系统调用的函数
1. 将这个新的用户程序放到软盘的不同位置处
1. 将以前写的几个跳动的A的程序放到用户程序处
1. 加载程序部分，能够加载多个用户程序进内存中（维护一个地址和对应的标签，标签表示该地址有没有被用过）
    1. 每次加载一个程序，就从这个数据中取一个没有用过的地址，加载进去然后运行
1. 实现进程控制块，两个用户程序交替运行
1. 实现一个命令，这个命令会触发进程交换
    1. 先将两个进程对应的信息写进进程控制块表
    1. 将时钟中断改成进程切换
    1. 再写一个启动函数，加载进程控制块其中一块


## 修一个bug

原来的时钟中断没有保存时钟中断没有用的寄存器，会导致一种情况：在终端输入的时候，可能会随机出现卡死的情况。
这种情况的来源，是因为时钟中断会随时发生，如果发生在下面的两条语句中间，还修改了ax，可能会崩掉：
```
mov ax, cs
mov ds, ax
```

在int 16h中断中，有这样的语句：
```
push ds
mov ds, 0x40
;恢复ds的值
```
一旦时钟中断在ds改变后发生,时钟中断还依赖于数据段寄存器的正确取值，就会可能出现问题，这个问题来源于时钟中断的独立性没有保证。
时钟中断作为一个可能随时都会发生的一个过程，必须保证绝对不会修改任何寄存器，同时也要尽可能的减少对寄存器的依赖。在我的实现中，时钟中断后来修改成只依赖cs在内核态的正确取值。这也是我第一次接触到pusha和popa这一类指令，极大地方便了我保存状态。

在将我的int8中断头尾加上如下内容之后，经过暴力测试，没有出现卡死的情况。

```
    push es
    push ds
    push ss
    pusha

    ;时钟中断具体内容

    popa
    pop ss
    pop ds
    pop es
```