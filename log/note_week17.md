# 实验8：具有信号量的进程模型的实现

## 1 实验目的

1. 实现用于互斥和同步的计数信号量机制
2. 在这个项目中，我们完善进程模型
   1. 多个进程能够利用计数信号量机制实现临界区互斥
   2. 合作进程在并发时，利用计数信号量，可以按规定的时序执行各自的操作，实现复杂的同步，确保进程并发的情况正确完成使命

## 2 本实验完成的功能

本次实验，我实现了以下四个系统调用

1. `user_sem_p(int sem_id)`
   1. 用于信号量的P操作，该操作会调用内核的do_p原语。
2. `user_sem_v(int sem_id)`
   1. 用于信号量的V操作，该操作会调用内核的do_v原语。
3. `int user_get_sem(int value)`
   1. 用于得到一个信号量。
4. `user_free_sem(int sem_id)`
   1. 用于释放该信号量。

同时，在信号量机制中，我还实现了专属于信号量机制的`sem_block`和`sem_waitup`函数，用于阻塞进程以及唤醒进程。

## 3 基本原理

### user_get_sem函数

通过这个函数，用户可以得到一个在内核中进行管理的信号量，并得到该信号量对应的id，此后对信号量的所有操作，都依赖于该id而不是直接访问该信号量所在的内存地址。



### user_free_sem函数





### user_p函数



### user_v函数



## 4 遇到的问题

### 4.1 fork的子进程没有返回0

现在我遇到了一个很奇怪的问题，我使用上一个实验的示例，是fork后，子进程的fork是的确能够返回0的，但是当我编写好信号量的测试程序后，我的fork无论是父进程还是子进程都返回了7。

当fork完成，mm进程向子进程发送一个消息，解除子进程的阻塞时，可能会有两种情况：

1. 子进程正处于等待接收消息的状态，此时mm进程将消息复制到子进程的q_msg中
2. 子进程没有处于等待接受消息的状态，此时mm进程将会处于sending状态，阻塞住，直到子进程接收到mm进程的消息，子进程会从mm进程中的q_msg成员将消息复制过来。

想一想这样的一种情况，父进程已经处于等待接受消息的状态了，如果在此时mm进程被调用，将父进程复制一份变成子进程，子进程此时存有的q_msg仍然是父进程中的q_msg，这样子会造成一个怎样的问题呢？

由于fork_msg是一个全局变量，因此子进程接受了消息后若不没有及时处理，而是先被父进程



### 4.2 

![](https://lh3.googleusercontent.com/-rpBs9cikTNk/WzDxdAAktJI/AAAAAAAAIpU/1IP10iMZTQwWFUkVZNulib0ePOk0HNw7wCHMYCw/s0/Snipaste_2018-06-25_21-43-15.png)

将等号不小心打了两个，导致信号量的used值没有被更新，最终我申请的两个信号量id一样。

![](https://lh3.googleusercontent.com/-7CPicLUWZ0g/WzDx0ZJLM0I/AAAAAAAAIpc/j7BeV-zQJWA0fX68ZYYn-NeIPGgzZsoDACHMYCw/s0/Snipaste_2018-06-25_21-44-51.png)

### 4.3 mm进程被神秘解除阻塞



## 5 测试结果

## 6 实验感想