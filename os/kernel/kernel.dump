
kernel.debug:     file format elf32-i386


Disassembly of section .text:

00000000 <_start>:
_start():
       0:	e8 9c 00             	call   9f <install_int8>
       3:	e8 ef 00             	call   f5 <install_int33>
       6:	e8 25 01             	call   12e <install_int34>
       9:	e8 5f 01             	call   16b <install_int35>
       c:	e8 97 01             	call   1a6 <install_int36>
       f:	e8 3c 00             	call   4e <install_int40>
      12:	66 e8 86 02 00 00    	calll  29e <cstart>

00000018 <start_tty>:
start_tty():
      18:	e8 11 00             	call   2c <restart>
      1b:	ea 00 00 00 15       	ljmp   $0x1500,$0x0
      20:	66 e8 fe 05 00 00    	calll  624 <tty>
      26:	b4 02                	mov    $0x2,%ah
      28:	cd 40                	int    $0x40
      2a:	eb fe                	jmp    2a <core_code_entry_header_offset>

0000002c <restart>:
restart():
      2c:	be 04 2d             	mov    $0x2d04,%si
      2f:	8e 06 00 2d          	mov    0x2d00,%es
      33:	8b 3e 02 2d          	mov    0x2d02,%di
      37:	b9 2a 00             	mov    $0x2a,%cx
      3a:	83 ef 2a             	sub    $0x2a,%di
      3d:	fc                   	cld    
      3e:	f3 a4                	rep movsb %ds:(%si),%es:(%di)
      40:	8c c0                	mov    %es,%ax
      42:	83 ef 2a             	sub    $0x2a,%di
      45:	8e d0                	mov    %ax,%ss
      47:	89 fc                	mov    %di,%sp
      49:	1f                   	pop    %ds
      4a:	07                   	pop    %es
      4b:	66 61                	popal  
      4d:	cf                   	iret   

0000004e <install_int40>:
install_int40():
      4e:	53                   	push   %bx
      4f:	51                   	push   %cx
      50:	52                   	push   %dx
      51:	56                   	push   %si
      52:	57                   	push   %di
      53:	55                   	push   %bp
      54:	1e                   	push   %ds
      55:	06                   	push   %es
      56:	16                   	push   %ss
      57:	b8 00 00             	mov    $0x0,%ax
      5a:	8e d8                	mov    %ax,%ds
      5c:	8c c8                	mov    %cs,%ax
      5e:	c7 06 00 01 71 00    	movw   $0x71,0x100
      64:	a3 02 01             	mov    %ax,0x102
      67:	17                   	pop    %ss
      68:	07                   	pop    %es
      69:	1f                   	pop    %ds
      6a:	5d                   	pop    %bp
      6b:	5f                   	pop    %di
      6c:	5e                   	pop    %si
      6d:	5a                   	pop    %dx
      6e:	59                   	pop    %cx
      6f:	5b                   	pop    %bx
      70:	c3                   	ret    

00000071 <new_int40>:
new_int40():
      71:	80 fc 4c             	cmp    $0x4c,%ah
      74:	74 11                	je     87 <new_int40.return_kernel>
      76:	88 e3                	mov    %ah,%bl
      78:	31 c0                	xor    %ax,%ax
      7a:	b0 02                	mov    $0x2,%al
      7c:	f6 e3                	mul    %bl
      7e:	89 c6                	mov    %ax,%si
      80:	bb 20 71             	mov    $0x7120,%bx
      83:	66 ff 10             	calll  *(%bx,%si)
      86:	cf                   	iret   

00000087 <new_int40.return_kernel>:
new_int40.return_kernel():
      87:	59                   	pop    %cx
      88:	59                   	pop    %cx
      89:	59                   	pop    %cx
      8a:	b8 00 10             	mov    $0x1000,%ax
      8d:	8e d8                	mov    %ax,%ds
      8f:	8e c0                	mov    %ax,%es
      91:	8e d0                	mov    %ax,%ss
      93:	bc 00 50             	mov    $0x5000,%sp
      96:	51                   	push   %cx
      97:	68 00 10             	push   $0x1000
      9a:	68 18 00             	push   $0x18
      9d:	fb                   	sti    
      9e:	cf                   	iret   

0000009f <install_int8>:
install_int8():
      9f:	53                   	push   %bx
      a0:	51                   	push   %cx
      a1:	52                   	push   %dx
      a2:	56                   	push   %si
      a3:	57                   	push   %di
      a4:	55                   	push   %bp
      a5:	1e                   	push   %ds
      a6:	06                   	push   %es
      a7:	16                   	push   %ss
      a8:	b0 34                	mov    $0x34,%al
      aa:	e6 43                	out    %al,$0x43
      ac:	b8 ff ff             	mov    $0xffff,%ax
      af:	e6 40                	out    %al,$0x40
      b1:	88 e0                	mov    %ah,%al
      b3:	e6 40                	out    %al,$0x40
      b5:	b8 00 00             	mov    $0x0,%ax
      b8:	8e d8                	mov    %ax,%ds
      ba:	8c c8                	mov    %cs,%ax
      bc:	a3 22 00             	mov    %ax,0x22
      bf:	c7 06 20 00 cf 00    	movw   $0xcf,0x20
      c5:	17                   	pop    %ss
      c6:	07                   	pop    %es
      c7:	1f                   	pop    %ds
      c8:	5d                   	pop    %bp
      c9:	5f                   	pop    %di
      ca:	5e                   	pop    %si
      cb:	5a                   	pop    %dx
      cc:	59                   	pop    %cx
      cd:	5b                   	pop    %bx
      ce:	c3                   	ret    

000000cf <new_int8>:
new_int8():
      cf:	50                   	push   %ax
      d0:	53                   	push   %bx
      d1:	51                   	push   %cx
      d2:	52                   	push   %dx
      d3:	56                   	push   %si
      d4:	57                   	push   %di
      d5:	55                   	push   %bp
      d6:	1e                   	push   %ds
      d7:	06                   	push   %es
      d8:	16                   	push   %ss
      d9:	b8 00 b8             	mov    $0xb800,%ax
      dc:	8e d8                	mov    %ax,%ds
      de:	66 e8 73 16 00 00    	calll  1757 <move_name>
      e4:	b0 20                	mov    $0x20,%al
      e6:	e6 20                	out    %al,$0x20
      e8:	e6 a0                	out    %al,$0xa0
      ea:	17                   	pop    %ss
      eb:	07                   	pop    %es
      ec:	1f                   	pop    %ds
      ed:	5d                   	pop    %bp
      ee:	5f                   	pop    %di
      ef:	5e                   	pop    %si
      f0:	5a                   	pop    %dx
      f1:	59                   	pop    %cx
      f2:	5b                   	pop    %bx
      f3:	58                   	pop    %ax
      f4:	cf                   	iret   

000000f5 <install_int33>:
install_int33():
      f5:	53                   	push   %bx
      f6:	51                   	push   %cx
      f7:	52                   	push   %dx
      f8:	56                   	push   %si
      f9:	57                   	push   %di
      fa:	55                   	push   %bp
      fb:	1e                   	push   %ds
      fc:	06                   	push   %es
      fd:	16                   	push   %ss
      fe:	b8 00 00             	mov    $0x0,%ax
     101:	8e d8                	mov    %ax,%ds
     103:	8c c8                	mov    %cs,%ax
     105:	c7 06 cc 00 18 01    	movw   $0x118,0xcc
     10b:	a3 ce 00             	mov    %ax,0xce
     10e:	17                   	pop    %ss
     10f:	07                   	pop    %es
     110:	1f                   	pop    %ds
     111:	5d                   	pop    %bp
     112:	5f                   	pop    %di
     113:	5e                   	pop    %si
     114:	5a                   	pop    %dx
     115:	59                   	pop    %cx
     116:	5b                   	pop    %bx
     117:	c3                   	ret    

00000118 <new_int33>:
new_int33():
     118:	53                   	push   %bx
     119:	51                   	push   %cx
     11a:	52                   	push   %dx
     11b:	56                   	push   %si
     11c:	57                   	push   %di
     11d:	55                   	push   %bp
     11e:	1e                   	push   %ds
     11f:	06                   	push   %es
     120:	16                   	push   %ss
     121:	89 c2                	mov    %ax,%dx
     123:	ec                   	in     (%dx),%al
     124:	17                   	pop    %ss
     125:	07                   	pop    %es
     126:	1f                   	pop    %ds
     127:	5d                   	pop    %bp
     128:	5f                   	pop    %di
     129:	5e                   	pop    %si
     12a:	5a                   	pop    %dx
     12b:	59                   	pop    %cx
     12c:	5b                   	pop    %bx
     12d:	cf                   	iret   

0000012e <install_int34>:
install_int34():
     12e:	53                   	push   %bx
     12f:	51                   	push   %cx
     130:	52                   	push   %dx
     131:	56                   	push   %si
     132:	57                   	push   %di
     133:	55                   	push   %bp
     134:	1e                   	push   %ds
     135:	06                   	push   %es
     136:	16                   	push   %ss
     137:	b8 00 00             	mov    $0x0,%ax
     13a:	8e d8                	mov    %ax,%ds
     13c:	8c c8                	mov    %cs,%ax
     13e:	c7 06 d0 00 51 01    	movw   $0x151,0xd0
     144:	a3 d2 00             	mov    %ax,0xd2
     147:	17                   	pop    %ss
     148:	07                   	pop    %es
     149:	1f                   	pop    %ds
     14a:	5d                   	pop    %bp
     14b:	5f                   	pop    %di
     14c:	5e                   	pop    %si
     14d:	5a                   	pop    %dx
     14e:	59                   	pop    %cx
     14f:	5b                   	pop    %bx
     150:	c3                   	ret    

00000151 <new_int34>:
new_int34():
     151:	50                   	push   %ax
     152:	53                   	push   %bx
     153:	51                   	push   %cx
     154:	52                   	push   %dx
     155:	56                   	push   %si
     156:	57                   	push   %di
     157:	55                   	push   %bp
     158:	1e                   	push   %ds
     159:	06                   	push   %es
     15a:	16                   	push   %ss
     15b:	89 da                	mov    %bx,%dx
     15d:	88 c0                	mov    %al,%al
     15f:	ee                   	out    %al,(%dx)
     160:	17                   	pop    %ss
     161:	07                   	pop    %es
     162:	1f                   	pop    %ds
     163:	5d                   	pop    %bp
     164:	5f                   	pop    %di
     165:	5e                   	pop    %si
     166:	5a                   	pop    %dx
     167:	59                   	pop    %cx
     168:	5b                   	pop    %bx
     169:	58                   	pop    %ax
     16a:	cf                   	iret   

0000016b <install_int35>:
install_int35():
     16b:	53                   	push   %bx
     16c:	51                   	push   %cx
     16d:	52                   	push   %dx
     16e:	56                   	push   %si
     16f:	57                   	push   %di
     170:	55                   	push   %bp
     171:	1e                   	push   %ds
     172:	06                   	push   %es
     173:	16                   	push   %ss
     174:	b8 00 00             	mov    $0x0,%ax
     177:	8e d8                	mov    %ax,%ds
     179:	8c c8                	mov    %cs,%ax
     17b:	c7 06 d4 00 8e 01    	movw   $0x18e,0xd4
     181:	a3 d6 00             	mov    %ax,0xd6
     184:	17                   	pop    %ss
     185:	07                   	pop    %es
     186:	1f                   	pop    %ds
     187:	5d                   	pop    %bp
     188:	5f                   	pop    %di
     189:	5e                   	pop    %si
     18a:	5a                   	pop    %dx
     18b:	59                   	pop    %cx
     18c:	5b                   	pop    %bx
     18d:	c3                   	ret    

0000018e <new_int35>:
new_int35():
     18e:	53                   	push   %bx
     18f:	51                   	push   %cx
     190:	52                   	push   %dx
     191:	56                   	push   %si
     192:	57                   	push   %di
     193:	55                   	push   %bp
     194:	1e                   	push   %ds
     195:	06                   	push   %es
     196:	16                   	push   %ss
     197:	8e c0                	mov    %ax,%es
     199:	26 8a 07             	mov    %es:(%bx),%al
     19c:	17                   	pop    %ss
     19d:	07                   	pop    %es
     19e:	1f                   	pop    %ds
     19f:	5d                   	pop    %bp
     1a0:	5f                   	pop    %di
     1a1:	5e                   	pop    %si
     1a2:	5a                   	pop    %dx
     1a3:	59                   	pop    %cx
     1a4:	5b                   	pop    %bx
     1a5:	cf                   	iret   

000001a6 <install_int36>:
install_int36():
     1a6:	53                   	push   %bx
     1a7:	51                   	push   %cx
     1a8:	52                   	push   %dx
     1a9:	56                   	push   %si
     1aa:	57                   	push   %di
     1ab:	55                   	push   %bp
     1ac:	1e                   	push   %ds
     1ad:	06                   	push   %es
     1ae:	16                   	push   %ss
     1af:	b8 00 00             	mov    $0x0,%ax
     1b2:	8e d8                	mov    %ax,%ds
     1b4:	8c c8                	mov    %cs,%ax
     1b6:	c7 06 d8 00 c9 01    	movw   $0x1c9,0xd8
     1bc:	a3 da 00             	mov    %ax,0xda
     1bf:	17                   	pop    %ss
     1c0:	07                   	pop    %es
     1c1:	1f                   	pop    %ds
     1c2:	5d                   	pop    %bp
     1c3:	5f                   	pop    %di
     1c4:	5e                   	pop    %si
     1c5:	5a                   	pop    %dx
     1c6:	59                   	pop    %cx
     1c7:	5b                   	pop    %bx
     1c8:	c3                   	ret    

000001c9 <new_int36>:
new_int36():
     1c9:	50                   	push   %ax
     1ca:	53                   	push   %bx
     1cb:	51                   	push   %cx
     1cc:	52                   	push   %dx
     1cd:	56                   	push   %si
     1ce:	57                   	push   %di
     1cf:	55                   	push   %bp
     1d0:	1e                   	push   %ds
     1d1:	06                   	push   %es
     1d2:	16                   	push   %ss
     1d3:	8e c0                	mov    %ax,%es
     1d5:	26 88 0f             	mov    %cl,%es:(%bx)
     1d8:	17                   	pop    %ss
     1d9:	07                   	pop    %es
     1da:	1f                   	pop    %ds
     1db:	5d                   	pop    %bp
     1dc:	5f                   	pop    %di
     1dd:	5e                   	pop    %si
     1de:	5a                   	pop    %dx
     1df:	59                   	pop    %cx
     1e0:	5b                   	pop    %bx
     1e1:	58                   	pop    %ax
     1e2:	cf                   	iret   

000001e3 <init_process>:
init_process():
/mnt/e/code/my_operating_system/os/kernel/start.c:27


    return 0;
}

void init_process(int process_index){
     1e3:	67 66 8b 54 24 04    	mov    0x4(%esp),%edx
/mnt/e/code/my_operating_system/os/kernel/start.c:30
    PCB_t* this_process = &process_block[process_index];
    u16 segment = 0x2000;
    this_process->regs.ss = segment;
     1e9:	66 89 d0             	mov    %edx,%eax
     1ec:	66 c1 e0 06          	shl    $0x6,%eax
     1f0:	67 66 8d 0c 90       	lea    (%eax,%edx,4),%ecx
     1f5:	67 c7 81 00 2d 00 00 	movw   $0x2000,0x2d00(%ecx)
     1fc:	00 20 
/mnt/e/code/my_operating_system/os/kernel/start.c:31
    this_process->regs.sp = 0x5000;
     1fe:	67 c7 81 02 2d 00 00 	movw   $0x5000,0x2d02(%ecx)
     205:	00 50 
/mnt/e/code/my_operating_system/os/kernel/start.c:32
    this_process->regs.ds = segment;
     207:	67 c7 81 04 2d 00 00 	movw   $0x2000,0x2d04(%ecx)
     20e:	00 20 
/mnt/e/code/my_operating_system/os/kernel/start.c:33
    this_process->regs.es = segment;
     210:	67 c7 81 06 2d 00 00 	movw   $0x2000,0x2d06(%ecx)
     217:	00 20 
/mnt/e/code/my_operating_system/os/kernel/start.c:34
    this_process->regs.edi = 0;
     219:	67 66 c7 81 08 2d 00 	movl   $0x0,0x2d08(%ecx)
     220:	00 00 00 00 00 
/mnt/e/code/my_operating_system/os/kernel/start.c:35
    this_process->regs.esi = 0;
     225:	67 66 c7 81 0c 2d 00 	movl   $0x0,0x2d0c(%ecx)
     22c:	00 00 00 00 00 
/mnt/e/code/my_operating_system/os/kernel/start.c:36
    this_process->regs.ebp = 0x5000;
     231:	67 66 c7 81 10 2d 00 	movl   $0x5000,0x2d10(%ecx)
     238:	00 00 50 00 00 
/mnt/e/code/my_operating_system/os/kernel/start.c:37
    this_process->regs.kernel_esp = 0;
     23d:	67 66 c7 81 14 2d 00 	movl   $0x0,0x2d14(%ecx)
     244:	00 00 00 00 00 
/mnt/e/code/my_operating_system/os/kernel/start.c:38
    this_process->regs.ebx = 0;
     249:	67 66 c7 81 18 2d 00 	movl   $0x0,0x2d18(%ecx)
     250:	00 00 00 00 00 
/mnt/e/code/my_operating_system/os/kernel/start.c:39
    this_process->regs.edx = 0;
     255:	67 66 c7 81 1c 2d 00 	movl   $0x0,0x2d1c(%ecx)
     25c:	00 00 00 00 00 
/mnt/e/code/my_operating_system/os/kernel/start.c:40
    this_process->regs.ecx = 0;
     261:	67 66 c7 81 20 2d 00 	movl   $0x0,0x2d20(%ecx)
     268:	00 00 00 00 00 
/mnt/e/code/my_operating_system/os/kernel/start.c:41
    this_process->regs.eax = 0;
     26d:	67 66 c7 81 24 2d 00 	movl   $0x0,0x2d24(%ecx)
     274:	00 00 00 00 00 
/mnt/e/code/my_operating_system/os/kernel/start.c:42
    this_process->regs.ip = 0x0000;
     279:	67 c7 81 28 2d 00 00 	movw   $0x0,0x2d28(%ecx)
     280:	00 00 
/mnt/e/code/my_operating_system/os/kernel/start.c:43
    this_process->regs.cs = segment;
     282:	67 c7 81 2a 2d 00 00 	movw   $0x2000,0x2d2a(%ecx)
     289:	00 20 
/mnt/e/code/my_operating_system/os/kernel/start.c:44
    this_process->regs.flags = 0x1202;
     28b:	67 c7 81 2c 2d 00 00 	movw   $0x1202,0x2d2c(%ecx)
     292:	02 12 
/mnt/e/code/my_operating_system/os/kernel/start.c:45
    this_process->pid = process_index;
     294:	67 66 89 91 30 2d 00 	mov    %edx,0x2d30(%ecx)
     29b:	00 
     29c:	66 c3                	retl   

0000029e <cstart>:
cstart():
/mnt/e/code/my_operating_system/os/kernel/start.c:11
#include "../include/system_call.h"
#include "../include/fsystem.h"
#include "../include/proc.h"

void test_system_call();
int cstart(){
     29e:	66 83 ec 0c          	sub    $0xc,%esp
/mnt/e/code/my_operating_system/os/kernel/start.c:13
    // 初始化文件系统
    init_fsystem();
     2a2:	66 e8 41 05 00 00    	calll  7e9 <init_fsystem>
/mnt/e/code/my_operating_system/os/kernel/start.c:15
    // 清屏
    clean_screen();
     2a8:	66 e8 e4 12 00 00    	calll  1592 <clean_screen>
/mnt/e/code/my_operating_system/os/kernel/start.c:17
    // 将光标设置为0 TODO:
    set_cursor(0);
     2ae:	66 83 ec 0c          	sub    $0xc,%esp
     2b2:	66 6a 00             	pushl  $0x0
     2b5:	66 e8 f3 08 00 00    	calll  bae <set_cursor>
/mnt/e/code/my_operating_system/os/kernel/start.c:19
    // install_system_call(2, test_system_call);
    fs_load_by_name("test_b.bin", 0x2000, 0x0000);
     2bb:	66 83 c4 0c          	add    $0xc,%esp
     2bf:	66 6a 00             	pushl  $0x0
     2c2:	66 68 00 20 00 00    	pushl  $0x2000
     2c8:	66 68 86 17 00 00    	pushl  $0x1786
     2ce:	66 e8 86 07 00 00    	calll  a5a <fs_load_by_name>
/mnt/e/code/my_operating_system/os/kernel/start.c:21
    // while (1){}
    init_process(0);
     2d4:	67 66 c7 04 24 00 00 	movl   $0x0,(%esp)
     2db:	00 00 
     2dd:	66 e8 00 ff ff ff    	calll  1e3 <init_process>
/mnt/e/code/my_operating_system/os/kernel/start.c:25


    return 0;
}
     2e3:	66 b8 00 00 00 00    	mov    $0x0,%eax
     2e9:	66 83 c4 1c          	add    $0x1c,%esp
     2ed:	66 c3                	retl   

000002ef <parser>:
parser():
/mnt/e/code/my_operating_system/os/kernel/tty.c:89
    }
    return ;
}


void parser(){
     2ef:	66 56                	push   %esi
     2f1:	66 53                	push   %ebx
     2f3:	66 83 ec 74          	sub    $0x74,%esp
/mnt/e/code/my_operating_system/os/kernel/tty.c:93
    char arguments[10][10];
    int input_start = 0;
    int input_end = 0;
    int arguments_num = 0;
     2f7:	66 be 00 00 00 00    	mov    $0x0,%esi
/mnt/e/code/my_operating_system/os/kernel/tty.c:92


void parser(){
    char arguments[10][10];
    int input_start = 0;
    int input_end = 0;
     2fd:	66 bb 00 00 00 00    	mov    $0x0,%ebx
/mnt/e/code/my_operating_system/os/kernel/tty.c:91
}


void parser(){
    char arguments[10][10];
    int input_start = 0;
     303:	66 ba 00 00 00 00    	mov    $0x0,%edx
/mnt/e/code/my_operating_system/os/kernel/tty.c:95
    int input_end = 0;
    int arguments_num = 0;
    // 使用空格作为分隔符，将输入缓冲区的内容分割成几个参数分别存进arguments数组中
    while (input_end <= command_line_cursor){
     309:	eb 64                	jmp    36f <parser+0x80>
/mnt/e/code/my_operating_system/os/kernel/tty.c:96
        if(input_buf[input_end] == ' ' || input_buf[input_end] == '\0'){
     30b:	67 66 0f b6 83 40 21 	movzbl 0x2140(%ebx),%eax
     312:	00 00 
     314:	3c 20                	cmp    $0x20,%al
     316:	0f 94 c1             	sete   %cl
     319:	84 c0                	test   %al,%al
     31b:	0f 94 c0             	sete   %al
     31e:	08 c1                	or     %al,%cl
     320:	74 49                	je     36b <parser+0x7c>
/mnt/e/code/my_operating_system/os/kernel/tty.c:97
            if (input_start == input_end){ // 如果并没有参数，那么继续
     322:	66 39 da             	cmp    %ebx,%edx
     325:	75 0a                	jne    331 <parser+0x42>
/mnt/e/code/my_operating_system/os/kernel/tty.c:98
                input_start++;
     327:	66 83 c2 01          	add    $0x1,%edx
/mnt/e/code/my_operating_system/os/kernel/tty.c:99
                input_end++;
     32b:	66 83 c3 01          	add    $0x1,%ebx
/mnt/e/code/my_operating_system/os/kernel/tty.c:100
                continue;
     32f:	eb 3e                	jmp    36f <parser+0x80>
/mnt/e/code/my_operating_system/os/kernel/tty.c:103
            }
            else {// 如果有参数，并且已经读到末尾了，那就复制到相应的区域
                strncpy(arguments[arguments_num], input_buf+input_start, input_end-input_start);
     331:	66 89 d9             	mov    %ebx,%ecx
     334:	66 29 d1             	sub    %edx,%ecx
     337:	67 66 8d 04 b6       	lea    (%esi,%esi,4),%eax
     33c:	67 66 8d 44 44 0c    	lea    0xc(%esp,%eax,2),%eax
     342:	66 83 ec 04          	sub    $0x4,%esp
     346:	66 51                	push   %ecx
     348:	66 81 c2 40 21 00 00 	add    $0x2140,%edx
     34f:	66 52                	push   %edx
     351:	66 50                	push   %eax
     353:	66 e8 0f 13 00 00    	calll  1668 <strncpy>
/mnt/e/code/my_operating_system/os/kernel/tty.c:104
                input_end++;
     359:	67 66 8d 53 01       	lea    0x1(%ebx),%edx
/mnt/e/code/my_operating_system/os/kernel/tty.c:106
                input_start = input_end;
                arguments_num++;
     35e:	66 83 c6 01          	add    $0x1,%esi
     362:	66 83 c4 10          	add    $0x10,%esp
/mnt/e/code/my_operating_system/os/kernel/tty.c:104
                input_end++;
                continue;
            }
            else {// 如果有参数，并且已经读到末尾了，那就复制到相应的区域
                strncpy(arguments[arguments_num], input_buf+input_start, input_end-input_start);
                input_end++;
     366:	66 89 d3             	mov    %edx,%ebx
     369:	eb 04                	jmp    36f <parser+0x80>
/mnt/e/code/my_operating_system/os/kernel/tty.c:110
                input_start = input_end;
                arguments_num++;
            }
        }
        else {// 有参数，还没有读到末尾
            input_end++;
     36b:	66 83 c3 01          	add    $0x1,%ebx
/mnt/e/code/my_operating_system/os/kernel/tty.c:95
    char arguments[10][10];
    int input_start = 0;
    int input_end = 0;
    int arguments_num = 0;
    // 使用空格作为分隔符，将输入缓冲区的内容分割成几个参数分别存进arguments数组中
    while (input_end <= command_line_cursor){
     36f:	66 3b 1e 20 21       	cmp    0x2120,%ebx
     374:	7e 95                	jle    30b <parser+0x1c>
/mnt/e/code/my_operating_system/os/kernel/tty.c:117
        }
    }

    // 完成分词，开始进行解析。

    if(!strcmp(arguments[0],"run")){// 如果返回0，就是相等了
     376:	66 83 ec 08          	sub    $0x8,%esp
     37a:	66 68 91 17 00 00    	pushl  $0x1791
     380:	67 66 8d 44 24 18    	lea    0x18(%esp),%eax
     386:	66 50                	push   %eax
     388:	66 e8 16 13 00 00    	calll  16a4 <strcmp>
     38e:	66 83 c4 10          	add    $0x10,%esp
     392:	66 85 c0             	test   %eax,%eax
     395:	75 31                	jne    3c8 <parser+0xd9>
/mnt/e/code/my_operating_system/os/kernel/tty.c:122
        // 运行一个用户程序。
        // 先从软盘中加载一个指定程序到内存处，然后开始执行。
        // 考虑维护一个空闲空间的指针，然后每加载一个程序，如果可行的话。
        void (**my_program)();
        *my_program = 0x4000;
     397:	66 bb 00 00 00 00    	mov    $0x0,%ebx
     39d:	67 66 c7 03 00 40 00 	movl   $0x4000,(%ebx)
     3a4:	00 
/mnt/e/code/my_operating_system/os/kernel/tty.c:123
        fs_load_by_name(arguments[1],*my_program);
     3a5:	66 83 ec 08          	sub    $0x8,%esp
     3a9:	66 68 00 40 00 00    	pushl  $0x4000
     3af:	67 66 8d 44 24 22    	lea    0x22(%esp),%eax
     3b5:	66 50                	push   %eax
     3b7:	66 e8 9d 06 00 00    	calll  a5a <fs_load_by_name>
/mnt/e/code/my_operating_system/os/kernel/tty.c:124
        (*my_program)();
     3bd:	67 66 ff 13          	calll  *(%ebx)
     3c1:	66 83 c4 10          	add    $0x10,%esp
     3c5:	e9 1b 01             	jmp    4e3 <parser+0x1f4>
/mnt/e/code/my_operating_system/os/kernel/tty.c:126
    }
    else if(!strcmp(arguments[0],"ls") && arguments_num == 1){
     3c8:	66 83 ec 08          	sub    $0x8,%esp
     3cc:	66 68 95 17 00 00    	pushl  $0x1795
     3d2:	67 66 8d 44 24 18    	lea    0x18(%esp),%eax
     3d8:	66 50                	push   %eax
     3da:	66 e8 c4 12 00 00    	calll  16a4 <strcmp>
     3e0:	66 83 c4 10          	add    $0x10,%esp
     3e4:	66 85 c0             	test   %eax,%eax
     3e7:	75 23                	jne    40c <parser+0x11d>
/mnt/e/code/my_operating_system/os/kernel/tty.c:126 (discriminator 1)
     3e9:	66 83 fe 01          	cmp    $0x1,%esi
     3ed:	75 1d                	jne    40c <parser+0x11d>
/mnt/e/code/my_operating_system/os/kernel/tty.c:127
        printf("\n\n");
     3ef:	66 83 ec 0c          	sub    $0xc,%esp
     3f3:	66 68 98 17 00 00    	pushl  $0x1798
     3f9:	66 e8 f8 0d 00 00    	calll  11f7 <printf>
/mnt/e/code/my_operating_system/os/kernel/tty.c:128
        fs_show_root_file_table();
     3ff:	66 e8 d5 06 00 00    	calll  ada <fs_show_root_file_table>
/mnt/e/code/my_operating_system/os/kernel/tty.c:126
        void (**my_program)();
        *my_program = 0x4000;
        fs_load_by_name(arguments[1],*my_program);
        (*my_program)();
    }
    else if(!strcmp(arguments[0],"ls") && arguments_num == 1){
     405:	66 83 c4 10          	add    $0x10,%esp
     409:	e9 d7 00             	jmp    4e3 <parser+0x1f4>
/mnt/e/code/my_operating_system/os/kernel/tty.c:130
        printf("\n\n");
        fs_show_root_file_table();
    }
    else if(!strcmp(arguments[0],"reboot") && arguments_num == 1){
     40c:	66 83 ec 08          	sub    $0x8,%esp
     410:	66 68 9b 17 00 00    	pushl  $0x179b
     416:	67 66 8d 44 24 18    	lea    0x18(%esp),%eax
     41c:	66 50                	push   %eax
     41e:	66 e8 80 12 00 00    	calll  16a4 <strcmp>
     424:	66 83 c4 10          	add    $0x10,%esp
     428:	66 85 c0             	test   %eax,%eax
     42b:	75 23                	jne    450 <parser+0x161>
/mnt/e/code/my_operating_system/os/kernel/tty.c:130 (discriminator 1)
     42d:	66 83 fe 01          	cmp    $0x1,%esi
     431:	75 1d                	jne    450 <parser+0x161>
/mnt/e/code/my_operating_system/os/kernel/tty.c:131
        printf("\n\n");
     433:	66 83 ec 0c          	sub    $0xc,%esp
     437:	66 68 98 17 00 00    	pushl  $0x1798
     43d:	66 e8 b4 0d 00 00    	calll  11f7 <printf>
/mnt/e/code/my_operating_system/os/kernel/tty.c:132
        reboot();
     443:	66 e8 f1 11 00 00    	calll  163a <reboot>
/mnt/e/code/my_operating_system/os/kernel/tty.c:130
    }
    else if(!strcmp(arguments[0],"ls") && arguments_num == 1){
        printf("\n\n");
        fs_show_root_file_table();
    }
    else if(!strcmp(arguments[0],"reboot") && arguments_num == 1){
     449:	66 83 c4 10          	add    $0x10,%esp
     44d:	e9 93 00             	jmp    4e3 <parser+0x1f4>
/mnt/e/code/my_operating_system/os/kernel/tty.c:134
        printf("\n\n");
        reboot();
    }
    else if(!strcmp(arguments[0],"help") && arguments_num == 1){
     450:	66 83 ec 08          	sub    $0x8,%esp
     454:	66 68 a2 17 00 00    	pushl  $0x17a2
     45a:	67 66 8d 44 24 18    	lea    0x18(%esp),%eax
     460:	66 50                	push   %eax
     462:	66 e8 3c 12 00 00    	calll  16a4 <strcmp>
     468:	66 83 c4 10          	add    $0x10,%esp
     46c:	66 85 c0             	test   %eax,%eax
     46f:	75 58                	jne    4c9 <parser+0x1da>
/mnt/e/code/my_operating_system/os/kernel/tty.c:134 (discriminator 1)
     471:	66 83 fe 01          	cmp    $0x1,%esi
     475:	75 52                	jne    4c9 <parser+0x1da>
/mnt/e/code/my_operating_system/os/kernel/tty.c:135
        printf("\n\n");
     477:	66 83 ec 0c          	sub    $0xc,%esp
     47b:	66 68 98 17 00 00    	pushl  $0x1798
     481:	66 e8 70 0d 00 00    	calll  11f7 <printf>
/mnt/e/code/my_operating_system/os/kernel/tty.c:136
        printf("ls        : show the file in the root folder.\n");
     487:	67 66 c7 04 24 04 20 	movl   $0x2004,(%esp)
     48e:	00 00 
     490:	66 e8 61 0d 00 00    	calll  11f7 <printf>
/mnt/e/code/my_operating_system/os/kernel/tty.c:137
        printf("run [name]: run the file in the root folder.\n");
     496:	67 66 c7 04 24 34 20 	movl   $0x2034,(%esp)
     49d:	00 00 
     49f:	66 e8 52 0d 00 00    	calll  11f7 <printf>
/mnt/e/code/my_operating_system/os/kernel/tty.c:138
        printf("help      : show the help message.\n");
     4a5:	67 66 c7 04 24 64 20 	movl   $0x2064,(%esp)
     4ac:	00 00 
     4ae:	66 e8 43 0d 00 00    	calll  11f7 <printf>
/mnt/e/code/my_operating_system/os/kernel/tty.c:139
        printf("reboot    : reboot the machine.\n");
     4b4:	67 66 c7 04 24 88 20 	movl   $0x2088,(%esp)
     4bb:	00 00 
     4bd:	66 e8 34 0d 00 00    	calll  11f7 <printf>
     4c3:	66 83 c4 10          	add    $0x10,%esp
     4c7:	eb 1a                	jmp    4e3 <parser+0x1f4>
/mnt/e/code/my_operating_system/os/kernel/tty.c:142
    }
    else {
        printf("\n%s : command not found! \n", input_buf);
     4c9:	66 83 ec 08          	sub    $0x8,%esp
     4cd:	66 68 40 21 00 00    	pushl  $0x2140
     4d3:	66 68 a7 17 00 00    	pushl  $0x17a7
     4d9:	66 e8 18 0d 00 00    	calll  11f7 <printf>
     4df:	66 83 c4 10          	add    $0x10,%esp
/mnt/e/code/my_operating_system/os/kernel/tty.c:144
    }
    int current_cursor = get_cursor();
     4e3:	66 e8 37 07 00 00    	calll  c20 <get_cursor>
     4e9:	66 0f b7 c0          	movzwl %ax,%eax
/mnt/e/code/my_operating_system/os/kernel/tty.c:145
    command_line_row = (current_cursor / 80);
     4ed:	66 ba 67 66 66 66    	mov    $0x66666667,%edx
     4f3:	66 f7 ea             	imul   %edx
     4f6:	66 c1 fa 05          	sar    $0x5,%edx
     4fa:	66 89 16 f8 20       	mov    %edx,0x20f8
/mnt/e/code/my_operating_system/os/kernel/tty.c:148
    // printf("arguments: %d|%s|%s|",arguments_num, arguments[0],arguments[1]);
    return ;
}
     4ff:	66 83 c4 74          	add    $0x74,%esp
     503:	66 5b                	pop    %ebx
     505:	66 5e                	pop    %esi
     507:	66 c3                	retl   

00000509 <create_a_line>:
create_a_line():
/mnt/e/code/my_operating_system/os/kernel/tty.c:151

// 转移光标到命令行下一行,更新缓冲区，并且打印信息
void create_a_line(){
     509:	66 83 ec 2c          	sub    $0x2c,%esp
/mnt/e/code/my_operating_system/os/kernel/tty.c:152
    char message[30] = "walker@walker-pc ~ $ \0";
     50d:	66 a1 d4 20          	mov    0x20d4,%eax
     511:	67 66 89 44 24 02    	mov    %eax,0x2(%esp)
     517:	66 a1 d8 20          	mov    0x20d8,%eax
     51b:	67 66 89 44 24 06    	mov    %eax,0x6(%esp)
     521:	66 a1 dc 20          	mov    0x20dc,%eax
     525:	67 66 89 44 24 0a    	mov    %eax,0xa(%esp)
     52b:	66 a1 e0 20          	mov    0x20e0,%eax
     52f:	67 66 89 44 24 0e    	mov    %eax,0xe(%esp)
     535:	66 a1 e4 20          	mov    0x20e4,%eax
     539:	67 66 89 44 24 12    	mov    %eax,0x12(%esp)
     53f:	66 0f b7 06 e8 20    	movzwl 0x20e8,%eax
     545:	67 89 44 24 16       	mov    %ax,0x16(%esp)
     54a:	66 0f b6 06 ea 20    	movzbl 0x20ea,%eax
     550:	67 88 44 24 18       	mov    %al,0x18(%esp)
     555:	67 66 c7 44 24 19 00 	movl   $0x0,0x19(%esp)
     55c:	00 00 00 
     55f:	67 c7 44 24 1d 00 00 	movw   $0x0,0x1d(%esp)
     566:	67 c6 44 24 1f 00    	movb   $0x0,0x1f(%esp)
/mnt/e/code/my_operating_system/os/kernel/tty.c:153
    for (int i = 0; i < MAX_BUF; i++){
     56c:	66 b8 00 00 00 00    	mov    $0x0,%eax
     572:	eb 0c                	jmp    580 <create_a_line+0x77>
/mnt/e/code/my_operating_system/os/kernel/tty.c:154 (discriminator 3)
        input_buf[i] = 0;
     574:	67 c6 80 40 21 00 00 	movb   $0x0,0x2140(%eax)
     57b:	00 
/mnt/e/code/my_operating_system/os/kernel/tty.c:153 (discriminator 3)
}

// 转移光标到命令行下一行,更新缓冲区，并且打印信息
void create_a_line(){
    char message[30] = "walker@walker-pc ~ $ \0";
    for (int i = 0; i < MAX_BUF; i++){
     57c:	66 83 c0 01          	add    $0x1,%eax
/mnt/e/code/my_operating_system/os/kernel/tty.c:153 (discriminator 1)
     580:	66 83 f8 63          	cmp    $0x63,%eax
     584:	7e ee                	jle    574 <create_a_line+0x6b>
/mnt/e/code/my_operating_system/os/kernel/tty.c:156
        input_buf[i] = 0;
    }
    message_length = strlen(message);
     586:	66 83 ec 0c          	sub    $0xc,%esp
     58a:	67 66 8d 44 24 0e    	lea    0xe(%esp),%eax
     590:	66 50                	push   %eax
     592:	66 e8 b4 10 00 00    	calll  164c <strlen>
     598:	66 a3 24 21          	mov    %eax,0x2124
/mnt/e/code/my_operating_system/os/kernel/tty.c:157
    command_line_row = command_line_row + (command_line_cursor + message_length)/80 + 1;
     59c:	66 03 06 20 21       	add    0x2120,%eax
     5a1:	66 89 c1             	mov    %eax,%ecx
     5a4:	66 ba 67 66 66 66    	mov    $0x66666667,%edx
     5aa:	66 f7 ea             	imul   %edx
     5ad:	66 c1 fa 05          	sar    $0x5,%edx
     5b1:	66 c1 f9 1f          	sar    $0x1f,%ecx
     5b5:	66 29 ca             	sub    %ecx,%edx
     5b8:	66 89 d0             	mov    %edx,%eax
     5bb:	66 03 06 f8 20       	add    0x20f8,%eax
     5c0:	66 83 c0 01          	add    $0x1,%eax
     5c4:	66 a3 f8 20          	mov    %eax,0x20f8
/mnt/e/code/my_operating_system/os/kernel/tty.c:158
    while(command_line_row > 23){
     5c8:	66 83 c4 10          	add    $0x10,%esp
     5cc:	eb 0c                	jmp    5da <create_a_line+0xd1>
/mnt/e/code/my_operating_system/os/kernel/tty.c:159
        scroll_screen();
     5ce:	66 e8 d8 0f 00 00    	calll  15ac <scroll_screen>
/mnt/e/code/my_operating_system/os/kernel/tty.c:160
        command_line_row--;
     5d4:	66 83 2e f8 20 01    	subl   $0x1,0x20f8
/mnt/e/code/my_operating_system/os/kernel/tty.c:158
    for (int i = 0; i < MAX_BUF; i++){
        input_buf[i] = 0;
    }
    message_length = strlen(message);
    command_line_row = command_line_row + (command_line_cursor + message_length)/80 + 1;
    while(command_line_row > 23){
     5da:	66 a1 f8 20          	mov    0x20f8,%eax
     5de:	66 83 f8 17          	cmp    $0x17,%eax
     5e2:	7f ea                	jg     5ce <create_a_line+0xc5>
/mnt/e/code/my_operating_system/os/kernel/tty.c:162
        scroll_screen();
        command_line_row--;
    }
    command_line_cursor = 0;
     5e4:	66 c7 06 20 21 00 00 	movl   $0x0,0x2120
     5eb:	00 00 
/mnt/e/code/my_operating_system/os/kernel/tty.c:163
    set_cursor(command_line_row * 80);
     5ed:	66 83 ec 0c          	sub    $0xc,%esp
     5f1:	67 66 8d 04 80       	lea    (%eax,%eax,4),%eax
     5f6:	66 c1 e0 04          	shl    $0x4,%eax
     5fa:	66 0f b7 d0          	movzwl %ax,%edx
     5fe:	66 52                	push   %edx
     600:	66 e8 a8 05 00 00    	calll  bae <set_cursor>
/mnt/e/code/my_operating_system/os/kernel/tty.c:165
    // printf("%d", command_line_row);
    printf("%s", message);
     606:	66 83 c4 08          	add    $0x8,%esp
     60a:	67 66 8d 44 24 0a    	lea    0xa(%esp),%eax
     610:	66 50                	push   %eax
     612:	66 68 c2 17 00 00    	pushl  $0x17c2
     618:	66 e8 d9 0b 00 00    	calll  11f7 <printf>
/mnt/e/code/my_operating_system/os/kernel/tty.c:166
}
     61e:	66 83 c4 3c          	add    $0x3c,%esp
     622:	66 c3                	retl   

00000624 <tty>:
tty():
/mnt/e/code/my_operating_system/os/kernel/tty.c:19
int message_length = 0;
int command_line_cursor = 0; // 光标在输入区的偏移量
char input_buf[MAX_BUF]; // 输入缓存区


void tty(){
     624:	66 56                	push   %esi
     626:	66 53                	push   %ebx
     628:	66 83 ec 04          	sub    $0x4,%esp
/mnt/e/code/my_operating_system/os/kernel/tty.c:21
    int keyboard_flag = 0;
    new_line_flag = 1;
     62c:	66 c7 06 f4 20 01 00 	movl   $0x1,0x20f4
     633:	00 00 
/mnt/e/code/my_operating_system/os/kernel/tty.c:22
    command_line_row = -1;
     635:	66 c7 06 f8 20 ff ff 	movl   $0xffffffff,0x20f8
     63c:	ff ff 
/mnt/e/code/my_operating_system/os/kernel/tty.c:23
    clean_screen();
     63e:	66 e8 4e 0f 00 00    	calll  1592 <clean_screen>
/mnt/e/code/my_operating_system/os/kernel/tty.c:24
    set_cursor(1974);
     644:	66 83 ec 0c          	sub    $0xc,%esp
     648:	66 68 b6 07 00 00    	pushl  $0x7b6
     64e:	66 e8 5a 05 00 00    	calll  bae <set_cursor>
/mnt/e/code/my_operating_system/os/kernel/tty.c:25
    set_cursor(0);
     654:	67 66 c7 04 24 00 00 	movl   $0x0,(%esp)
     65b:	00 00 
     65d:	66 e8 4b 05 00 00    	calll  bae <set_cursor>
/mnt/e/code/my_operating_system/os/kernel/tty.c:26
    print_my_name();
     663:	66 e8 a7 0f 00 00    	calll  1610 <print_my_name>
     669:	66 83 c4 10          	add    $0x10,%esp
/mnt/e/code/my_operating_system/os/kernel/tty.c:29
    while (1){
        // 使用缓冲区数据更新
        if (new_line_flag){
     66d:	66 83 3e f4 20 00    	cmpl   $0x0,0x20f4
     673:	74 0f                	je     684 <tty+0x60>
/mnt/e/code/my_operating_system/os/kernel/tty.c:30
            create_a_line();
     675:	66 e8 8e fe ff ff    	calll  509 <create_a_line>
/mnt/e/code/my_operating_system/os/kernel/tty.c:31
            new_line_flag = 0;
     67b:	66 c7 06 f4 20 00 00 	movl   $0x0,0x20f4
     682:	00 00 
/mnt/e/code/my_operating_system/os/kernel/tty.c:34
        }

        if(command_line_row == 23 && message_length + command_line_cursor > 80){
     684:	66 83 3e f8 20 17    	cmpl   $0x17,0x20f8
     68a:	75 2f                	jne    6bb <tty+0x97>
/mnt/e/code/my_operating_system/os/kernel/tty.c:34 (discriminator 1)
     68c:	66 a1 20 21          	mov    0x2120,%eax
     690:	66 03 06 24 21       	add    0x2124,%eax
     695:	66 83 f8 50          	cmp    $0x50,%eax
     699:	7e 20                	jle    6bb <tty+0x97>
/mnt/e/code/my_operating_system/os/kernel/tty.c:35
            scroll_screen();
     69b:	66 e8 0b 0f 00 00    	calll  15ac <scroll_screen>
/mnt/e/code/my_operating_system/os/kernel/tty.c:36
            command_line_row--;
     6a1:	66 83 2e f8 20 01    	subl   $0x1,0x20f8
/mnt/e/code/my_operating_system/os/kernel/tty.c:37
            set_cursor(1840);
     6a7:	66 83 ec 0c          	sub    $0xc,%esp
     6ab:	66 68 30 07 00 00    	pushl  $0x730
     6b1:	66 e8 f7 04 00 00    	calll  bae <set_cursor>
     6b7:	66 83 c4 10          	add    $0x10,%esp
/mnt/e/code/my_operating_system/os/kernel/tty.c:39
        }
        putc(' ');// 用来删除光标处的文字，与输入退格的时候光标-1配合使用
     6bb:	66 83 ec 0c          	sub    $0xc,%esp
     6bf:	66 6a 20             	pushl  $0x20
     6c2:	66 e8 b4 05 00 00    	calll  c7c <putc>
/mnt/e/code/my_operating_system/os/kernel/tty.c:42

        // command_line_row = get_cursor() / 80;
        set_cursor(80*command_line_row + message_length);
     6c8:	66 8b 16 f8 20       	mov    0x20f8,%edx
     6cd:	67 66 8d 14 92       	lea    (%edx,%edx,4),%edx
     6d2:	66 89 d0             	mov    %edx,%eax
     6d5:	66 c1 e0 04          	shl    $0x4,%eax
     6d9:	03 06 24 21          	add    0x2124,%ax
     6dd:	66 0f b7 c0          	movzwl %ax,%eax
     6e1:	67 66 89 04 24       	mov    %eax,(%esp)
     6e6:	66 e8 c2 04 00 00    	calll  bae <set_cursor>
/mnt/e/code/my_operating_system/os/kernel/tty.c:43
        puts(input_buf, command_line_cursor);
     6ec:	66 83 c4 08          	add    $0x8,%esp
     6f0:	66 ff 36 20 21       	pushl  0x2120
     6f5:	66 68 40 21 00 00    	pushl  $0x2140
     6fb:	66 e8 70 07 00 00    	calll  e71 <puts>
/mnt/e/code/my_operating_system/os/kernel/tty.c:46

        // 更新完了 检测键盘
        keyboard_flag = check_keyboard();
     701:	66 e8 75 0e 00 00    	calll  157c <check_keyboard>
/mnt/e/code/my_operating_system/os/kernel/tty.c:49

        // 如果返回1，则有输入，处理输入信息，否则继续循环。
        if (keyboard_flag){
     707:	66 83 c4 10          	add    $0x10,%esp
     70b:	85 c0                	test   %ax,%ax
     70d:	0f 84 5c ff          	je     66d <tty+0x49>
/mnt/e/code/my_operating_system/os/kernel/tty.c:51
            // 处理键盘事件
            u16 keyboard_code =  get_keyboard();
     711:	66 e8 75 0e 00 00    	calll  158c <get_keyboard>
/mnt/e/code/my_operating_system/os/kernel/tty.c:52
            u8 ascii_code = keyboard_code;
     717:	66 89 c3             	mov    %eax,%ebx
/mnt/e/code/my_operating_system/os/kernel/tty.c:54
            u8 scan_code = keyboard_code >> 8;
            if (isprint(ascii_code)){
     71a:	66 83 ec 0c          	sub    $0xc,%esp
     71e:	66 0f b6 c0          	movzbl %al,%eax
     722:	66 50                	push   %eax
     724:	66 e8 28 0c 00 00    	calll  1352 <isprint>
     72a:	66 83 c4 10          	add    $0x10,%esp
     72e:	66 85 c0             	test   %eax,%eax
     731:	74 20                	je     753 <tty+0x12f>
/mnt/e/code/my_operating_system/os/kernel/tty.c:55
                if (command_line_cursor <= MAX_BUF){
     733:	66 a1 20 21          	mov    0x2120,%eax
     737:	66 83 f8 64          	cmp    $0x64,%eax
     73b:	0f 8f 2e ff          	jg     66d <tty+0x49>
/mnt/e/code/my_operating_system/os/kernel/tty.c:56
                    input_buf[command_line_cursor++] = ascii_code;
     73f:	67 66 8d 50 01       	lea    0x1(%eax),%edx
     744:	66 89 16 20 21       	mov    %edx,0x2120
     749:	67 88 98 40 21 00 00 	mov    %bl,0x2140(%eax)
     750:	e9 1a ff             	jmp    66d <tty+0x49>
/mnt/e/code/my_operating_system/os/kernel/tty.c:59
                }
            }
            else if (ascii_code == 13){
     753:	80 fb 0d             	cmp    $0xd,%bl
     756:	75 1e                	jne    776 <tty+0x152>
/mnt/e/code/my_operating_system/os/kernel/tty.c:60
                new_line_flag = 1;
     758:	66 c7 06 f4 20 01 00 	movl   $0x1,0x20f4
     75f:	00 00 
/mnt/e/code/my_operating_system/os/kernel/tty.c:61
                input_buf[command_line_cursor] = '\0';
     761:	66 a1 20 21          	mov    0x2120,%eax
     765:	67 c6 80 40 21 00 00 	movb   $0x0,0x2140(%eax)
     76c:	00 
/mnt/e/code/my_operating_system/os/kernel/tty.c:62
                parser();
     76d:	66 e8 7c fb ff ff    	calll  2ef <parser>
     773:	e9 f7 fe             	jmp    66d <tty+0x49>
/mnt/e/code/my_operating_system/os/kernel/tty.c:64
            }
            else if (ascii_code == 8){
     776:	80 fb 08             	cmp    $0x8,%bl
     779:	75 3e                	jne    7b9 <tty+0x195>
/mnt/e/code/my_operating_system/os/kernel/tty.c:65
                if(command_line_cursor){
     77b:	66 a1 20 21          	mov    0x2120,%eax
     77f:	66 85 c0             	test   %eax,%eax
     782:	0f 84 e7 fe          	je     66d <tty+0x49>
/mnt/e/code/my_operating_system/os/kernel/tty.c:66
                    input_buf[--command_line_cursor] = 0;
     786:	67 66 8d 50 ff       	lea    -0x1(%eax),%edx
     78b:	66 89 16 20 21       	mov    %edx,0x2120
     790:	67 c6 80 3f 21 00 00 	movb   $0x0,0x213f(%eax)
     797:	00 
/mnt/e/code/my_operating_system/os/kernel/tty.c:68
                    // 将光标设置为前一个位置，方便删除
                    int cur_cursor = get_cursor();
     798:	66 e8 82 04 00 00    	calll  c20 <get_cursor>
/mnt/e/code/my_operating_system/os/kernel/tty.c:69
                    set_cursor(cur_cursor-1);
     79e:	66 83 ec 0c          	sub    $0xc,%esp
     7a2:	66 83 e8 01          	sub    $0x1,%eax
     7a6:	66 0f b7 c0          	movzwl %ax,%eax
     7aa:	66 50                	push   %eax
     7ac:	66 e8 fc 03 00 00    	calll  bae <set_cursor>
     7b2:	66 83 c4 10          	add    $0x10,%esp
     7b6:	e9 b4 fe             	jmp    66d <tty+0x49>
/mnt/e/code/my_operating_system/os/kernel/tty.c:72
                }
            }
            else if (ascii_code == 27){
     7b9:	80 fb 1b             	cmp    $0x1b,%bl
     7bc:	0f 85 ad fe          	jne    66d <tty+0x49>
/mnt/e/code/my_operating_system/os/kernel/tty.c:73
                __asm__("mov $0x4c00, %ax");
     7c0:	b8 00 4c             	mov    $0x4c00,%ax
/mnt/e/code/my_operating_system/os/kernel/tty.c:74
                __asm__("int $0x40");
     7c3:	cd 40                	int    $0x40
     7c5:	e9 a5 fe             	jmp    66d <tty+0x49>

000007c8 <tty_scroll_screen>:
tty_scroll_screen():
/mnt/e/code/my_operating_system/os/kernel/tty.c:169
    // printf("%d", command_line_row);
    printf("%s", message);
}


void tty_scroll_screen(){
     7c8:	66 83 ec 0c          	sub    $0xc,%esp
/mnt/e/code/my_operating_system/os/kernel/tty.c:170
    if (get_cursor()/80 > 24){
     7cc:	66 e8 4e 04 00 00    	calll  c20 <get_cursor>
     7d2:	3d cf 07             	cmp    $0x7cf,%ax
     7d5:	76 0c                	jbe    7e3 <tty_scroll_screen+0x1b>
/mnt/e/code/my_operating_system/os/kernel/tty.c:171
        scroll_screen();
     7d7:	66 e8 cf 0d 00 00    	calll  15ac <scroll_screen>
/mnt/e/code/my_operating_system/os/kernel/tty.c:172
        command_line_row--;
     7dd:	66 83 2e f8 20 01    	subl   $0x1,0x20f8
/mnt/e/code/my_operating_system/os/kernel/tty.c:175
    }
    return ;
     7e3:	66 83 c4 0c          	add    $0xc,%esp
     7e7:	66 c3                	retl   

000007e9 <init_fsystem>:
init_fsystem():
/mnt/e/code/my_operating_system/os/service/fsystem.c:14
FileDescriptor root[56];
u16 root_sector;
u16 first_cluster_by_sector;
u16 cluster2sector;

void init_fsystem(){
     7e9:	66 83 ec 0c          	sub    $0xc,%esp
/mnt/e/code/my_operating_system/os/service/fsystem.c:15
    cluster2sector = 1;
     7ed:	c7 06 e0 2c 01 00    	movw   $0x1,0x2ce0
/mnt/e/code/my_operating_system/os/service/fsystem.c:16
    root_sector = 37;
     7f3:	c7 06 c0 21 25 00    	movw   $0x25,0x21c0
/mnt/e/code/my_operating_system/os/service/fsystem.c:17
    first_cluster_by_sector = root_sector + 1;  
     7f9:	c7 06 e2 2c 26 00    	movw   $0x26,0x2ce2
/mnt/e/code/my_operating_system/os/service/fsystem.c:18
    read_n_sector(root_sector,1, 0x1000, root);
     7ff:	66 b8 e0 25 00 00    	mov    $0x25e0,%eax
     805:	66 0f b7 c0          	movzwl %ax,%eax
     809:	66 50                	push   %eax
     80b:	66 68 00 10 00 00    	pushl  $0x1000
     811:	66 6a 01             	pushl  $0x1
     814:	66 6a 25             	pushl  $0x25
     817:	66 e8 e8 0b 00 00    	calll  1405 <read_n_sector>
/mnt/e/code/my_operating_system/os/service/fsystem.c:19
    read_n_sector(1,2,0x1000, FAT_table);// 这个会覆盖掉root吗？
     81d:	66 b8 e0 21 00 00    	mov    $0x21e0,%eax
     823:	66 0f b7 c0          	movzwl %ax,%eax
     827:	66 50                	push   %eax
     829:	66 68 00 10 00 00    	pushl  $0x1000
     82f:	66 6a 02             	pushl  $0x2
     832:	66 6a 01             	pushl  $0x1
     835:	66 e8 ca 0b 00 00    	calll  1405 <read_n_sector>
/mnt/e/code/my_operating_system/os/service/fsystem.c:27
    // puti(FAT_table[0]);
    // puti(root[0].cluster_number);
    // puts(&root[0], 10);
    // puts(&root[1], 10);
    // puts(&root[2], 10);
}
     83b:	66 83 c4 2c          	add    $0x2c,%esp
     83f:	66 c3                	retl   

00000841 <_fs_find_descriptor_number_by_name>:
_fs_find_descriptor_number_by_name():
/mnt/e/code/my_operating_system/os/service/fsystem.c:29

u16 _fs_find_descriptor_number_by_name(char * file_name){
     841:	66 57                	push   %edi
     843:	66 56                	push   %esi
     845:	66 53                	push   %ebx
     847:	67 66 8b 7c 24 10    	mov    0x10(%esp),%edi
/mnt/e/code/my_operating_system/os/service/fsystem.c:30
    int file_name_length = strlen(file_name);
     84d:	66 83 ec 0c          	sub    $0xc,%esp
     851:	66 57                	push   %edi
     853:	66 e8 f3 0d 00 00    	calll  164c <strlen>
     859:	66 89 c6             	mov    %eax,%esi
/mnt/e/code/my_operating_system/os/service/fsystem.c:31
    if (file_name_length >= 11) file_name_length = 11;
     85c:	66 83 c4 10          	add    $0x10,%esp
     860:	66 83 f8 0a          	cmp    $0xa,%eax
     864:	7e 06                	jle    86c <_fs_find_descriptor_number_by_name+0x2b>
     866:	66 be 0b 00 00 00    	mov    $0xb,%esi
/mnt/e/code/my_operating_system/os/service/fsystem.c:33
    // TODO:这里的10是文件数，需要使用常量代替
    for (int i = 0; i < 10; i++){
     86c:	66 bb 00 00 00 00    	mov    $0x0,%ebx
     872:	eb 2f                	jmp    8a3 <_fs_find_descriptor_number_by_name+0x62>
/mnt/e/code/my_operating_system/os/service/fsystem.c:34
        if (!strncmp(&root[i], file_name, file_name_length)){
     874:	66 89 d8             	mov    %ebx,%eax
     877:	66 c1 e0 05          	shl    $0x5,%eax
     87b:	66 05 e0 25 00 00    	add    $0x25e0,%eax
     881:	66 83 ec 04          	sub    $0x4,%esp
     885:	66 56                	push   %esi
     887:	66 57                	push   %edi
     889:	66 50                	push   %eax
     88b:	66 e8 7f 0e 00 00    	calll  1710 <strncmp>
     891:	66 83 c4 10          	add    $0x10,%esp
     895:	66 85 c0             	test   %eax,%eax
     898:	75 05                	jne    89f <_fs_find_descriptor_number_by_name+0x5e>
/mnt/e/code/my_operating_system/os/service/fsystem.c:35
            return i;
     89a:	66 89 d8             	mov    %ebx,%eax
     89d:	eb 10                	jmp    8af <_fs_find_descriptor_number_by_name+0x6e>
/mnt/e/code/my_operating_system/os/service/fsystem.c:33 (discriminator 2)

u16 _fs_find_descriptor_number_by_name(char * file_name){
    int file_name_length = strlen(file_name);
    if (file_name_length >= 11) file_name_length = 11;
    // TODO:这里的10是文件数，需要使用常量代替
    for (int i = 0; i < 10; i++){
     89f:	66 83 c3 01          	add    $0x1,%ebx
/mnt/e/code/my_operating_system/os/service/fsystem.c:33 (discriminator 1)
     8a3:	66 83 fb 09          	cmp    $0x9,%ebx
     8a7:	7e cb                	jle    874 <_fs_find_descriptor_number_by_name+0x33>
/mnt/e/code/my_operating_system/os/service/fsystem.c:38
        if (!strncmp(&root[i], file_name, file_name_length)){
            return i;
        }
    }
    return -1;
     8a9:	66 b8 ff ff ff ff    	mov    $0xffffffff,%eax
/mnt/e/code/my_operating_system/os/service/fsystem.c:39
}
     8af:	66 5b                	pop    %ebx
     8b1:	66 5e                	pop    %esi
     8b3:	66 5f                	pop    %edi
     8b5:	66 c3                	retl   

000008b7 <_fs_find_cluster_code_by_name>:
_fs_find_cluster_code_by_name():
/mnt/e/code/my_operating_system/os/service/fsystem.c:41

u16 _fs_find_cluster_code_by_name(char * file_name){
     8b7:	66 83 ec 18          	sub    $0x18,%esp
/mnt/e/code/my_operating_system/os/service/fsystem.c:42
    int index = _fs_find_descriptor_number_by_name(file_name);
     8bb:	67 66 ff 74 24 1c    	pushl  0x1c(%esp)
     8c1:	66 e8 7a ff ff ff    	calll  841 <_fs_find_descriptor_number_by_name>
     8c7:	66 0f b7 c0          	movzwl %ax,%eax
/mnt/e/code/my_operating_system/os/service/fsystem.c:44
    if (index != -1)
        return root[index].cluster_code;
     8cb:	66 c1 e0 05          	shl    $0x5,%eax
     8cf:	67 66 0f b7 80 fa 25 	movzwl 0x25fa(%eax),%eax
     8d6:	00 00 
/mnt/e/code/my_operating_system/os/service/fsystem.c:46
    return 0;
}
     8d8:	66 83 c4 1c          	add    $0x1c,%esp
     8dc:	66 c3                	retl   

000008de <_fs_get_file_size_by_cluster_code>:
_fs_get_file_size_by_cluster_code():
/mnt/e/code/my_operating_system/os/service/fsystem.c:48

u16 _fs_get_file_size_by_cluster_code(u16 cluster_code){
     8de:	67 66 0f b7 54 24 04 	movzwl 0x4(%esp),%edx
/mnt/e/code/my_operating_system/os/service/fsystem.c:49
    int size = 0;
     8e5:	66 b8 00 00 00 00    	mov    $0x0,%eax
/mnt/e/code/my_operating_system/os/service/fsystem.c:50
    while (0x0002 <= cluster_code && cluster_code <= 0xFFEF){
     8eb:	eb 1b                	jmp    908 <_fs_get_file_size_by_cluster_code+0x2a>
/mnt/e/code/my_operating_system/os/service/fsystem.c:51
        size += 512*cluster2sector;
     8ed:	66 0f b7 0e e0 2c    	movzwl 0x2ce0,%ecx
     8f3:	66 c1 e1 09          	shl    $0x9,%ecx
     8f7:	66 01 c8             	add    %ecx,%eax
/mnt/e/code/my_operating_system/os/service/fsystem.c:52
        int sector_number = first_cluster_by_sector + (cluster_code-2)*cluster2sector;
     8fa:	66 0f b7 d2          	movzwl %dx,%edx
/mnt/e/code/my_operating_system/os/service/fsystem.c:53
        cluster_code = FAT_table[cluster_code];
     8fe:	67 66 0f b7 94 12 e0 	movzwl 0x21e0(%edx,%edx,1),%edx
     905:	21 00 00 
/mnt/e/code/my_operating_system/os/service/fsystem.c:50
    return 0;
}

u16 _fs_get_file_size_by_cluster_code(u16 cluster_code){
    int size = 0;
    while (0x0002 <= cluster_code && cluster_code <= 0xFFEF){
     908:	67 66 8d 4a fe       	lea    -0x2(%edx),%ecx
     90d:	83 f9 ed             	cmp    $0xffed,%cx
     910:	76 db                	jbe    8ed <_fs_get_file_size_by_cluster_code+0xf>
/mnt/e/code/my_operating_system/os/service/fsystem.c:56
        size += 512*cluster2sector;
        int sector_number = first_cluster_by_sector + (cluster_code-2)*cluster2sector;
        cluster_code = FAT_table[cluster_code];
    }
    return size;
}
     912:	66 f3 c3             	repz retl 

00000915 <_fs_show_file_by_descriptor_number>:
_fs_show_file_by_descriptor_number():
/mnt/e/code/my_operating_system/os/service/fsystem.c:58

void _fs_show_file_by_descriptor_number(u16 index){
     915:	66 56                	push   %esi
     917:	66 53                	push   %ebx
     919:	66 83 ec 08          	sub    $0x8,%esp
/mnt/e/code/my_operating_system/os/service/fsystem.c:59
    int cluster_code = root[index].cluster_code;
     91d:	67 66 0f b7 44 24 14 	movzwl 0x14(%esp),%eax
     924:	66 89 c6             	mov    %eax,%esi
     927:	66 c1 e6 05          	shl    $0x5,%esi
     92b:	67 66 0f b7 9e fa 25 	movzwl 0x25fa(%esi),%ebx
     932:	00 00 
     934:	66 81 c6 e0 25 00 00 	add    $0x25e0,%esi
/mnt/e/code/my_operating_system/os/service/fsystem.c:60
    printf("%d, %d\n" , index,cluster_code);
     93b:	66 53                	push   %ebx
     93d:	66 50                	push   %eax
     93f:	66 68 c5 17 00 00    	pushl  $0x17c5
     945:	66 e8 ac 08 00 00    	calll  11f7 <printf>
/mnt/e/code/my_operating_system/os/service/fsystem.c:62
    printf("%s   | %d byte |", (char *)&root[index],
                             _fs_get_file_size_by_cluster_code(cluster_code));
     94b:	67 66 89 1c 24       	mov    %ebx,(%esp)
     950:	66 e8 88 ff ff ff    	calll  8de <_fs_get_file_size_by_cluster_code>
     956:	66 83 c4 0c          	add    $0xc,%esp
/mnt/e/code/my_operating_system/os/service/fsystem.c:61
}

void _fs_show_file_by_descriptor_number(u16 index){
    int cluster_code = root[index].cluster_code;
    printf("%d, %d\n" , index,cluster_code);
    printf("%s   | %d byte |", (char *)&root[index],
     95a:	66 0f b7 c0          	movzwl %ax,%eax
     95e:	66 50                	push   %eax
     960:	66 56                	push   %esi
     962:	66 68 cd 17 00 00    	pushl  $0x17cd
     968:	66 e8 89 08 00 00    	calll  11f7 <printf>
/mnt/e/code/my_operating_system/os/service/fsystem.c:63
                             _fs_get_file_size_by_cluster_code(cluster_code));
    while (0x0002 <= cluster_code && cluster_code <= 0xFFEF){
     96e:	66 83 c4 10          	add    $0x10,%esp
     972:	eb 20                	jmp    994 <_fs_show_file_by_descriptor_number+0x7f>
/mnt/e/code/my_operating_system/os/service/fsystem.c:64
        printf("-%d", cluster_code);
     974:	66 83 ec 08          	sub    $0x8,%esp
     978:	66 53                	push   %ebx
     97a:	66 68 de 17 00 00    	pushl  $0x17de
     980:	66 e8 71 08 00 00    	calll  11f7 <printf>
/mnt/e/code/my_operating_system/os/service/fsystem.c:65
        cluster_code = FAT_table[cluster_code];
     986:	67 66 0f b7 9c 1b e0 	movzwl 0x21e0(%ebx,%ebx,1),%ebx
     98d:	21 00 00 
     990:	66 83 c4 10          	add    $0x10,%esp
/mnt/e/code/my_operating_system/os/service/fsystem.c:63
void _fs_show_file_by_descriptor_number(u16 index){
    int cluster_code = root[index].cluster_code;
    printf("%d, %d\n" , index,cluster_code);
    printf("%s   | %d byte |", (char *)&root[index],
                             _fs_get_file_size_by_cluster_code(cluster_code));
    while (0x0002 <= cluster_code && cluster_code <= 0xFFEF){
     994:	67 66 8d 43 fe       	lea    -0x2(%ebx),%eax
     999:	66 3d ed ff 00 00    	cmp    $0xffed,%eax
     99f:	76 d3                	jbe    974 <_fs_show_file_by_descriptor_number+0x5f>
/mnt/e/code/my_operating_system/os/service/fsystem.c:67
        printf("-%d", cluster_code);
        cluster_code = FAT_table[cluster_code];
    }
    printf("-|\n");
     9a1:	66 83 ec 0c          	sub    $0xc,%esp
     9a5:	66 68 e2 17 00 00    	pushl  $0x17e2
     9ab:	66 e8 46 08 00 00    	calll  11f7 <printf>
/mnt/e/code/my_operating_system/os/service/fsystem.c:69
    return ;
}
     9b1:	66 83 c4 14          	add    $0x14,%esp
     9b5:	66 5b                	pop    %ebx
     9b7:	66 5e                	pop    %esi
     9b9:	66 c3                	retl   

000009bb <_fs_load_by_cluster_code>:
_fs_load_by_cluster_code():
/mnt/e/code/my_operating_system/os/service/fsystem.c:71

u16 _fs_load_by_cluster_code(u16 cluster_code, u16 segment, u16 offset){
     9bb:	66 55                	push   %ebp
     9bd:	66 57                	push   %edi
     9bf:	66 56                	push   %esi
     9c1:	66 53                	push   %ebx
     9c3:	66 83 ec 0c          	sub    $0xc,%esp
     9c7:	67 66 0f b7 5c 24 20 	movzwl 0x20(%esp),%ebx
     9ce:	67 66 0f b7 6c 24 24 	movzwl 0x24(%esp),%ebp
     9d5:	67 66 0f b7 74 24 28 	movzwl 0x28(%esp),%esi
/mnt/e/code/my_operating_system/os/service/fsystem.c:72
    int size = 0;
     9dc:	66 bf 00 00 00 00    	mov    $0x0,%edi
/mnt/e/code/my_operating_system/os/service/fsystem.c:73
    while (0x0002 <= cluster_code && cluster_code <= 0xFFEF){
     9e2:	eb 5b                	jmp    a3f <_fs_load_by_cluster_code+0x84>
/mnt/e/code/my_operating_system/os/service/fsystem.c:74
        size += 512*cluster2sector;
     9e4:	66 0f b7 16 e0 2c    	movzwl 0x2ce0,%edx
     9ea:	66 89 d0             	mov    %edx,%eax
     9ed:	66 c1 e0 09          	shl    $0x9,%eax
     9f1:	66 01 c7             	add    %eax,%edi
/mnt/e/code/my_operating_system/os/service/fsystem.c:75
        int sector_number = first_cluster_by_sector + (cluster_code-2)*cluster2sector;
     9f4:	66 0f b7 0e e2 2c    	movzwl 0x2ce2,%ecx
     9fa:	66 0f b7 db          	movzwl %bx,%ebx
     9fe:	67 66 8d 43 fe       	lea    -0x2(%ebx),%eax
     a03:	66 0f af c2          	imul   %edx,%eax
     a07:	66 01 c8             	add    %ecx,%eax
/mnt/e/code/my_operating_system/os/service/fsystem.c:76
        read_n_sector(sector_number, cluster2sector, segment, offset);
     a0a:	66 0f b7 ce          	movzwl %si,%ecx
     a0e:	66 51                	push   %ecx
     a10:	66 0f b7 cd          	movzwl %bp,%ecx
     a14:	66 51                	push   %ecx
     a16:	66 52                	push   %edx
     a18:	66 0f b7 c0          	movzwl %ax,%eax
     a1c:	66 50                	push   %eax
     a1e:	66 e8 e1 09 00 00    	calll  1405 <read_n_sector>
/mnt/e/code/my_operating_system/os/service/fsystem.c:77
        offset = offset+cluster2sector*512;
     a24:	66 0f b7 06 e0 2c    	movzwl 0x2ce0,%eax
     a2a:	66 c1 e0 09          	shl    $0x9,%eax
     a2e:	66 01 c6             	add    %eax,%esi
/mnt/e/code/my_operating_system/os/service/fsystem.c:78
        cluster_code = FAT_table[cluster_code];
     a31:	67 66 0f b7 9c 1b e0 	movzwl 0x21e0(%ebx,%ebx,1),%ebx
     a38:	21 00 00 
     a3b:	66 83 c4 10          	add    $0x10,%esp
/mnt/e/code/my_operating_system/os/service/fsystem.c:73
    return ;
}

u16 _fs_load_by_cluster_code(u16 cluster_code, u16 segment, u16 offset){
    int size = 0;
    while (0x0002 <= cluster_code && cluster_code <= 0xFFEF){
     a3f:	67 66 8d 43 fe       	lea    -0x2(%ebx),%eax
     a44:	83 f8 ed             	cmp    $0xffed,%ax
     a47:	76 9b                	jbe    9e4 <_fs_load_by_cluster_code+0x29>
/mnt/e/code/my_operating_system/os/service/fsystem.c:81
        read_n_sector(sector_number, cluster2sector, segment, offset);
        offset = offset+cluster2sector*512;
        cluster_code = FAT_table[cluster_code];
    }
    return size;
}
     a49:	66 89 f8             	mov    %edi,%eax
     a4c:	66 83 c4 0c          	add    $0xc,%esp
     a50:	66 5b                	pop    %ebx
     a52:	66 5e                	pop    %esi
     a54:	66 5f                	pop    %edi
     a56:	66 5d                	pop    %ebp
     a58:	66 c3                	retl   

00000a5a <fs_load_by_name>:
fs_load_by_name():
/mnt/e/code/my_operating_system/os/service/fsystem.c:84


u16 fs_load_by_name(char * file_name, u16 segment, u16 offset){
     a5a:	66 56                	push   %esi
     a5c:	66 53                	push   %ebx
     a5e:	66 83 ec 10          	sub    $0x10,%esp
     a62:	67 66 8b 5c 24 20    	mov    0x20(%esp),%ebx
     a68:	67 66 8b 74 24 24    	mov    0x24(%esp),%esi
/mnt/e/code/my_operating_system/os/service/fsystem.c:85
    int cluster_code = _fs_find_cluster_code_by_name(file_name);
     a6e:	67 66 ff 74 24 1c    	pushl  0x1c(%esp)
     a74:	66 e8 3d fe ff ff    	calll  8b7 <_fs_find_cluster_code_by_name>
     a7a:	66 0f b7 c0          	movzwl %ax,%eax
/mnt/e/code/my_operating_system/os/service/fsystem.c:86
    if (cluster_code){
     a7e:	66 83 c4 10          	add    $0x10,%esp
     a82:	66 85 c0             	test   %eax,%eax
     a85:	74 1e                	je     aa5 <fs_load_by_name+0x4b>
/mnt/e/code/my_operating_system/os/service/fsystem.c:87
        return _fs_load_by_cluster_code(cluster_code, segment, offset);
     a87:	66 83 ec 04          	sub    $0x4,%esp
     a8b:	66 0f b7 f6          	movzwl %si,%esi
     a8f:	66 56                	push   %esi
     a91:	66 0f b7 db          	movzwl %bx,%ebx
     a95:	66 53                	push   %ebx
     a97:	66 50                	push   %eax
     a99:	66 e8 1c ff ff ff    	calll  9bb <_fs_load_by_cluster_code>
     a9f:	66 83 c4 10          	add    $0x10,%esp
     aa3:	eb 06                	jmp    aab <fs_load_by_name+0x51>
/mnt/e/code/my_operating_system/os/service/fsystem.c:90
    }
    else {
        return 0;
     aa5:	66 b8 00 00 00 00    	mov    $0x0,%eax
/mnt/e/code/my_operating_system/os/service/fsystem.c:92
    }
}
     aab:	66 83 c4 04          	add    $0x4,%esp
     aaf:	66 5b                	pop    %ebx
     ab1:	66 5e                	pop    %esi
     ab3:	66 c3                	retl   

00000ab5 <fs_get_file_size>:
fs_get_file_size():
/mnt/e/code/my_operating_system/os/service/fsystem.c:95


u16 fs_get_file_size(char * file_name){
     ab5:	66 83 ec 18          	sub    $0x18,%esp
/mnt/e/code/my_operating_system/os/service/fsystem.c:96
    int cluster_code = _fs_find_cluster_code_by_name(file_name);
     ab9:	67 66 ff 74 24 1c    	pushl  0x1c(%esp)
     abf:	66 e8 f2 fd ff ff    	calll  8b7 <_fs_find_cluster_code_by_name>
/mnt/e/code/my_operating_system/os/service/fsystem.c:97
    return _fs_get_file_size_by_cluster_code(cluster_code);
     ac5:	66 0f b7 c0          	movzwl %ax,%eax
     ac9:	67 66 89 04 24       	mov    %eax,(%esp)
     ace:	66 e8 0a fe ff ff    	calll  8de <_fs_get_file_size_by_cluster_code>
/mnt/e/code/my_operating_system/os/service/fsystem.c:98
}
     ad4:	66 83 c4 1c          	add    $0x1c,%esp
     ad8:	66 c3                	retl   

00000ada <fs_show_root_file_table>:
fs_show_root_file_table():
/mnt/e/code/my_operating_system/os/service/fsystem.c:100

void fs_show_root_file_table(){
     ada:	66 53                	push   %ebx
     adc:	66 83 ec 08          	sub    $0x8,%esp
/mnt/e/code/my_operating_system/os/service/fsystem.c:101
    printf("%s   | %s | %s\n", "file name ", "file size", "cluster");
     ae0:	66 68 e6 17 00 00    	pushl  $0x17e6
     ae6:	66 68 ee 17 00 00    	pushl  $0x17ee
     aec:	66 68 f8 17 00 00    	pushl  $0x17f8
     af2:	66 68 03 18 00 00    	pushl  $0x1803
     af8:	66 e8 f9 06 00 00    	calll  11f7 <printf>
/mnt/e/code/my_operating_system/os/service/fsystem.c:102
    printf("------------------------------------\n\r");
     afe:	67 66 c7 04 24 ac 20 	movl   $0x20ac,(%esp)
     b05:	00 00 
     b07:	66 e8 ea 06 00 00    	calll  11f7 <printf>
/mnt/e/code/my_operating_system/os/service/fsystem.c:104
    int file_number = 9;// TODO:文件数量需要设置！
    for(int i = 0; i < file_number; i++){
     b0d:	66 83 c4 10          	add    $0x10,%esp
     b11:	66 bb 00 00 00 00    	mov    $0x0,%ebx
     b17:	eb 18                	jmp    b31 <fs_show_root_file_table+0x57>
/mnt/e/code/my_operating_system/os/service/fsystem.c:105 (discriminator 3)
        _fs_show_file_by_descriptor_number(i);
     b19:	66 83 ec 0c          	sub    $0xc,%esp
     b1d:	66 0f b7 c3          	movzwl %bx,%eax
     b21:	66 50                	push   %eax
     b23:	66 e8 ec fd ff ff    	calll  915 <_fs_show_file_by_descriptor_number>
/mnt/e/code/my_operating_system/os/service/fsystem.c:104 (discriminator 3)

void fs_show_root_file_table(){
    printf("%s   | %s | %s\n", "file name ", "file size", "cluster");
    printf("------------------------------------\n\r");
    int file_number = 9;// TODO:文件数量需要设置！
    for(int i = 0; i < file_number; i++){
     b29:	66 83 c3 01          	add    $0x1,%ebx
     b2d:	66 83 c4 10          	add    $0x10,%esp
/mnt/e/code/my_operating_system/os/service/fsystem.c:104 (discriminator 1)
     b31:	66 83 fb 08          	cmp    $0x8,%ebx
     b35:	7e e2                	jle    b19 <fs_show_root_file_table+0x3f>
/mnt/e/code/my_operating_system/os/service/fsystem.c:108
        _fs_show_file_by_descriptor_number(i);
    }
    return ;
}
     b37:	66 83 c4 08          	add    $0x8,%esp
     b3b:	66 5b                	pop    %ebx
     b3d:	66 c3                	retl   

00000b3f <fs_show_file_by_name>:
fs_show_file_by_name():
/mnt/e/code/my_operating_system/os/service/fsystem.c:110

void fs_show_file_by_name(char * file_name){
     b3f:	66 83 ec 18          	sub    $0x18,%esp
/mnt/e/code/my_operating_system/os/service/fsystem.c:111
    int descriptor_index = _fs_find_descriptor_number_by_name(file_name);
     b43:	67 66 ff 74 24 1c    	pushl  0x1c(%esp)
     b49:	66 e8 f2 fc ff ff    	calll  841 <_fs_find_descriptor_number_by_name>
/mnt/e/code/my_operating_system/os/service/fsystem.c:112
    _fs_show_file_by_descriptor_number(descriptor_index);
     b4f:	66 0f b7 c0          	movzwl %ax,%eax
     b53:	67 66 89 04 24       	mov    %eax,(%esp)
     b58:	66 e8 b7 fd ff ff    	calll  915 <_fs_show_file_by_descriptor_number>
/mnt/e/code/my_operating_system/os/service/fsystem.c:114
    return ;
}
     b5e:	66 83 c4 1c          	add    $0x1c,%esp
     b62:	66 c3                	retl   

00000b64 <fs_show_floppy_infomation>:
fs_show_floppy_infomation():
/mnt/e/code/my_operating_system/os/service/fsystem.c:117


void fs_show_floppy_infomation(){
     b64:	66 f3 c3             	repz retl 

00000b67 <_put_char>:
_put_char():
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:5
#include "../include/basic.h"
#include "../include/type.h"
#include "../include/string.h"

void _put_char(char c, u16 cursor_index){
     b67:	66 53                	push   %ebx
     b69:	66 83 ec 10          	sub    $0x10,%esp
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:7
    int _address = 0xb8000;
    int _offset = cursor_index * 2;
     b6d:	67 66 0f b7 5c 24 1c 	movzwl 0x1c(%esp),%ebx
     b74:	66 01 db             	add    %ebx,%ebx
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:8
    write_memory_byte(_address+_offset, c);
     b77:	67 66 8d 83 00 80 0b 	lea    0xb8000(%ebx),%eax
     b7e:	00 
     b7f:	67 66 0f b6 54 24 18 	movzbl 0x18(%esp),%edx
     b86:	66 52                	push   %edx
     b88:	66 50                	push   %eax
     b8a:	66 e8 9c 09 00 00    	calll  152c <write_memory_byte>
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:9
    write_memory_byte(_address+_offset+1, 0x1f);
     b90:	66 81 c3 01 80 0b 00 	add    $0xb8001,%ebx
     b97:	66 83 c4 08          	add    $0x8,%esp
     b9b:	66 6a 1f             	pushl  $0x1f
     b9e:	66 53                	push   %ebx
     ba0:	66 e8 86 09 00 00    	calll  152c <write_memory_byte>
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:11
    return ;
}
     ba6:	66 83 c4 18          	add    $0x18,%esp
     baa:	66 5b                	pop    %ebx
     bac:	66 c3                	retl   

00000bae <set_cursor>:
set_cursor():
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:13

void set_cursor(u16 cursor_index){
     bae:	66 56                	push   %esi
     bb0:	66 53                	push   %ebx
     bb2:	66 83 ec 0c          	sub    $0xc,%esp
     bb6:	67 66 8b 5c 24 18    	mov    0x18(%esp),%ebx
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:16
    // short cursor_index = 80 * row + column;     // 计算光标寄存器的值
    u8 low_eight = cursor_index; // 取低八位，高位被截断
    u8 high_eight = cursor_index >> 8; // 取高八位
     bbc:	66 89 d8             	mov    %ebx,%eax
     bbf:	c1 e8 08             	shr    $0x8,%ax
     bc2:	66 89 c6             	mov    %eax,%esi
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:17
    write_port_byte(0x3d4,0x0e);// 指定索引寄存器为光标寄存器的高八位
     bc5:	66 6a 0e             	pushl  $0xe
     bc8:	66 68 d4 03 00 00    	pushl  $0x3d4
     bce:	66 e8 0c 09 00 00    	calll  14e0 <write_port_byte>
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:18
    write_port_byte(0x3d5, high_eight);// 将光标索引高八位写入端口
     bd4:	66 83 c4 08          	add    $0x8,%esp
     bd8:	66 89 f0             	mov    %esi,%eax
     bdb:	66 0f b6 f0          	movzbl %al,%esi
     bdf:	66 56                	push   %esi
     be1:	66 68 d5 03 00 00    	pushl  $0x3d5
     be7:	66 e8 f3 08 00 00    	calll  14e0 <write_port_byte>
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:19
    write_port_byte(0x3d4,0x0f);// 指定索引寄存器为光标寄存器的低八位
     bed:	66 83 c4 08          	add    $0x8,%esp
     bf1:	66 6a 0f             	pushl  $0xf
     bf4:	66 68 d4 03 00 00    	pushl  $0x3d4
     bfa:	66 e8 e0 08 00 00    	calll  14e0 <write_port_byte>
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:20
    write_port_byte(0x3d5, low_eight);// 将光标索引低八位写入端口
     c00:	66 83 c4 08          	add    $0x8,%esp
     c04:	66 0f b6 db          	movzbl %bl,%ebx
     c08:	66 53                	push   %ebx
     c0a:	66 68 d5 03 00 00    	pushl  $0x3d5
     c10:	66 e8 ca 08 00 00    	calll  14e0 <write_port_byte>
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:22
    return ;
}
     c16:	66 83 c4 14          	add    $0x14,%esp
     c1a:	66 5b                	pop    %ebx
     c1c:	66 5e                	pop    %esi
     c1e:	66 c3                	retl   

00000c20 <get_cursor>:
get_cursor():
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:24

u16 get_cursor(){
     c20:	66 53                	push   %ebx
     c22:	66 83 ec 10          	sub    $0x10,%esp
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:27
    u8 low_eight = 0, high_eight = 0;
    u16 cursor_index = 0;
    write_port_byte(0x3d4,0x0e);// 指定索引寄存器为光标寄存器的高八位
     c26:	66 6a 0e             	pushl  $0xe
     c29:	66 68 d4 03 00 00    	pushl  $0x3d4
     c2f:	66 e8 ab 08 00 00    	calll  14e0 <write_port_byte>
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:28
    high_eight = read_port_byte(0x3d5);// 将光标索引高八位写入端口
     c35:	67 66 c7 04 24 d5 03 	movl   $0x3d5,(%esp)
     c3c:	00 00 
     c3e:	66 e8 c4 08 00 00    	calll  1508 <read_port_byte>
     c44:	66 89 c3             	mov    %eax,%ebx
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:29
    write_port_byte(0x3d4,0x0f);// 指定索引寄存器为光标寄存器的低八位
     c47:	66 83 c4 08          	add    $0x8,%esp
     c4b:	66 6a 0f             	pushl  $0xf
     c4e:	66 68 d4 03 00 00    	pushl  $0x3d4
     c54:	66 e8 86 08 00 00    	calll  14e0 <write_port_byte>
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:30
    low_eight = read_port_byte(0x3d5);// 将光标索引低八位写入端口
     c5a:	67 66 c7 04 24 d5 03 	movl   $0x3d5,(%esp)
     c61:	00 00 
     c63:	66 e8 9f 08 00 00    	calll  1508 <read_port_byte>
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:32
    cursor_index = high_eight;
    cursor_index = (cursor_index << 8) + low_eight;
     c69:	66 c1 e3 08          	shl    $0x8,%ebx
     c6d:	66 0f b6 c0          	movzbl %al,%eax
     c71:	66 01 d8             	add    %ebx,%eax
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:34
    return cursor_index;
}
     c74:	66 83 c4 18          	add    $0x18,%esp
     c78:	66 5b                	pop    %ebx
     c7a:	66 c3                	retl   

00000c7c <putc>:
putc():
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:36

void putc(char c){
     c7c:	66 57                	push   %edi
     c7e:	66 56                	push   %esi
     c80:	66 53                	push   %ebx
     c82:	67 66 8b 7c 24 10    	mov    0x10(%esp),%edi
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:37
    u16 cursor_index = get_cursor();
     c88:	66 e8 92 ff ff ff    	calll  c20 <get_cursor>
     c8e:	66 89 c6             	mov    %eax,%esi
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:38
    u16 row = cursor_index / 80;
     c91:	66 0f b7 d8          	movzwl %ax,%ebx
     c95:	66 69 db cd cc 00 00 	imul   $0xcccd,%ebx,%ebx
     c9c:	66 c1 eb 10          	shr    $0x10,%ebx
     ca0:	c1 eb 06             	shr    $0x6,%bx
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:40
    u16 col = cursor_index % 80;
    if (cursor_index >= 1920){
     ca3:	3d 7f 07             	cmp    $0x77f,%ax
     ca6:	76 0c                	jbe    cb4 <putc+0x38>
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:41
        scroll_screen();
     ca8:	66 e8 fe 08 00 00    	calll  15ac <scroll_screen>
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:42
        cursor_index = 1840;
     cae:	66 be 30 07 00 00    	mov    $0x730,%esi
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:44
    }
    switch (c) {
     cb4:	66 89 f8             	mov    %edi,%eax
     cb7:	3c 0a                	cmp    $0xa,%al
     cb9:	74 06                	je     cc1 <putc+0x45>
     cbb:	3c 0d                	cmp    $0xd,%al
     cbd:	74 25                	je     ce4 <putc+0x68>
     cbf:	eb 45                	jmp    d06 <putc+0x8a>
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:46
        case '\n':
            set_cursor((row+1)*80); // 回车，移到下一行
     cc1:	66 83 ec 0c          	sub    $0xc,%esp
     cc5:	67 66 8d 5c 9b 05    	lea    0x5(%ebx,%ebx,4),%ebx
     ccb:	66 89 d8             	mov    %ebx,%eax
     cce:	66 c1 e0 04          	shl    $0x4,%eax
     cd2:	66 0f b7 c0          	movzwl %ax,%eax
     cd6:	66 50                	push   %eax
     cd8:	66 e8 d0 fe ff ff    	calll  bae <set_cursor>
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:47
            break;
     cde:	66 83 c4 10          	add    $0x10,%esp
     ce2:	eb 52                	jmp    d36 <putc+0xba>
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:49
        case '\r':
            set_cursor(row*80);    // 移到本行开头处
     ce4:	66 83 ec 0c          	sub    $0xc,%esp
     ce8:	67 66 8d 1c 9b       	lea    (%ebx,%ebx,4),%ebx
     ced:	66 89 d8             	mov    %ebx,%eax
     cf0:	66 c1 e0 04          	shl    $0x4,%eax
     cf4:	66 0f b7 c0          	movzwl %ax,%eax
     cf8:	66 50                	push   %eax
     cfa:	66 e8 ae fe ff ff    	calll  bae <set_cursor>
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:50
            break;
     d00:	66 83 c4 10          	add    $0x10,%esp
     d04:	eb 30                	jmp    d36 <putc+0xba>
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:52
        default:
            _put_char(c, cursor_index);
     d06:	66 83 ec 08          	sub    $0x8,%esp
     d0a:	66 0f b7 c6          	movzwl %si,%eax
     d0e:	66 50                	push   %eax
     d10:	66 89 f8             	mov    %edi,%eax
     d13:	66 0f be f8          	movsbl %al,%edi
     d17:	66 57                	push   %edi
     d19:	66 e8 48 fe ff ff    	calll  b67 <_put_char>
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:53
            set_cursor(cursor_index+1);
     d1f:	66 83 c6 01          	add    $0x1,%esi
     d23:	66 0f b7 f6          	movzwl %si,%esi
     d27:	67 66 89 34 24       	mov    %esi,(%esp)
     d2c:	66 e8 7c fe ff ff    	calll  bae <set_cursor>
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:54
            break;
     d32:	66 83 c4 10          	add    $0x10,%esp
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:57
    }
    return ;
}
     d36:	66 5b                	pop    %ebx
     d38:	66 5e                	pop    %esi
     d3a:	66 5f                	pop    %edi
     d3c:	66 c3                	retl   

00000d3e <_putc>:
_putc():
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:59

void _putc(char c){
     d3e:	66 56                	push   %esi
     d40:	66 53                	push   %ebx
     d42:	66 83 ec 04          	sub    $0x4,%esp
     d46:	67 66 8b 5c 24 10    	mov    0x10(%esp),%ebx
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:60
    u16 cursor_index = get_cursor();
     d4c:	66 e8 ce fe ff ff    	calll  c20 <get_cursor>
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:61
    u16 row = cursor_index / 80;
     d52:	66 0f b7 d0          	movzwl %ax,%edx
     d56:	66 69 d2 cd cc 00 00 	imul   $0xcccd,%edx,%edx
     d5d:	66 c1 ea 10          	shr    $0x10,%edx
     d61:	c1 ea 06             	shr    $0x6,%dx
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:62
    u16 col = cursor_index % 80;
     d64:	67 66 8d 34 92       	lea    (%edx,%edx,4),%esi
     d69:	66 c1 e6 04          	shl    $0x4,%esi
     d6d:	66 89 f1             	mov    %esi,%ecx
     d70:	66 89 c6             	mov    %eax,%esi
     d73:	66 29 ce             	sub    %ecx,%esi
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:63
    switch (c) {
     d76:	80 fb 0a             	cmp    $0xa,%bl
     d79:	74 07                	je     d82 <_putc+0x44>
     d7b:	80 fb 0d             	cmp    $0xd,%bl
     d7e:	74 2b                	je     dab <_putc+0x6d>
     d80:	eb 4b                	jmp    dcd <_putc+0x8f>
     d82:	66 89 f1             	mov    %esi,%ecx
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:65
        case '\n':
            set_cursor((row+1)*80+col); // 回车，移到下一行
     d85:	66 83 ec 0c          	sub    $0xc,%esp
     d89:	67 66 8d 54 92 05    	lea    0x5(%edx,%edx,4),%edx
     d8f:	66 89 d0             	mov    %edx,%eax
     d92:	66 c1 e0 04          	shl    $0x4,%eax
     d96:	66 01 c1             	add    %eax,%ecx
     d99:	66 0f b7 c9          	movzwl %cx,%ecx
     d9d:	66 51                	push   %ecx
     d9f:	66 e8 09 fe ff ff    	calll  bae <set_cursor>
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:66
            break;
     da5:	66 83 c4 10          	add    $0x10,%esp
     da9:	eb 3c                	jmp    de7 <_putc+0xa9>
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:68
        case '\r':
            set_cursor(row*80);    // 移到本行开头处
     dab:	66 83 ec 0c          	sub    $0xc,%esp
     daf:	67 66 8d 14 92       	lea    (%edx,%edx,4),%edx
     db4:	66 89 d0             	mov    %edx,%eax
     db7:	66 c1 e0 04          	shl    $0x4,%eax
     dbb:	66 0f b7 c0          	movzwl %ax,%eax
     dbf:	66 50                	push   %eax
     dc1:	66 e8 e7 fd ff ff    	calll  bae <set_cursor>
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:69
            break;
     dc7:	66 83 c4 10          	add    $0x10,%esp
     dcb:	eb 1a                	jmp    de7 <_putc+0xa9>
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:71
        default:
            _put_char(c, cursor_index);
     dcd:	66 83 ec 08          	sub    $0x8,%esp
     dd1:	66 0f b7 c0          	movzwl %ax,%eax
     dd5:	66 50                	push   %eax
     dd7:	66 0f be db          	movsbl %bl,%ebx
     ddb:	66 53                	push   %ebx
     ddd:	66 e8 84 fd ff ff    	calll  b67 <_put_char>
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:73
            // set_cursor(cursor_index+1);
            break;
     de3:	66 83 c4 10          	add    $0x10,%esp
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:76
    }
    return ;
}
     de7:	66 83 c4 04          	add    $0x4,%esp
     deb:	66 5b                	pop    %ebx
     ded:	66 5e                	pop    %esi
     def:	66 c3                	retl   

00000df1 <puti>:
puti():
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:78

void puti(u32 n){
     df1:	66 56                	push   %esi
     df3:	66 53                	push   %ebx
     df5:	66 83 ec 44          	sub    $0x44,%esp
     df9:	67 66 8b 4c 24 50    	mov    0x50(%esp),%ecx
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:79
    int len = 0;
     dff:	66 bb 00 00 00 00    	mov    $0x0,%ebx
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:81
    int num[INT_LENGTH];  // 临时存放各位数，从低位放到高位，之后倒序输出即可
    while (n != 0){
     e05:	eb 2d                	jmp    e34 <puti+0x43>
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:82
        num[len] = n % 10;
     e07:	66 ba cd cc cc cc    	mov    $0xcccccccd,%edx
     e0d:	66 89 c8             	mov    %ecx,%eax
     e10:	66 f7 e2             	mul    %edx
     e13:	66 c1 ea 03          	shr    $0x3,%edx
     e17:	66 89 d6             	mov    %edx,%esi
     e1a:	67 66 8d 14 92       	lea    (%edx,%edx,4),%edx
     e1f:	67 66 8d 04 12       	lea    (%edx,%edx,1),%eax
     e24:	66 29 c1             	sub    %eax,%ecx
     e27:	67 66 89 4c 9c 04    	mov    %ecx,0x4(%esp,%ebx,4)
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:83
        n = n / 10;
     e2d:	66 89 f1             	mov    %esi,%ecx
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:84
        len++;
     e30:	66 83 c3 01          	add    $0x1,%ebx
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:81
}

void puti(u32 n){
    int len = 0;
    int num[INT_LENGTH];  // 临时存放各位数，从低位放到高位，之后倒序输出即可
    while (n != 0){
     e34:	66 85 c9             	test   %ecx,%ecx
     e37:	75 ce                	jne    e07 <puti+0x16>
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:86
        num[len] = n % 10;
        n = n / 10;
        len++;
    }
    for (int i = len-1; i >= 0; i--){
     e39:	66 83 eb 01          	sub    $0x1,%ebx
     e3d:	eb 23                	jmp    e62 <puti+0x71>
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:87 (discriminator 3)
        putc(num[i]+'0');
     e3f:	66 83 ec 0c          	sub    $0xc,%esp
     e43:	67 66 0f b6 44 9c 10 	movzbl 0x10(%esp,%ebx,4),%eax
     e4a:	66 83 c0 30          	add    $0x30,%eax
     e4e:	66 0f be c0          	movsbl %al,%eax
     e52:	66 50                	push   %eax
     e54:	66 e8 22 fe ff ff    	calll  c7c <putc>
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:86 (discriminator 3)
    while (n != 0){
        num[len] = n % 10;
        n = n / 10;
        len++;
    }
    for (int i = len-1; i >= 0; i--){
     e5a:	66 83 eb 01          	sub    $0x1,%ebx
     e5e:	66 83 c4 10          	add    $0x10,%esp
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:86 (discriminator 1)
     e62:	66 85 db             	test   %ebx,%ebx
     e65:	79 d8                	jns    e3f <puti+0x4e>
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:90
        putc(num[i]+'0');
    }
    return ;
}
     e67:	66 83 c4 44          	add    $0x44,%esp
     e6b:	66 5b                	pop    %ebx
     e6d:	66 5e                	pop    %esi
     e6f:	66 c3                	retl   

00000e71 <puts>:
puts():
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:92

void puts(char * str, int size){
     e71:	66 57                	push   %edi
     e73:	66 56                	push   %esi
     e75:	66 53                	push   %ebx
     e77:	67 66 8b 7c 24 10    	mov    0x10(%esp),%edi
     e7d:	67 66 8b 74 24 14    	mov    0x14(%esp),%esi
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:93
    int i = 0;
     e83:	66 bb 00 00 00 00    	mov    $0x0,%ebx
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:94
    while (i < size){
     e89:	eb 1a                	jmp    ea5 <puts+0x34>
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:95
        putc(str[i]);
     e8b:	66 83 ec 0c          	sub    $0xc,%esp
     e8f:	67 66 0f be 04 1f    	movsbl (%edi,%ebx,1),%eax
     e95:	66 50                	push   %eax
     e97:	66 e8 df fd ff ff    	calll  c7c <putc>
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:96
        i++;
     e9d:	66 83 c3 01          	add    $0x1,%ebx
     ea1:	66 83 c4 10          	add    $0x10,%esp
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:94
    return ;
}

void puts(char * str, int size){
    int i = 0;
    while (i < size){
     ea5:	66 39 f3             	cmp    %esi,%ebx
     ea8:	7c e1                	jl     e8b <puts+0x1a>
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:99
        putc(str[i]);
        i++;
    }
    return ;
}
     eaa:	66 5b                	pop    %ebx
     eac:	66 5e                	pop    %esi
     eae:	66 5f                	pop    %edi
     eb0:	66 c3                	retl   

00000eb2 <sprintf>:
sprintf():
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:103



void sprintf(char * dest , char * format, ...){
     eb2:	66 55                	push   %ebp
     eb4:	66 57                	push   %edi
     eb6:	66 56                	push   %esi
     eb8:	66 53                	push   %ebx
     eba:	66 83 ec 5c          	sub    $0x5c,%esp
     ebe:	67 66 8b 6c 24 70    	mov    0x70(%esp),%ebp
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:106
    int arg_num = 0;
    int src_index = 0;   // 源字符串索引，总是指向未读的一位
    int des_index = 0;   // 目标字符串索引，总是指向未写的一位。
     ec4:	66 bb 00 00 00 00    	mov    $0x0,%ebx
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:105



void sprintf(char * dest , char * format, ...){
    int arg_num = 0;
    int src_index = 0;   // 源字符串索引，总是指向未读的一位
     eca:	66 bf 00 00 00 00    	mov    $0x0,%edi
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:104
}



void sprintf(char * dest , char * format, ...){
    int arg_num = 0;
     ed0:	66 ba 00 00 00 00    	mov    $0x0,%edx
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:108
    int src_index = 0;   // 源字符串索引，总是指向未读的一位
    int des_index = 0;   // 目标字符串索引，总是指向未写的一位。
    int* arg_addr = &format+1; // 边长参数第一个参数的地址。
    while (format[src_index] != 0){
     ed6:	e9 33 01             	jmp    100c <core_header_data_segment+0xc>
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:109
        if (format[src_index] == '%'){
     ed9:	3c 25                	cmp    $0x25,%al
     edb:	0f 85 1b 01          	jne    ffa <sprintf+0x148>
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:111
            src_index++;
            switch(format[src_index]){
     edf:	67 66 0f b6 44 39 01 	movzbl 0x1(%ecx,%edi,1),%eax
     ee6:	3c 64                	cmp    $0x64,%al
     ee8:	74 28                	je     f12 <sprintf+0x60>
     eea:	3c 73                	cmp    $0x73,%al
     eec:	0f 84 b5 00          	je     fa5 <sprintf+0xf3>
     ef0:	3c 63                	cmp    $0x63,%al
     ef2:	0f 85 fe 00          	jne    ff4 <sprintf+0x142>
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:113
                case 'c':{
                    dest[des_index++] =*(arg_addr + arg_num++);
     ef6:	67 66 8b 44 94 78    	mov    0x78(%esp,%edx,4),%eax
     efc:	67 88 44 1d 00       	mov    %al,0x0(%ebp,%ebx,1)
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:114
                    src_index++;
     f01:	66 83 c7 02          	add    $0x2,%edi
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:113
    while (format[src_index] != 0){
        if (format[src_index] == '%'){
            src_index++;
            switch(format[src_index]){
                case 'c':{
                    dest[des_index++] =*(arg_addr + arg_num++);
     f05:	67 66 8d 5b 01       	lea    0x1(%ebx),%ebx
     f0a:	67 66 8d 52 01       	lea    0x1(%edx),%edx
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:115
                    src_index++;
                    break;
     f0f:	e9 fa 00             	jmp    100c <core_header_data_segment+0xc>
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:118
                }
                case 'd':{
                    int n = *(arg_addr + arg_num++);
     f12:	67 66 8d 42 01       	lea    0x1(%edx),%eax
     f17:	67 66 89 44 24 08    	mov    %eax,0x8(%esp)
     f1d:	67 66 8b 4c 94 78    	mov    0x78(%esp,%edx,4),%ecx
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:119
                    int len = 0; 
     f23:	66 be 00 00 00 00    	mov    $0x0,%esi
     f29:	67 66 89 7c 24 0c    	mov    %edi,0xc(%esp)
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:121
                    int num[INT_LENGTH];
                    while (n != 0){
     f2f:	eb 37                	jmp    f68 <sprintf+0xb6>
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:122
                        num[len] = n % 10;
     f31:	66 ba 67 66 66 66    	mov    $0x66666667,%edx
     f37:	66 89 c8             	mov    %ecx,%eax
     f3a:	66 f7 ea             	imul   %edx
     f3d:	66 c1 fa 02          	sar    $0x2,%edx
     f41:	66 89 c8             	mov    %ecx,%eax
     f44:	66 c1 f8 1f          	sar    $0x1f,%eax
     f48:	66 29 c2             	sub    %eax,%edx
     f4b:	66 89 d7             	mov    %edx,%edi
     f4e:	67 66 8d 14 92       	lea    (%edx,%edx,4),%edx
     f53:	67 66 8d 04 12       	lea    (%edx,%edx,1),%eax
     f58:	66 29 c1             	sub    %eax,%ecx
     f5b:	67 66 89 4c b4 14    	mov    %ecx,0x14(%esp,%esi,4)
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:123
                        n = n / 10;
     f61:	66 89 f9             	mov    %edi,%ecx
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:124
                        len++;
     f64:	66 83 c6 01          	add    $0x1,%esi
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:121
                }
                case 'd':{
                    int n = *(arg_addr + arg_num++);
                    int len = 0; 
                    int num[INT_LENGTH];
                    while (n != 0){
     f68:	66 85 c9             	test   %ecx,%ecx
     f6b:	75 c4                	jne    f31 <sprintf+0x7f>
     f6d:	67 66 8b 7c 24 0c    	mov    0xc(%esp),%edi
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:126
                        num[len] = n % 10;
                        n = n / 10;
                        len++;
                    }
                    for (int i = len-1; i >= 0; i--){
     f73:	67 66 8d 46 ff       	lea    -0x1(%esi),%eax
     f78:	eb 1a                	jmp    f94 <sprintf+0xe2>
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:127 (discriminator 3)
                        dest[des_index++] = num[i]+'0';
     f7a:	67 66 0f b6 74 84 14 	movzbl 0x14(%esp,%eax,4),%esi
     f81:	67 66 8d 56 30       	lea    0x30(%esi),%edx
     f86:	67 88 54 1d 00       	mov    %dl,0x0(%ebp,%ebx,1)
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:126 (discriminator 3)
                    while (n != 0){
                        num[len] = n % 10;
                        n = n / 10;
                        len++;
                    }
                    for (int i = len-1; i >= 0; i--){
     f8b:	66 83 e8 01          	sub    $0x1,%eax
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:127 (discriminator 3)
                        dest[des_index++] = num[i]+'0';
     f8f:	67 66 8d 5b 01       	lea    0x1(%ebx),%ebx
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:126 (discriminator 1)
                    while (n != 0){
                        num[len] = n % 10;
                        n = n / 10;
                        len++;
                    }
                    for (int i = len-1; i >= 0; i--){
     f94:	66 85 c0             	test   %eax,%eax
     f97:	79 e1                	jns    f7a <sprintf+0xc8>
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:129
                        dest[des_index++] = num[i]+'0';
                    }
                    src_index++;
     f99:	66 83 c7 02          	add    $0x2,%edi
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:118
                    dest[des_index++] =*(arg_addr + arg_num++);
                    src_index++;
                    break;
                }
                case 'd':{
                    int n = *(arg_addr + arg_num++);
     f9d:	67 66 8b 54 24 08    	mov    0x8(%esp),%edx
     fa3:	eb 67                	jmp    100c <core_header_data_segment+0xc>
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:133
                    }
                    src_index++;
                    break;
                }
                case 's':{
                    char * str = *(arg_addr + arg_num++);
     fa5:	67 66 8d 42 01       	lea    0x1(%edx),%eax
     faa:	67 66 89 44 24 08    	mov    %eax,0x8(%esp)
     fb0:	67 66 8b 74 94 78    	mov    0x78(%esp,%edx,4),%esi
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:134
                    u32 str_len = strlen(str);
     fb6:	66 83 ec 0c          	sub    $0xc,%esp
     fba:	66 56                	push   %esi
     fbc:	66 e8 8a 06 00 00    	calll  164c <strlen>
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:136
                    u32 i = 0;
                    while (i < str_len){
     fc2:	66 83 c4 10          	add    $0x10,%esp
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:135
                    break;
                }
                case 's':{
                    char * str = *(arg_addr + arg_num++);
                    u32 str_len = strlen(str);
                    u32 i = 0;
     fc6:	66 ba 00 00 00 00    	mov    $0x0,%edx
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:136
                    while (i < str_len){
     fcc:	eb 15                	jmp    fe3 <sprintf+0x131>
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:137
                        dest[des_index++] = str[i++];
     fce:	67 66 0f b6 0c 16    	movzbl (%esi,%edx,1),%ecx
     fd4:	67 88 4c 1d 00       	mov    %cl,0x0(%ebp,%ebx,1)
     fd9:	67 66 8d 52 01       	lea    0x1(%edx),%edx
     fde:	67 66 8d 5b 01       	lea    0x1(%ebx),%ebx
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:136
                }
                case 's':{
                    char * str = *(arg_addr + arg_num++);
                    u32 str_len = strlen(str);
                    u32 i = 0;
                    while (i < str_len){
     fe3:	66 39 c2             	cmp    %eax,%edx
     fe6:	72 e6                	jb     fce <sprintf+0x11c>
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:139
                        dest[des_index++] = str[i++];
                    }
                    src_index++;
     fe8:	66 83 c7 02          	add    $0x2,%edi
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:133
                    }
                    src_index++;
                    break;
                }
                case 's':{
                    char * str = *(arg_addr + arg_num++);
     fec:	67 66 8b 54 24 08    	mov    0x8(%esp),%edx
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:140
                    u32 i = 0;
                    while (i < str_len){
                        dest[des_index++] = str[i++];
                    }
                    src_index++;
                    break;
     ff2:	eb 18                	jmp    100c <core_header_data_segment+0xc>
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:143
                }
                default :
                    src_index++;
     ff4:	66 83 c7 02          	add    $0x2,%edi
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:144
                    break;
     ff8:	eb 12                	jmp    100c <core_header_data_segment+0xc>
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:147
            }
        }
        else if (format[src_index] == '\\') {
     ffa:	3c 5c                	cmp    $0x5c,%al
     ffc:	74 0e                	je     100c <core_header_data_segment+0xc>
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:166
                        break;
                }
            }
        }
        else {
            dest[des_index++] = format[src_index++];
     ffe:	66 83 c7 01          	add    $0x1,%edi
    1002:	67 88 44 1d 00       	mov    %al,0x0(%ebp,%ebx,1)
    1007:	67 66 8d 5b 01       	lea    0x1(%ebx),%ebx
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:108
void sprintf(char * dest , char * format, ...){
    int arg_num = 0;
    int src_index = 0;   // 源字符串索引，总是指向未读的一位
    int des_index = 0;   // 目标字符串索引，总是指向未写的一位。
    int* arg_addr = &format+1; // 边长参数第一个参数的地址。
    while (format[src_index] != 0){
    100c:	67 66 8b 4c 24 74    	mov    0x74(%esp),%ecx
    1012:	67 66 0f b6 04 39    	movzbl (%ecx,%edi,1),%eax
    1018:	84 c0                	test   %al,%al
    101a:	0f 85 bb fe          	jne    ed9 <sprintf+0x27>
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:169
        }
        else {
            dest[des_index++] = format[src_index++];
        }
    }
    dest[des_index] = 0;
    101e:	67 c6 44 1d 00 00    	movb   $0x0,0x0(%ebp,%ebx,1)
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:171
    return ;
}
    1024:	66 83 c4 5c          	add    $0x5c,%esp
    1028:	66 5b                	pop    %ebx
    102a:	66 5e                	pop    %esi
    102c:	66 5f                	pop    %edi
    102e:	66 5d                	pop    %ebp
    1030:	66 c3                	retl   

00001032 <vprintf>:
vprintf():
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:174


void vprintf(char * format, va_list va){
    1032:	66 55                	push   %ebp
    1034:	66 57                	push   %edi
    1036:	66 56                	push   %esi
    1038:	66 53                	push   %ebx
    103a:	66 81 ec 5c 04 00 00 	sub    $0x45c,%esp
    1041:	67 66 8b ac 24 70 04 	mov    0x470(%esp),%ebp
    1048:	00 00 
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:178
    char buf[BUF_LENGTH];
    int arg_num = 0;
    int src_index = 0;   // 源字符串索引，总是指向未读的一位
    int des_index = 0;   // 目标字符串索引，总是指向未写的一位。
    104a:	66 bb 00 00 00 00    	mov    $0x0,%ebx
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:177


void vprintf(char * format, va_list va){
    char buf[BUF_LENGTH];
    int arg_num = 0;
    int src_index = 0;   // 源字符串索引，总是指向未读的一位
    1050:	66 bf 00 00 00 00    	mov    $0x0,%edi
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:176
}


void vprintf(char * format, va_list va){
    char buf[BUF_LENGTH];
    int arg_num = 0;
    1056:	66 ba 00 00 00 00    	mov    $0x0,%edx
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:180
    int src_index = 0;   // 源字符串索引，总是指向未读的一位
    int des_index = 0;   // 目标字符串索引，总是指向未写的一位。
    int* arg_addr = va; // 边长参数第一个参数的地址。
    while (format[src_index] != 0){
    105c:	e9 4c 01             	jmp    11ab <vprintf+0x179>
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:181
        if (format[src_index] == '%'){
    105f:	3c 25                	cmp    $0x25,%al
    1061:	0f 85 34 01          	jne    1199 <vprintf+0x167>
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:183
            src_index++;
            switch(format[src_index]){
    1065:	67 66 0f b6 44 3d 01 	movzbl 0x1(%ebp,%edi,1),%eax
    106c:	3c 64                	cmp    $0x64,%al
    106e:	74 30                	je     10a0 <vprintf+0x6e>
    1070:	3c 73                	cmp    $0x73,%al
    1072:	0f 84 c6 00          	je     113c <vprintf+0x10a>
    1076:	3c 63                	cmp    $0x63,%al
    1078:	0f 85 17 01          	jne    1193 <vprintf+0x161>
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:185
                case 'c':{
                    buf[des_index++] =*(arg_addr + arg_num++);
    107c:	67 66 8b 84 24 74 04 	mov    0x474(%esp),%eax
    1083:	00 00 
    1085:	67 66 8b 04 90       	mov    (%eax,%edx,4),%eax
    108a:	67 88 44 1c 50       	mov    %al,0x50(%esp,%ebx,1)
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:186
                    src_index++;
    108f:	66 83 c7 02          	add    $0x2,%edi
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:185
    while (format[src_index] != 0){
        if (format[src_index] == '%'){
            src_index++;
            switch(format[src_index]){
                case 'c':{
                    buf[des_index++] =*(arg_addr + arg_num++);
    1093:	67 66 8d 5b 01       	lea    0x1(%ebx),%ebx
    1098:	67 66 8d 52 01       	lea    0x1(%edx),%edx
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:187
                    src_index++;
                    break;
    109d:	e9 0b 01             	jmp    11ab <vprintf+0x179>
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:190
                }
                case 'd':{
                    int n = *(arg_addr + arg_num++);
    10a0:	67 66 8d 42 01       	lea    0x1(%edx),%eax
    10a5:	67 66 89 44 24 08    	mov    %eax,0x8(%esp)
    10ab:	67 66 8b 84 24 74 04 	mov    0x474(%esp),%eax
    10b2:	00 00 
    10b4:	67 66 8b 34 90       	mov    (%eax,%edx,4),%esi
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:191
                    int len = 0; 
    10b9:	66 b9 00 00 00 00    	mov    $0x0,%ecx
    10bf:	67 66 89 7c 24 0c    	mov    %edi,0xc(%esp)
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:193
                    int num[INT_LENGTH];
                    while (n != 0){
    10c5:	eb 3a                	jmp    1101 <vprintf+0xcf>
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:194
                        num[len] = n % 10;
    10c7:	66 ba 67 66 66 66    	mov    $0x66666667,%edx
    10cd:	66 89 f0             	mov    %esi,%eax
    10d0:	66 f7 ea             	imul   %edx
    10d3:	66 c1 fa 02          	sar    $0x2,%edx
    10d7:	66 89 f0             	mov    %esi,%eax
    10da:	66 c1 f8 1f          	sar    $0x1f,%eax
    10de:	66 29 c2             	sub    %eax,%edx
    10e1:	66 89 d7             	mov    %edx,%edi
    10e4:	67 66 8d 14 92       	lea    (%edx,%edx,4),%edx
    10e9:	67 66 8d 04 12       	lea    (%edx,%edx,1),%eax
    10ee:	66 89 f2             	mov    %esi,%edx
    10f1:	66 29 c2             	sub    %eax,%edx
    10f4:	67 66 89 54 8c 14    	mov    %edx,0x14(%esp,%ecx,4)
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:195
                        n = n / 10;
    10fa:	66 89 fe             	mov    %edi,%esi
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:196
                        len++;
    10fd:	66 83 c1 01          	add    $0x1,%ecx
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:193
                }
                case 'd':{
                    int n = *(arg_addr + arg_num++);
                    int len = 0; 
                    int num[INT_LENGTH];
                    while (n != 0){
    1101:	66 85 f6             	test   %esi,%esi
    1104:	75 c1                	jne    10c7 <vprintf+0x95>
    1106:	67 66 8b 7c 24 0c    	mov    0xc(%esp),%edi
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:198
                        num[len] = n % 10;
                        n = n / 10;
                        len++;
                    }
                    for (int i = len-1; i >= 0; i--){
    110c:	66 83 e9 01          	sub    $0x1,%ecx
    1110:	eb 19                	jmp    112b <vprintf+0xf9>
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:199 (discriminator 3)
                        buf[des_index++] = num[i]+'0';
    1112:	67 66 0f b6 44 8c 14 	movzbl 0x14(%esp,%ecx,4),%eax
    1119:	66 83 c0 30          	add    $0x30,%eax
    111d:	67 88 44 1c 50       	mov    %al,0x50(%esp,%ebx,1)
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:198 (discriminator 3)
                    while (n != 0){
                        num[len] = n % 10;
                        n = n / 10;
                        len++;
                    }
                    for (int i = len-1; i >= 0; i--){
    1122:	66 83 e9 01          	sub    $0x1,%ecx
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:199 (discriminator 3)
                        buf[des_index++] = num[i]+'0';
    1126:	67 66 8d 5b 01       	lea    0x1(%ebx),%ebx
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:198 (discriminator 1)
                    while (n != 0){
                        num[len] = n % 10;
                        n = n / 10;
                        len++;
                    }
                    for (int i = len-1; i >= 0; i--){
    112b:	66 85 c9             	test   %ecx,%ecx
    112e:	79 e2                	jns    1112 <vprintf+0xe0>
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:201
                        buf[des_index++] = num[i]+'0';
                    }
                    src_index++;
    1130:	66 83 c7 02          	add    $0x2,%edi
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:190
                    buf[des_index++] =*(arg_addr + arg_num++);
                    src_index++;
                    break;
                }
                case 'd':{
                    int n = *(arg_addr + arg_num++);
    1134:	67 66 8b 54 24 08    	mov    0x8(%esp),%edx
    113a:	eb 6f                	jmp    11ab <vprintf+0x179>
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:205
                    }
                    src_index++;
                    break;
                }
                case 's':{
                    char * str = *(arg_addr + arg_num++);
    113c:	67 66 8d 42 01       	lea    0x1(%edx),%eax
    1141:	67 66 89 44 24 08    	mov    %eax,0x8(%esp)
    1147:	67 66 8b 84 24 74 04 	mov    0x474(%esp),%eax
    114e:	00 00 
    1150:	67 66 8b 34 90       	mov    (%eax,%edx,4),%esi
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:206
                    u32 str_len = strlen(str);
    1155:	66 83 ec 0c          	sub    $0xc,%esp
    1159:	66 56                	push   %esi
    115b:	66 e8 eb 04 00 00    	calll  164c <strlen>
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:208
                    u32 i = 0;
                    while (i < str_len){
    1161:	66 83 c4 10          	add    $0x10,%esp
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:207
                    break;
                }
                case 's':{
                    char * str = *(arg_addr + arg_num++);
                    u32 str_len = strlen(str);
                    u32 i = 0;
    1165:	66 ba 00 00 00 00    	mov    $0x0,%edx
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:208
                    while (i < str_len){
    116b:	eb 15                	jmp    1182 <vprintf+0x150>
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:209
                        buf[des_index++] = str[i++];
    116d:	67 66 0f b6 0c 16    	movzbl (%esi,%edx,1),%ecx
    1173:	67 88 4c 1c 50       	mov    %cl,0x50(%esp,%ebx,1)
    1178:	67 66 8d 52 01       	lea    0x1(%edx),%edx
    117d:	67 66 8d 5b 01       	lea    0x1(%ebx),%ebx
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:208
                }
                case 's':{
                    char * str = *(arg_addr + arg_num++);
                    u32 str_len = strlen(str);
                    u32 i = 0;
                    while (i < str_len){
    1182:	66 39 c2             	cmp    %eax,%edx
    1185:	72 e6                	jb     116d <vprintf+0x13b>
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:211
                        buf[des_index++] = str[i++];
                    }
                    src_index++;
    1187:	66 83 c7 02          	add    $0x2,%edi
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:205
                    }
                    src_index++;
                    break;
                }
                case 's':{
                    char * str = *(arg_addr + arg_num++);
    118b:	67 66 8b 54 24 08    	mov    0x8(%esp),%edx
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:212
                    u32 i = 0;
                    while (i < str_len){
                        buf[des_index++] = str[i++];
                    }
                    src_index++;
                    break;
    1191:	eb 18                	jmp    11ab <vprintf+0x179>
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:215
                }
                default :
                    src_index++;
    1193:	66 83 c7 02          	add    $0x2,%edi
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:216
                    break;
    1197:	eb 12                	jmp    11ab <vprintf+0x179>
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:219
            }
        }
        else if (format[src_index] == '\\') {
    1199:	3c 5c                	cmp    $0x5c,%al
    119b:	74 0e                	je     11ab <vprintf+0x179>
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:238
                        break;
                }
            }
        }
        else {
            buf[des_index++] = format[src_index++];
    119d:	66 83 c7 01          	add    $0x1,%edi
    11a1:	67 88 44 1c 50       	mov    %al,0x50(%esp,%ebx,1)
    11a6:	67 66 8d 5b 01       	lea    0x1(%ebx),%ebx
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:180
    char buf[BUF_LENGTH];
    int arg_num = 0;
    int src_index = 0;   // 源字符串索引，总是指向未读的一位
    int des_index = 0;   // 目标字符串索引，总是指向未写的一位。
    int* arg_addr = va; // 边长参数第一个参数的地址。
    while (format[src_index] != 0){
    11ab:	67 66 0f b6 44 3d 00 	movzbl 0x0(%ebp,%edi,1),%eax
    11b2:	84 c0                	test   %al,%al
    11b4:	0f 85 a7 fe          	jne    105f <vprintf+0x2d>
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:241
        }
        else {
            buf[des_index++] = format[src_index++];
        }
    }
    buf[des_index] = 0;
    11b8:	67 c6 44 1c 50 00    	movb   $0x0,0x50(%esp,%ebx,1)
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:242
    for (int i = 0; i < des_index; i++){
    11be:	66 be 00 00 00 00    	mov    $0x0,%esi
    11c4:	eb 1b                	jmp    11e1 <vprintf+0x1af>
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:243 (discriminator 3)
        putc(buf[i]);
    11c6:	66 83 ec 0c          	sub    $0xc,%esp
    11ca:	67 66 0f be 44 34 5c 	movsbl 0x5c(%esp,%esi,1),%eax
    11d1:	66 50                	push   %eax
    11d3:	66 e8 a3 fa ff ff    	calll  c7c <putc>
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:242 (discriminator 3)
        else {
            buf[des_index++] = format[src_index++];
        }
    }
    buf[des_index] = 0;
    for (int i = 0; i < des_index; i++){
    11d9:	66 83 c6 01          	add    $0x1,%esi
    11dd:	66 83 c4 10          	add    $0x10,%esp
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:242 (discriminator 1)
    11e1:	66 39 f3             	cmp    %esi,%ebx
    11e4:	7f e0                	jg     11c6 <vprintf+0x194>
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:246
        putc(buf[i]);
    }
    return ;
}
    11e6:	66 81 c4 5c 04 00 00 	add    $0x45c,%esp
    11ed:	66 5b                	pop    %ebx
    11ef:	66 5e                	pop    %esi
    11f1:	66 5f                	pop    %edi
    11f3:	66 5d                	pop    %ebp
    11f5:	66 c3                	retl   

000011f7 <printf>:
printf():
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:248

void printf(char * format, ...){
    11f7:	66 83 ec 14          	sub    $0x14,%esp
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:249
    vprintf(format, &format+1);// 其实这里由于format是个指针，是32位的，所以这里对format的地址+1，也会加4个字节。
    11fb:	67 66 8d 44 24 1c    	lea    0x1c(%esp),%eax
    1201:	66 50                	push   %eax
    1203:	67 66 ff 74 24 1c    	pushl  0x1c(%esp)
    1209:	66 e8 23 fe ff ff    	calll  1032 <vprintf>
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:251
    return ;
}
    120f:	66 83 c4 1c          	add    $0x1c,%esp
    1213:	66 c3                	retl   

00001215 <isalpha>:
isalpha():
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:270
//     return ;
// }



int isalpha (int ch){
    1215:	67 66 8b 44 24 04    	mov    0x4(%esp),%eax
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:271
    if ('a' <= ch && ch <= 'z')
    121b:	67 66 8d 50 9f       	lea    -0x61(%eax),%edx
    1220:	66 83 fa 19          	cmp    $0x19,%edx
    1224:	76 12                	jbe    1238 <isalpha+0x23>
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:273
        return 1;
    if ('A' <= ch && ch <= 'Z')
    1226:	66 83 e8 41          	sub    $0x41,%eax
    122a:	66 83 f8 19          	cmp    $0x19,%eax
    122e:	77 10                	ja     1240 <isalpha+0x2b>
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:274
        return 1;
    1230:	66 b8 01 00 00 00    	mov    $0x1,%eax
    1236:	66 c3                	retl   
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:272



int isalpha (int ch){
    if ('a' <= ch && ch <= 'z')
        return 1;
    1238:	66 b8 01 00 00 00    	mov    $0x1,%eax
    123e:	66 c3                	retl   
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:275
    if ('A' <= ch && ch <= 'Z')
        return 1;
    return 0;
    1240:	66 b8 00 00 00 00    	mov    $0x0,%eax
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:276
}
    1246:	66 c3                	retl   

00001248 <isdigit>:
isdigit():
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:278
int isdigit (int ch){
    if ('0' <= ch && ch <= '9')
    1248:	67 66 8b 44 24 04    	mov    0x4(%esp),%eax
    124e:	66 83 e8 30          	sub    $0x30,%eax
    1252:	66 83 f8 09          	cmp    $0x9,%eax
    1256:	77 08                	ja     1260 <isdigit+0x18>
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:279
        return 1;
    1258:	66 b8 01 00 00 00    	mov    $0x1,%eax
    125e:	66 c3                	retl   
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:280
    return 0;
    1260:	66 b8 00 00 00 00    	mov    $0x0,%eax
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:281
}
    1266:	66 c3                	retl   

00001268 <isalnum>:
isalnum():
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:283

int isalnum (int ch){
    1268:	66 53                	push   %ebx
    126a:	67 66 8b 5c 24 08    	mov    0x8(%esp),%ebx
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:284
    if ( isalpha(ch) || isdigit(ch) ){
    1270:	66 53                	push   %ebx
    1272:	66 e8 9d ff ff ff    	calll  1215 <isalpha>
    1278:	66 83 c4 04          	add    $0x4,%esp
    127c:	66 85 c0             	test   %eax,%eax
    127f:	75 13                	jne    1294 <isalnum+0x2c>
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:284 (discriminator 1)
    1281:	66 53                	push   %ebx
    1283:	66 e8 bf ff ff ff    	calll  1248 <isdigit>
    1289:	66 83 c4 04          	add    $0x4,%esp
    128d:	66 85 c0             	test   %eax,%eax
    1290:	75 0a                	jne    129c <isalnum+0x34>
    1292:	eb 0e                	jmp    12a2 <isalnum+0x3a>
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:285
        return 1;
    1294:	66 b8 01 00 00 00    	mov    $0x1,%eax
    129a:	eb 06                	jmp    12a2 <isalnum+0x3a>
    129c:	66 b8 01 00 00 00    	mov    $0x1,%eax
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:288
    }
    return 0;
}
    12a2:	66 5b                	pop    %ebx
    12a4:	66 c3                	retl   

000012a6 <ispunct>:
ispunct():
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:289
int ispunct (int ch){
    12a6:	66 83 ec 30          	sub    $0x30,%esp
    12aa:	67 66 8b 4c 24 34    	mov    0x34(%esp),%ecx
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:290
    char punct[34] =  "!\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~";
    12b0:	67 66 c7 44 24 0e 21 	movl   $0x24232221,0xe(%esp)
    12b7:	22 23 24 
    12ba:	67 66 c7 44 24 12 25 	movl   $0x28272625,0x12(%esp)
    12c1:	26 27 28 
    12c4:	67 66 c7 44 24 16 29 	movl   $0x2c2b2a29,0x16(%esp)
    12cb:	2a 2b 2c 
    12ce:	67 66 c7 44 24 1a 2d 	movl   $0x3a2f2e2d,0x1a(%esp)
    12d5:	2e 2f 3a 
    12d8:	67 66 c7 44 24 1e 3b 	movl   $0x3e3d3c3b,0x1e(%esp)
    12df:	3c 3d 3e 
    12e2:	67 66 c7 44 24 22 3f 	movl   $0x5c5b403f,0x22(%esp)
    12e9:	40 5b 5c 
    12ec:	67 66 c7 44 24 26 5d 	movl   $0x605f5e5d,0x26(%esp)
    12f3:	5e 5f 60 
    12f6:	67 66 c7 44 24 2a 7b 	movl   $0x7e7d7c7b,0x2a(%esp)
    12fd:	7c 7d 7e 
    1300:	67 c7 44 24 2e 00 00 	movw   $0x0,0x2e(%esp)
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:291
    for (int i = 0; i < 33; i++){
    1307:	66 b8 00 00 00 00    	mov    $0x0,%eax
    130d:	eb 10                	jmp    131f <ispunct+0x79>
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:292
        if (ch == punct[i])
    130f:	67 66 0f be 54 04 0e 	movsbl 0xe(%esp,%eax,1),%edx
    1316:	66 39 ca             	cmp    %ecx,%edx
    1319:	74 12                	je     132d <ispunct+0x87>
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:291 (discriminator 2)
    }
    return 0;
}
int ispunct (int ch){
    char punct[34] =  "!\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~";
    for (int i = 0; i < 33; i++){
    131b:	66 83 c0 01          	add    $0x1,%eax
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:291 (discriminator 1)
    131f:	66 83 f8 20          	cmp    $0x20,%eax
    1323:	7e ea                	jle    130f <ispunct+0x69>
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:295
        if (ch == punct[i])
            return 1;
    }
    return 0;
    1325:	66 b8 00 00 00 00    	mov    $0x0,%eax
    132b:	eb 06                	jmp    1333 <ispunct+0x8d>
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:293
}
int ispunct (int ch){
    char punct[34] =  "!\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~";
    for (int i = 0; i < 33; i++){
        if (ch == punct[i])
            return 1;
    132d:	66 b8 01 00 00 00    	mov    $0x1,%eax
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:296
    }
    return 0;
}
    1333:	66 83 c4 30          	add    $0x30,%esp
    1337:	66 c3                	retl   

00001339 <isblank>:
isblank():
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:298
int isblank (int ch){
    if (ch == ' ')
    1339:	67 66 83 7c 24 04 20 	cmpl   $0x20,0x4(%esp)
    1340:	75 08                	jne    134a <isblank+0x11>
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:299
        return 1;
    1342:	66 b8 01 00 00 00    	mov    $0x1,%eax
    1348:	66 c3                	retl   
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:300
    return 0;
    134a:	66 b8 00 00 00 00    	mov    $0x0,%eax
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:301
}
    1350:	66 c3                	retl   

00001352 <isprint>:
isprint():
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:302
int isprint (int ch){
    1352:	66 53                	push   %ebx
    1354:	67 66 8b 5c 24 08    	mov    0x8(%esp),%ebx
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:303
    if (isalpha(ch) || isdigit(ch) || isalnum(ch) || ispunct(ch) || isblank(ch)){
    135a:	66 53                	push   %ebx
    135c:	66 e8 b3 fe ff ff    	calll  1215 <isalpha>
    1362:	66 83 c4 04          	add    $0x4,%esp
    1366:	66 85 c0             	test   %eax,%eax
    1369:	75 46                	jne    13b1 <isprint+0x5f>
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:303 (discriminator 1)
    136b:	66 53                	push   %ebx
    136d:	66 e8 d5 fe ff ff    	calll  1248 <isdigit>
    1373:	66 83 c4 04          	add    $0x4,%esp
    1377:	66 85 c0             	test   %eax,%eax
    137a:	75 3d                	jne    13b9 <isprint+0x67>
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:303 (discriminator 2)
    137c:	66 53                	push   %ebx
    137e:	66 e8 e4 fe ff ff    	calll  1268 <isalnum>
    1384:	66 83 c4 04          	add    $0x4,%esp
    1388:	66 85 c0             	test   %eax,%eax
    138b:	75 34                	jne    13c1 <isprint+0x6f>
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:303 (discriminator 3)
    138d:	66 53                	push   %ebx
    138f:	66 e8 11 ff ff ff    	calll  12a6 <ispunct>
    1395:	66 83 c4 04          	add    $0x4,%esp
    1399:	66 85 c0             	test   %eax,%eax
    139c:	75 2b                	jne    13c9 <isprint+0x77>
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:303 (discriminator 4)
    139e:	66 53                	push   %ebx
    13a0:	66 e8 93 ff ff ff    	calll  1339 <isblank>
    13a6:	66 83 c4 04          	add    $0x4,%esp
    13aa:	66 85 c0             	test   %eax,%eax
    13ad:	75 22                	jne    13d1 <isprint+0x7f>
    13af:	eb 26                	jmp    13d7 <isprint+0x85>
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:304
        return 1;
    13b1:	66 b8 01 00 00 00    	mov    $0x1,%eax
    13b7:	eb 1e                	jmp    13d7 <isprint+0x85>
    13b9:	66 b8 01 00 00 00    	mov    $0x1,%eax
    13bf:	eb 16                	jmp    13d7 <isprint+0x85>
    13c1:	66 b8 01 00 00 00    	mov    $0x1,%eax
    13c7:	eb 0e                	jmp    13d7 <isprint+0x85>
    13c9:	66 b8 01 00 00 00    	mov    $0x1,%eax
    13cf:	eb 06                	jmp    13d7 <isprint+0x85>
    13d1:	66 b8 01 00 00 00    	mov    $0x1,%eax
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:307
    }
    return 0;
}
    13d7:	66 5b                	pop    %ebx
    13d9:	66 c3                	retl   

000013db <iscntrl>:
iscntrl():
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:308
int iscntrl (int ch){
    13db:	67 66 8b 44 24 04    	mov    0x4(%esp),%eax
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:310
    //he control characters are the characters with the codes 0x00-0x1F and 0x7F.
    if (0 <= ch && ch <= 0x1f)
    13e1:	66 83 f8 1f          	cmp    $0x1f,%eax
    13e5:	76 0e                	jbe    13f5 <iscntrl+0x1a>
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:312
        return 1;
    if (ch == 0x7f)
    13e7:	66 83 f8 7f          	cmp    $0x7f,%eax
    13eb:	75 10                	jne    13fd <iscntrl+0x22>
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:313
        return 1;
    13ed:	66 b8 01 00 00 00    	mov    $0x1,%eax
    13f3:	66 c3                	retl   
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:311
    return 0;
}
int iscntrl (int ch){
    //he control characters are the characters with the codes 0x00-0x1F and 0x7F.
    if (0 <= ch && ch <= 0x1f)
        return 1;
    13f5:	66 b8 01 00 00 00    	mov    $0x1,%eax
    13fb:	66 c3                	retl   
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:314
    if (ch == 0x7f)
        return 1;
    return 0;
    13fd:	66 b8 00 00 00 00    	mov    $0x0,%eax
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:315
}
    1403:	66 c3                	retl   

00001405 <read_n_sector>:
read_n_sector():
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:321

/* tested
读取指定逻辑扇区号的扇区到指定内存地址处
注意一次最多写一个段，也就是64k 最多读128个扇区。
够用了够用了 */
void read_n_sector(u16 sector_code, u16 number,  u16 segment, u16 offset){
    1405:	66 55                	push   %ebp
    1407:	66 57                	push   %edi
    1409:	66 56                	push   %esi
    140b:	66 53                	push   %ebx
    140d:	66 83 ec 1c          	sub    $0x1c,%esp
    1411:	67 66 0f b7 7c 24 30 	movzwl 0x30(%esp),%edi
    1418:	67 66 0f b7 74 24 34 	movzwl 0x34(%esp),%esi
    141f:	67 66 0f b7 44 24 38 	movzwl 0x38(%esp),%eax
    1426:	67 89 44 24 0c       	mov    %ax,0xc(%esp)
    142b:	67 66 0f b7 44 24 3c 	movzwl 0x3c(%esp),%eax
    1432:	67 89 44 24 0e       	mov    %ax,0xe(%esp)
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:322
    for (int i = 0; i < number; i++){
    1437:	66 bb 00 00 00 00    	mov    $0x0,%ebx
    143d:	eb 7d                	jmp    14bc <read_n_sector+0xb7>
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:323 (discriminator 3)
        int sector = (sector_code+i) % 18+1;
    143f:	66 0f b7 ef          	movzwl %di,%ebp
    1443:	66 01 dd             	add    %ebx,%ebp
    1446:	66 ba 39 8e e3 38    	mov    $0x38e38e39,%edx
    144c:	66 89 e8             	mov    %ebp,%eax
    144f:	66 f7 ea             	imul   %edx
    1452:	66 c1 fa 02          	sar    $0x2,%edx
    1456:	66 89 e8             	mov    %ebp,%eax
    1459:	66 c1 f8 1f          	sar    $0x1f,%eax
    145d:	66 29 c2             	sub    %eax,%edx
    1460:	66 89 d1             	mov    %edx,%ecx
    1463:	67 66 8d 14 d2       	lea    (%edx,%edx,8),%edx
    1468:	67 66 8d 04 12       	lea    (%edx,%edx,1),%eax
    146d:	66 89 ea             	mov    %ebp,%edx
    1470:	66 29 c2             	sub    %eax,%edx
    1473:	66 83 c2 01          	add    $0x1,%edx
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:325 (discriminator 3)
        int mid = (sector_code+i) / 18;
        int cylinder = mid >> 1;
    1477:	66 89 cd             	mov    %ecx,%ebp
    147a:	66 d1 fd             	sar    %ebp
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:327 (discriminator 3)
        int head = mid & 1;
        read_sector(head, cylinder,sector,segment, offset + i*512);
    147d:	66 83 ec 0c          	sub    $0xc,%esp
    1481:	66 89 d8             	mov    %ebx,%eax
    1484:	66 c1 e0 09          	shl    $0x9,%eax
    1488:	67 03 44 24 1a       	add    0x1a(%esp),%ax
    148d:	66 0f b7 c0          	movzwl %ax,%eax
    1491:	66 50                	push   %eax
    1493:	67 66 0f b7 44 24 1c 	movzwl 0x1c(%esp),%eax
    149a:	66 50                	push   %eax
    149c:	66 0f b7 d2          	movzwl %dx,%edx
    14a0:	66 52                	push   %edx
    14a2:	66 0f b7 ed          	movzwl %bp,%ebp
    14a6:	66 55                	push   %ebp
    14a8:	66 83 e1 01          	and    $0x1,%ecx
    14ac:	66 51                	push   %ecx
    14ae:	66 e8 28 01 00 00    	calll  15dc <read_sector>
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:322 (discriminator 3)
/* tested
读取指定逻辑扇区号的扇区到指定内存地址处
注意一次最多写一个段，也就是64k 最多读128个扇区。
够用了够用了 */
void read_n_sector(u16 sector_code, u16 number,  u16 segment, u16 offset){
    for (int i = 0; i < number; i++){
    14b4:	66 83 c3 01          	add    $0x1,%ebx
    14b8:	66 83 c4 20          	add    $0x20,%esp
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:322 (discriminator 1)
    14bc:	66 0f b7 c6          	movzwl %si,%eax
    14c0:	66 39 c3             	cmp    %eax,%ebx
    14c3:	0f 8c 78 ff          	jl     143f <read_n_sector+0x3a>
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:330
        int cylinder = mid >> 1;
        int head = mid & 1;
        read_sector(head, cylinder,sector,segment, offset + i*512);
    }
    return ;
}
    14c7:	66 83 c4 1c          	add    $0x1c,%esp
    14cb:	66 5b                	pop    %ebx
    14cd:	66 5e                	pop    %esi
    14cf:	66 5f                	pop    %edi
    14d1:	66 5d                	pop    %ebp
    14d3:	66 c3                	retl   
    14d5:	66 90                	xchg   %eax,%eax
    14d7:	66 90                	xchg   %eax,%eax
    14d9:	66 90                	xchg   %eax,%eax
    14db:	66 90                	xchg   %eax,%eax
    14dd:	66 90                	xchg   %eax,%eax
    14df:	90                   	nop

000014e0 <write_port_byte>:
write_port_byte():
    14e0:	66 55                	push   %ebp
    14e2:	66 89 e5             	mov    %esp,%ebp
    14e5:	53                   	push   %bx
    14e6:	51                   	push   %cx
    14e7:	52                   	push   %dx
    14e8:	56                   	push   %si
    14e9:	57                   	push   %di
    14ea:	55                   	push   %bp
    14eb:	1e                   	push   %ds
    14ec:	06                   	push   %es
    14ed:	16                   	push   %ss
    14ee:	67 8b 5d 08          	mov    0x8(%ebp),%bx
    14f2:	67 8a 45 0c          	mov    0xc(%ebp),%al
    14f6:	cd 34                	int    $0x34
    14f8:	17                   	pop    %ss
    14f9:	07                   	pop    %es
    14fa:	1f                   	pop    %ds
    14fb:	5d                   	pop    %bp
    14fc:	5f                   	pop    %di
    14fd:	5e                   	pop    %si
    14fe:	5a                   	pop    %dx
    14ff:	59                   	pop    %cx
    1500:	5b                   	pop    %bx
    1501:	66 89 ec             	mov    %ebp,%esp
    1504:	66 5d                	pop    %ebp
    1506:	66 c3                	retl   

00001508 <read_port_byte>:
read_port_byte():
    1508:	66 55                	push   %ebp
    150a:	66 89 e5             	mov    %esp,%ebp
    150d:	53                   	push   %bx
    150e:	51                   	push   %cx
    150f:	52                   	push   %dx
    1510:	56                   	push   %si
    1511:	57                   	push   %di
    1512:	55                   	push   %bp
    1513:	1e                   	push   %ds
    1514:	06                   	push   %es
    1515:	16                   	push   %ss
    1516:	67 8b 45 08          	mov    0x8(%ebp),%ax
    151a:	cd 33                	int    $0x33
    151c:	17                   	pop    %ss
    151d:	07                   	pop    %es
    151e:	1f                   	pop    %ds
    151f:	5d                   	pop    %bp
    1520:	5f                   	pop    %di
    1521:	5e                   	pop    %si
    1522:	5a                   	pop    %dx
    1523:	59                   	pop    %cx
    1524:	5b                   	pop    %bx
    1525:	66 89 ec             	mov    %ebp,%esp
    1528:	66 5d                	pop    %ebp
    152a:	66 c3                	retl   

0000152c <write_memory_byte>:
write_memory_byte():
    152c:	66 55                	push   %ebp
    152e:	66 89 e5             	mov    %esp,%ebp
    1531:	50                   	push   %ax
    1532:	53                   	push   %bx
    1533:	52                   	push   %dx
    1534:	1e                   	push   %ds
    1535:	67 8b 5d 08          	mov    0x8(%ebp),%bx
    1539:	67 8b 45 0a          	mov    0xa(%ebp),%ax
    153d:	c1 e0 0c             	shl    $0xc,%ax
    1540:	67 8a 4d 0c          	mov    0xc(%ebp),%cl
    1544:	cd 36                	int    $0x36
    1546:	1f                   	pop    %ds
    1547:	5a                   	pop    %dx
    1548:	5b                   	pop    %bx
    1549:	58                   	pop    %ax
    154a:	66 89 ec             	mov    %ebp,%esp
    154d:	66 5d                	pop    %ebp
    154f:	66 c3                	retl   

00001551 <read_memory_byte>:
read_memory_byte():
    1551:	66 55                	push   %ebp
    1553:	66 89 e5             	mov    %esp,%ebp
    1556:	53                   	push   %bx
    1557:	51                   	push   %cx
    1558:	52                   	push   %dx
    1559:	56                   	push   %si
    155a:	57                   	push   %di
    155b:	55                   	push   %bp
    155c:	1e                   	push   %ds
    155d:	06                   	push   %es
    155e:	16                   	push   %ss
    155f:	67 8b 5d 08          	mov    0x8(%ebp),%bx
    1563:	67 8b 45 0a          	mov    0xa(%ebp),%ax
    1567:	c1 e0 0c             	shl    $0xc,%ax
    156a:	cd 35                	int    $0x35
    156c:	17                   	pop    %ss
    156d:	07                   	pop    %es
    156e:	1f                   	pop    %ds
    156f:	5d                   	pop    %bp
    1570:	5f                   	pop    %di
    1571:	5e                   	pop    %si
    1572:	5a                   	pop    %dx
    1573:	59                   	pop    %cx
    1574:	5b                   	pop    %bx
    1575:	66 89 ec             	mov    %ebp,%esp
    1578:	66 5d                	pop    %ebp
    157a:	66 c3                	retl   

0000157c <check_keyboard>:
check_keyboard():
    157c:	b4 01                	mov    $0x1,%ah
    157e:	cd 16                	int    $0x16
    1580:	74 05                	je     1587 <check_keyboard.have_key>
    1582:	b8 00 00             	mov    $0x0,%ax
    1585:	eb 03                	jmp    158a <check_keyboard.check_keyboard_return>

00001587 <check_keyboard.have_key>:
check_keyboard.have_key():
    1587:	b8 01 00             	mov    $0x1,%ax

0000158a <check_keyboard.check_keyboard_return>:
check_keyboard.check_keyboard_return():
    158a:	66 c3                	retl   

0000158c <get_keyboard>:
get_keyboard():
    158c:	b4 00                	mov    $0x0,%ah
    158e:	cd 16                	int    $0x16
    1590:	66 c3                	retl   

00001592 <clean_screen>:
clean_screen():
    1592:	50                   	push   %ax
    1593:	53                   	push   %bx
    1594:	51                   	push   %cx
    1595:	52                   	push   %dx
    1596:	b4 06                	mov    $0x6,%ah
    1598:	b0 00                	mov    $0x0,%al
    159a:	b5 00                	mov    $0x0,%ch
    159c:	b1 00                	mov    $0x0,%cl
    159e:	b6 17                	mov    $0x17,%dh
    15a0:	b2 4f                	mov    $0x4f,%dl
    15a2:	b7 1f                	mov    $0x1f,%bh
    15a4:	cd 10                	int    $0x10
    15a6:	5a                   	pop    %dx
    15a7:	59                   	pop    %cx
    15a8:	5b                   	pop    %bx
    15a9:	58                   	pop    %ax
    15aa:	66 c3                	retl   

000015ac <scroll_screen>:
scroll_screen():
    15ac:	50                   	push   %ax
    15ad:	53                   	push   %bx
    15ae:	51                   	push   %cx
    15af:	52                   	push   %dx
    15b0:	b4 06                	mov    $0x6,%ah
    15b2:	b0 01                	mov    $0x1,%al
    15b4:	b5 00                	mov    $0x0,%ch
    15b6:	b1 00                	mov    $0x0,%cl
    15b8:	b6 17                	mov    $0x17,%dh
    15ba:	b2 4f                	mov    $0x4f,%dl
    15bc:	b7 10                	mov    $0x10,%bh
    15be:	cd 10                	int    $0x10
    15c0:	5a                   	pop    %dx
    15c1:	59                   	pop    %cx
    15c2:	5b                   	pop    %bx
    15c3:	58                   	pop    %ax
    15c4:	66 c3                	retl   

000015c6 <get_random>:
get_random():
    15c6:	53                   	push   %bx
    15c7:	b8 00 00             	mov    $0x0,%ax
    15ca:	e6 43                	out    %al,$0x43
    15cc:	e4 40                	in     $0x40,%al
    15ce:	b3 08                	mov    $0x8,%bl
    15d0:	f6 f3                	div    %bl
    15d2:	88 e0                	mov    %ah,%al
    15d4:	b4 00                	mov    $0x0,%ah
    15d6:	83 c0 72             	add    $0x72,%ax
    15d9:	5b                   	pop    %bx
    15da:	66 c3                	retl   

000015dc <read_sector>:
read_sector():
    15dc:	66 55                	push   %ebp
    15de:	66 89 e5             	mov    %esp,%ebp
    15e1:	50                   	push   %ax
    15e2:	53                   	push   %bx
    15e3:	51                   	push   %cx
    15e4:	52                   	push   %dx
    15e5:	06                   	push   %es
    15e6:	67 8b 45 14          	mov    0x14(%ebp),%ax
    15ea:	8e c0                	mov    %ax,%es
    15ec:	67 8b 5d 18          	mov    0x18(%ebp),%bx
    15f0:	b4 02                	mov    $0x2,%ah
    15f2:	b0 01                	mov    $0x1,%al
    15f4:	b2 00                	mov    $0x0,%dl
    15f6:	67 8a 75 08          	mov    0x8(%ebp),%dh
    15fa:	67 8a 6d 0c          	mov    0xc(%ebp),%ch
    15fe:	67 8a 4d 10          	mov    0x10(%ebp),%cl
    1602:	cd 13                	int    $0x13
    1604:	07                   	pop    %es
    1605:	5a                   	pop    %dx
    1606:	59                   	pop    %cx
    1607:	5b                   	pop    %bx
    1608:	58                   	pop    %ax
    1609:	66 89 ec             	mov    %ebp,%esp
    160c:	66 5d                	pop    %ebp
    160e:	66 c3                	retl   

00001610 <print_my_name>:
print_my_name():
    1610:	50                   	push   %ax
    1611:	53                   	push   %bx
    1612:	51                   	push   %cx
    1613:	52                   	push   %dx
    1614:	1e                   	push   %ds
    1615:	06                   	push   %es
    1616:	55                   	push   %bp
    1617:	b8 00 10             	mov    $0x1000,%ax
    161a:	8e c0                	mov    %ax,%es
    161c:	b8 fc 20             	mov    $0x20fc,%ax
    161f:	89 c5                	mov    %ax,%bp
    1621:	b4 13                	mov    $0x13,%ah
    1623:	b0 00                	mov    $0x0,%al
    1625:	b7 00                	mov    $0x0,%bh
    1627:	b3 0f                	mov    $0xf,%bl
    1629:	b9 19 00             	mov    $0x19,%cx
    162c:	b6 18                	mov    $0x18,%dh
    162e:	b2 01                	mov    $0x1,%dl
    1630:	cd 10                	int    $0x10
    1632:	5d                   	pop    %bp
    1633:	07                   	pop    %es
    1634:	1f                   	pop    %ds
    1635:	5a                   	pop    %dx
    1636:	59                   	pop    %cx
    1637:	5b                   	pop    %bx
    1638:	58                   	pop    %ax
    1639:	c3                   	ret    

0000163a <reboot>:
reboot():
    163a:	b4 06                	mov    $0x6,%ah
    163c:	b0 00                	mov    $0x0,%al
    163e:	b5 00                	mov    $0x0,%ch
    1640:	b1 00                	mov    $0x0,%cl
    1642:	b6 18                	mov    $0x18,%dh
    1644:	b2 4f                	mov    $0x4f,%dl
    1646:	b7 1f                	mov    $0x1f,%bh
    1648:	cd 10                	int    $0x10
    164a:	cd 19                	int    $0x19

0000164c <strlen>:
strlen():
/mnt/e/code/my_operating_system/os/service/../lib/string.c:3
#include "../include/type.h"

size_t strlen(char * str){
    164c:	67 66 8b 54 24 04    	mov    0x4(%esp),%edx
/mnt/e/code/my_operating_system/os/service/../lib/string.c:4
    u32 len = 0;
    1652:	66 b8 00 00 00 00    	mov    $0x0,%eax
/mnt/e/code/my_operating_system/os/service/../lib/string.c:5
    while (str[len] != 0){
    1658:	eb 04                	jmp    165e <strlen+0x12>
/mnt/e/code/my_operating_system/os/service/../lib/string.c:6
        len++;
    165a:	66 83 c0 01          	add    $0x1,%eax
/mnt/e/code/my_operating_system/os/service/../lib/string.c:5
#include "../include/type.h"

size_t strlen(char * str){
    u32 len = 0;
    while (str[len] != 0){
    165e:	67 80 3c 02 00       	cmpb   $0x0,(%edx,%eax,1)
    1663:	75 f5                	jne    165a <strlen+0xe>
/mnt/e/code/my_operating_system/os/service/../lib/string.c:9
        len++;
    }
    return len;
}
    1665:	66 f3 c3             	repz retl 

00001668 <strncpy>:
strncpy():
/mnt/e/code/my_operating_system/os/service/../lib/string.c:11

void strncpy(char * dest, char * src, u32 size){
    1668:	66 56                	push   %esi
    166a:	66 53                	push   %ebx
    166c:	67 66 8b 5c 24 0c    	mov    0xc(%esp),%ebx
    1672:	67 66 8b 74 24 10    	mov    0x10(%esp),%esi
    1678:	67 66 8b 4c 24 14    	mov    0x14(%esp),%ecx
/mnt/e/code/my_operating_system/os/service/../lib/string.c:12
    for (int i = 0; i < size; i++){
    167e:	66 b8 00 00 00 00    	mov    $0x0,%eax
    1684:	eb 0e                	jmp    1694 <strncpy+0x2c>
/mnt/e/code/my_operating_system/os/service/../lib/string.c:13 (discriminator 3)
        dest[i] = src[i];
    1686:	67 66 0f b6 14 06    	movzbl (%esi,%eax,1),%edx
    168c:	67 88 14 03          	mov    %dl,(%ebx,%eax,1)
/mnt/e/code/my_operating_system/os/service/../lib/string.c:12 (discriminator 3)
    }
    return len;
}

void strncpy(char * dest, char * src, u32 size){
    for (int i = 0; i < size; i++){
    1690:	66 83 c0 01          	add    $0x1,%eax
/mnt/e/code/my_operating_system/os/service/../lib/string.c:12 (discriminator 1)
    1694:	66 39 c8             	cmp    %ecx,%eax
    1697:	72 ed                	jb     1686 <strncpy+0x1e>
/mnt/e/code/my_operating_system/os/service/../lib/string.c:15
        dest[i] = src[i];
    }
    dest[size] = '\0';
    1699:	67 c6 04 0b 00       	movb   $0x0,(%ebx,%ecx,1)
/mnt/e/code/my_operating_system/os/service/../lib/string.c:16
}
    169e:	66 5b                	pop    %ebx
    16a0:	66 5e                	pop    %esi
    16a2:	66 c3                	retl   

000016a4 <strcmp>:
strcmp():
/mnt/e/code/my_operating_system/os/service/../lib/string.c:18

int strcmp(char * lhs, char * rhs){
    16a4:	66 57                	push   %edi
    16a6:	66 56                	push   %esi
    16a8:	66 53                	push   %ebx
    16aa:	67 66 8b 74 24 10    	mov    0x10(%esp),%esi
    16b0:	67 66 8b 7c 24 14    	mov    0x14(%esp),%edi
/mnt/e/code/my_operating_system/os/service/../lib/string.c:19
    int lhs_len = strlen(lhs);
    16b6:	66 56                	push   %esi
    16b8:	66 e8 8e ff ff ff    	calll  164c <strlen>
    16be:	66 89 c3             	mov    %eax,%ebx
/mnt/e/code/my_operating_system/os/service/../lib/string.c:20
    int rhs_len = strlen(rhs);
    16c1:	67 66 89 3c 24       	mov    %edi,(%esp)
    16c6:	66 e8 80 ff ff ff    	calll  164c <strlen>
    16cc:	66 83 c4 04          	add    $0x4,%esp
/mnt/e/code/my_operating_system/os/service/../lib/string.c:21
    if (lhs_len != rhs_len){
    16d0:	66 39 c3             	cmp    %eax,%ebx
    16d3:	75 25                	jne    16fa <strcmp+0x56>
    16d5:	66 b8 00 00 00 00    	mov    $0x0,%eax
    16db:	eb 10                	jmp    16ed <strcmp+0x49>
/mnt/e/code/my_operating_system/os/service/../lib/string.c:25
        return 1;
    }
    for (int i = 0; i < lhs_len; i++){
        if (lhs[i] != rhs[i])
    16dd:	67 66 0f b6 14 07    	movzbl (%edi,%eax,1),%edx
    16e3:	67 38 14 06          	cmp    %dl,(%esi,%eax,1)
    16e7:	75 19                	jne    1702 <strcmp+0x5e>
/mnt/e/code/my_operating_system/os/service/../lib/string.c:24 (discriminator 2)
    int lhs_len = strlen(lhs);
    int rhs_len = strlen(rhs);
    if (lhs_len != rhs_len){
        return 1;
    }
    for (int i = 0; i < lhs_len; i++){
    16e9:	66 83 c0 01          	add    $0x1,%eax
/mnt/e/code/my_operating_system/os/service/../lib/string.c:24 (discriminator 1)
    16ed:	66 39 d8             	cmp    %ebx,%eax
    16f0:	7c eb                	jl     16dd <strcmp+0x39>
/mnt/e/code/my_operating_system/os/service/../lib/string.c:28
        if (lhs[i] != rhs[i])
            return 1;
    }
    return 0;
    16f2:	66 b8 00 00 00 00    	mov    $0x0,%eax
    16f8:	eb 0e                	jmp    1708 <strcmp+0x64>
/mnt/e/code/my_operating_system/os/service/../lib/string.c:22

int strcmp(char * lhs, char * rhs){
    int lhs_len = strlen(lhs);
    int rhs_len = strlen(rhs);
    if (lhs_len != rhs_len){
        return 1;
    16fa:	66 b8 01 00 00 00    	mov    $0x1,%eax
    1700:	eb 06                	jmp    1708 <strcmp+0x64>
/mnt/e/code/my_operating_system/os/service/../lib/string.c:26
    }
    for (int i = 0; i < lhs_len; i++){
        if (lhs[i] != rhs[i])
            return 1;
    1702:	66 b8 01 00 00 00    	mov    $0x1,%eax
/mnt/e/code/my_operating_system/os/service/../lib/string.c:29
    }
    return 0;
}
    1708:	66 5b                	pop    %ebx
    170a:	66 5e                	pop    %esi
    170c:	66 5f                	pop    %edi
    170e:	66 c3                	retl   

00001710 <strncmp>:
strncmp():
/mnt/e/code/my_operating_system/os/service/../lib/string.c:31

int strncmp(char * lhs, char * rhs, int size){
    1710:	66 56                	push   %esi
    1712:	66 53                	push   %ebx
    1714:	67 66 8b 5c 24 0c    	mov    0xc(%esp),%ebx
    171a:	67 66 8b 4c 24 10    	mov    0x10(%esp),%ecx
    1720:	67 66 8b 74 24 14    	mov    0x14(%esp),%esi
/mnt/e/code/my_operating_system/os/service/../lib/string.c:32
    for (int i = 0; i < size; i++){
    1726:	66 b8 00 00 00 00    	mov    $0x0,%eax
    172c:	eb 10                	jmp    173e <strncmp+0x2e>
/mnt/e/code/my_operating_system/os/service/../lib/string.c:33
        if (lhs[i] != rhs[i])
    172e:	67 66 0f b6 14 01    	movzbl (%ecx,%eax,1),%edx
    1734:	67 38 14 03          	cmp    %dl,(%ebx,%eax,1)
    1738:	75 11                	jne    174b <strncmp+0x3b>
/mnt/e/code/my_operating_system/os/service/../lib/string.c:32 (discriminator 2)
    }
    return 0;
}

int strncmp(char * lhs, char * rhs, int size){
    for (int i = 0; i < size; i++){
    173a:	66 83 c0 01          	add    $0x1,%eax
/mnt/e/code/my_operating_system/os/service/../lib/string.c:32 (discriminator 1)
    173e:	66 39 f0             	cmp    %esi,%eax
    1741:	7c eb                	jl     172e <strncmp+0x1e>
/mnt/e/code/my_operating_system/os/service/../lib/string.c:36
        if (lhs[i] != rhs[i])
            return 1;
    }
    return 0;
    1743:	66 b8 00 00 00 00    	mov    $0x0,%eax
    1749:	eb 06                	jmp    1751 <strncmp+0x41>
/mnt/e/code/my_operating_system/os/service/../lib/string.c:34
}

int strncmp(char * lhs, char * rhs, int size){
    for (int i = 0; i < size; i++){
        if (lhs[i] != rhs[i])
            return 1;
    174b:	66 b8 01 00 00 00    	mov    $0x1,%eax
/mnt/e/code/my_operating_system/os/service/../lib/string.c:37
    }
    return 0;
    1751:	66 5b                	pop    %ebx
    1753:	66 5e                	pop    %esi
    1755:	66 c3                	retl   

00001757 <move_name>:
move_name():
/mnt/e/code/my_operating_system/os/service/../lib/style.c:9

void move_name(){
    u16 *text_line = 1920*2;
    // text_line 0-79
    // text_line[80]
    u16 last_char = text_line[79];
    1757:	66 0f b7 0e 9e 0f    	movzwl 0xf9e,%ecx
/mnt/e/code/my_operating_system/os/service/../lib/style.c:10
    for (int i =78; i >= 0; i--){
    175d:	66 b8 4e 00 00 00    	mov    $0x4e,%eax
    1763:	eb 16                	jmp    177b <move_name+0x24>
/mnt/e/code/my_operating_system/os/service/../lib/style.c:11 (discriminator 3)
        text_line[i+1] = text_line[i];
    1765:	67 66 0f b7 94 00 00 	movzwl 0xf00(%eax,%eax,1),%edx
    176c:	0f 00 00 
    176f:	67 89 94 00 02 0f 00 	mov    %dx,0xf02(%eax,%eax,1)
    1776:	00 
/mnt/e/code/my_operating_system/os/service/../lib/style.c:10 (discriminator 3)
void move_name(){
    u16 *text_line = 1920*2;
    // text_line 0-79
    // text_line[80]
    u16 last_char = text_line[79];
    for (int i =78; i >= 0; i--){
    1777:	66 83 e8 01          	sub    $0x1,%eax
/mnt/e/code/my_operating_system/os/service/../lib/style.c:10 (discriminator 1)
    177b:	66 85 c0             	test   %eax,%eax
    177e:	79 e5                	jns    1765 <move_name+0xe>
/mnt/e/code/my_operating_system/os/service/../lib/style.c:13
        text_line[i+1] = text_line[i];
    }
    text_line[0] = last_char;
    1780:	89 0e 00 0f          	mov    %cx,0xf00
    1784:	66 c3                	retl   
