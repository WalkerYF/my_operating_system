
kernel.debug:     file format elf32-i386


Disassembly of section .text:

00000000 <_start>:
_start():
       0:	e8 04 01             	call   107 <install_int33>
       3:	e8 3a 01             	call   140 <install_int34>
       6:	e8 74 01             	call   17d <install_int35>
       9:	e8 ac 01             	call   1b8 <install_int36>
       c:	e8 a7 00             	call   b6 <install_int40>
       f:	66 e8 e0 01 00 00    	calll  1f5 <cstart>
      15:	e8 11 00             	call   29 <install_int8>
      18:	e8 72 00             	call   8d <restart>

0000001b <start_tty>:
start_tty():
      1b:	66 e8 d8 0a 00 00    	calll  af9 <tty>
      21:	b4 02                	mov    $0x2,%ah
      23:	cd 40                	int    $0x40
      25:	eb fe                	jmp    25 <start_tty+0xa>
      27:	eb fe                	jmp    27 <user1_bound_y_right>

00000029 <install_int8>:
install_int8():
      29:	53                   	push   %bx
      2a:	51                   	push   %cx
      2b:	52                   	push   %dx
      2c:	56                   	push   %si
      2d:	57                   	push   %di
      2e:	55                   	push   %bp
      2f:	1e                   	push   %ds
      30:	06                   	push   %es
      31:	16                   	push   %ss
      32:	b0 34                	mov    $0x34,%al
      34:	e6 43                	out    %al,$0x43
      36:	b8 ff ff             	mov    $0xffff,%ax
      39:	e6 40                	out    %al,$0x40
      3b:	88 e0                	mov    %ah,%al
      3d:	e6 40                	out    %al,$0x40
      3f:	b8 00 00             	mov    $0x0,%ax
      42:	8e d8                	mov    %ax,%ds
      44:	8c c8                	mov    %cs,%ax
      46:	a3 22 00             	mov    %ax,0x22
      49:	c7 06 20 00 59 00    	movw   $0x59,0x20
      4f:	17                   	pop    %ss
      50:	07                   	pop    %es
      51:	1f                   	pop    %ds
      52:	5d                   	pop    %bp
      53:	5f                   	pop    %di
      54:	5e                   	pop    %si
      55:	5a                   	pop    %dx
      56:	59                   	pop    %cx
      57:	5b                   	pop    %bx
      58:	c3                   	ret    

00000059 <new_int8>:
new_int8():
      59:	fb                   	sti    
      5a:	66 60                	pushal 
      5c:	06                   	push   %es
      5d:	1e                   	push   %ds
      5e:	54                   	push   %sp
      5f:	16                   	push   %ss
      60:	89 e6                	mov    %sp,%si
      62:	b8 00 10             	mov    $0x1000,%ax
      65:	8e c0                	mov    %ax,%es
      67:	8b 3e 84 9f          	mov    -0x607c,%di
      6b:	b9 2e 00             	mov    $0x2e,%cx
      6e:	fc                   	cld    
      6f:	f3 a4                	rep movsb %ds:(%si),%es:(%di)
      71:	b8 00 10             	mov    $0x1000,%ax
      74:	8e c0                	mov    %ax,%es
      76:	8e d8                	mov    %ax,%ds
      78:	8e d0                	mov    %ax,%ss
      7a:	bc 00 50             	mov    $0x5000,%sp
      7d:	66 e8 1a 06 00 00    	calll  69d <schedule_process>
      83:	b0 20                	mov    $0x20,%al
      85:	e6 20                	out    %al,$0x20
      87:	e6 a0                	out    %al,$0xa0
      89:	e8 01 00             	call   8d <restart>
      8c:	cf                   	iret   

0000008d <restart>:
restart():
      8d:	8b 2e 84 9f          	mov    -0x607c,%bp
      91:	89 ee                	mov    %bp,%si
      93:	83 c6 04             	add    $0x4,%si
      96:	3e 8e 46 00          	mov    %ds:0x0(%bp),%es
      9a:	3e 8b 7e 02          	mov    %ds:0x2(%bp),%di
      9e:	b9 2a 00             	mov    $0x2a,%cx
      a1:	83 ef 2a             	sub    $0x2a,%di
      a4:	fc                   	cld    
      a5:	f3 a4                	rep movsb %ds:(%si),%es:(%di)
      a7:	8c c0                	mov    %es,%ax
      a9:	83 ef 2a             	sub    $0x2a,%di
      ac:	8e d0                	mov    %ax,%ss
      ae:	89 fc                	mov    %di,%sp
      b0:	1f                   	pop    %ds
      b1:	07                   	pop    %es
      b2:	66 61                	popal  
      b4:	fb                   	sti    
      b5:	cf                   	iret   

000000b6 <install_int40>:
install_int40():
      b6:	53                   	push   %bx
      b7:	51                   	push   %cx
      b8:	52                   	push   %dx
      b9:	56                   	push   %si
      ba:	57                   	push   %di
      bb:	55                   	push   %bp
      bc:	1e                   	push   %ds
      bd:	06                   	push   %es
      be:	16                   	push   %ss
      bf:	b8 00 00             	mov    $0x0,%ax
      c2:	8e d8                	mov    %ax,%ds
      c4:	8c c8                	mov    %cs,%ax
      c6:	c7 06 00 01 d9 00    	movw   $0xd9,0x100
      cc:	a3 02 01             	mov    %ax,0x102
      cf:	17                   	pop    %ss
      d0:	07                   	pop    %es
      d1:	1f                   	pop    %ds
      d2:	5d                   	pop    %bp
      d3:	5f                   	pop    %di
      d4:	5e                   	pop    %si
      d5:	5a                   	pop    %dx
      d6:	59                   	pop    %cx
      d7:	5b                   	pop    %bx
      d8:	c3                   	ret    

000000d9 <new_int40>:
new_int40():
      d9:	80 fc 4c             	cmp    $0x4c,%ah
      dc:	74 11                	je     ef <new_int40.return_kernel>
      de:	88 e3                	mov    %ah,%bl
      e0:	31 c0                	xor    %ax,%ax
      e2:	b0 02                	mov    $0x2,%al
      e4:	f6 e3                	mul    %bl
      e6:	89 c6                	mov    %ax,%si
      e8:	bb a0 9f             	mov    $0x9fa0,%bx
      eb:	66 ff 10             	calll  *(%bx,%si)
      ee:	cf                   	iret   

000000ef <new_int40.return_kernel>:
new_int40.return_kernel():
      ef:	59                   	pop    %cx
      f0:	59                   	pop    %cx
      f1:	59                   	pop    %cx
      f2:	b8 00 10             	mov    $0x1000,%ax
      f5:	8e d8                	mov    %ax,%ds
      f7:	8e c0                	mov    %ax,%es
      f9:	8e d0                	mov    %ax,%ss
      fb:	bc 00 50             	mov    $0x5000,%sp
      fe:	51                   	push   %cx
      ff:	68 00 10             	push   $0x1000
     102:	68 1b 00             	push   $0x1b
     105:	fb                   	sti    
     106:	cf                   	iret   

00000107 <install_int33>:
install_int33():
     107:	53                   	push   %bx
     108:	51                   	push   %cx
     109:	52                   	push   %dx
     10a:	56                   	push   %si
     10b:	57                   	push   %di
     10c:	55                   	push   %bp
     10d:	1e                   	push   %ds
     10e:	06                   	push   %es
     10f:	16                   	push   %ss
     110:	b8 00 00             	mov    $0x0,%ax
     113:	8e d8                	mov    %ax,%ds
     115:	8c c8                	mov    %cs,%ax
     117:	c7 06 cc 00 2a 01    	movw   $0x12a,0xcc
     11d:	a3 ce 00             	mov    %ax,0xce
     120:	17                   	pop    %ss
     121:	07                   	pop    %es
     122:	1f                   	pop    %ds
     123:	5d                   	pop    %bp
     124:	5f                   	pop    %di
     125:	5e                   	pop    %si
     126:	5a                   	pop    %dx
     127:	59                   	pop    %cx
     128:	5b                   	pop    %bx
     129:	c3                   	ret    

0000012a <new_int33>:
new_int33():
     12a:	53                   	push   %bx
     12b:	51                   	push   %cx
     12c:	52                   	push   %dx
     12d:	56                   	push   %si
     12e:	57                   	push   %di
     12f:	55                   	push   %bp
     130:	1e                   	push   %ds
     131:	06                   	push   %es
     132:	16                   	push   %ss
     133:	89 c2                	mov    %ax,%dx
     135:	ec                   	in     (%dx),%al
     136:	17                   	pop    %ss
     137:	07                   	pop    %es
     138:	1f                   	pop    %ds
     139:	5d                   	pop    %bp
     13a:	5f                   	pop    %di
     13b:	5e                   	pop    %si
     13c:	5a                   	pop    %dx
     13d:	59                   	pop    %cx
     13e:	5b                   	pop    %bx
     13f:	cf                   	iret   

00000140 <install_int34>:
install_int34():
     140:	53                   	push   %bx
     141:	51                   	push   %cx
     142:	52                   	push   %dx
     143:	56                   	push   %si
     144:	57                   	push   %di
     145:	55                   	push   %bp
     146:	1e                   	push   %ds
     147:	06                   	push   %es
     148:	16                   	push   %ss
     149:	b8 00 00             	mov    $0x0,%ax
     14c:	8e d8                	mov    %ax,%ds
     14e:	8c c8                	mov    %cs,%ax
     150:	c7 06 d0 00 63 01    	movw   $0x163,0xd0
     156:	a3 d2 00             	mov    %ax,0xd2
     159:	17                   	pop    %ss
     15a:	07                   	pop    %es
     15b:	1f                   	pop    %ds
     15c:	5d                   	pop    %bp
     15d:	5f                   	pop    %di
     15e:	5e                   	pop    %si
     15f:	5a                   	pop    %dx
     160:	59                   	pop    %cx
     161:	5b                   	pop    %bx
     162:	c3                   	ret    

00000163 <new_int34>:
new_int34():
     163:	50                   	push   %ax
     164:	53                   	push   %bx
     165:	51                   	push   %cx
     166:	52                   	push   %dx
     167:	56                   	push   %si
     168:	57                   	push   %di
     169:	55                   	push   %bp
     16a:	1e                   	push   %ds
     16b:	06                   	push   %es
     16c:	16                   	push   %ss
     16d:	89 da                	mov    %bx,%dx
     16f:	88 c0                	mov    %al,%al
     171:	ee                   	out    %al,(%dx)
     172:	17                   	pop    %ss
     173:	07                   	pop    %es
     174:	1f                   	pop    %ds
     175:	5d                   	pop    %bp
     176:	5f                   	pop    %di
     177:	5e                   	pop    %si
     178:	5a                   	pop    %dx
     179:	59                   	pop    %cx
     17a:	5b                   	pop    %bx
     17b:	58                   	pop    %ax
     17c:	cf                   	iret   

0000017d <install_int35>:
install_int35():
     17d:	53                   	push   %bx
     17e:	51                   	push   %cx
     17f:	52                   	push   %dx
     180:	56                   	push   %si
     181:	57                   	push   %di
     182:	55                   	push   %bp
     183:	1e                   	push   %ds
     184:	06                   	push   %es
     185:	16                   	push   %ss
     186:	b8 00 00             	mov    $0x0,%ax
     189:	8e d8                	mov    %ax,%ds
     18b:	8c c8                	mov    %cs,%ax
     18d:	c7 06 d4 00 a0 01    	movw   $0x1a0,0xd4
     193:	a3 d6 00             	mov    %ax,0xd6
     196:	17                   	pop    %ss
     197:	07                   	pop    %es
     198:	1f                   	pop    %ds
     199:	5d                   	pop    %bp
     19a:	5f                   	pop    %di
     19b:	5e                   	pop    %si
     19c:	5a                   	pop    %dx
     19d:	59                   	pop    %cx
     19e:	5b                   	pop    %bx
     19f:	c3                   	ret    

000001a0 <new_int35>:
new_int35():
     1a0:	53                   	push   %bx
     1a1:	51                   	push   %cx
     1a2:	52                   	push   %dx
     1a3:	56                   	push   %si
     1a4:	57                   	push   %di
     1a5:	55                   	push   %bp
     1a6:	1e                   	push   %ds
     1a7:	06                   	push   %es
     1a8:	16                   	push   %ss
     1a9:	8e c0                	mov    %ax,%es
     1ab:	26 8a 07             	mov    %es:(%bx),%al
     1ae:	17                   	pop    %ss
     1af:	07                   	pop    %es
     1b0:	1f                   	pop    %ds
     1b1:	5d                   	pop    %bp
     1b2:	5f                   	pop    %di
     1b3:	5e                   	pop    %si
     1b4:	5a                   	pop    %dx
     1b5:	59                   	pop    %cx
     1b6:	5b                   	pop    %bx
     1b7:	cf                   	iret   

000001b8 <install_int36>:
install_int36():
     1b8:	53                   	push   %bx
     1b9:	51                   	push   %cx
     1ba:	52                   	push   %dx
     1bb:	56                   	push   %si
     1bc:	57                   	push   %di
     1bd:	55                   	push   %bp
     1be:	1e                   	push   %ds
     1bf:	06                   	push   %es
     1c0:	16                   	push   %ss
     1c1:	b8 00 00             	mov    $0x0,%ax
     1c4:	8e d8                	mov    %ax,%ds
     1c6:	8c c8                	mov    %cs,%ax
     1c8:	c7 06 d8 00 db 01    	movw   $0x1db,0xd8
     1ce:	a3 da 00             	mov    %ax,0xda
     1d1:	17                   	pop    %ss
     1d2:	07                   	pop    %es
     1d3:	1f                   	pop    %ds
     1d4:	5d                   	pop    %bp
     1d5:	5f                   	pop    %di
     1d6:	5e                   	pop    %si
     1d7:	5a                   	pop    %dx
     1d8:	59                   	pop    %cx
     1d9:	5b                   	pop    %bx
     1da:	c3                   	ret    

000001db <new_int36>:
new_int36():
     1db:	50                   	push   %ax
     1dc:	53                   	push   %bx
     1dd:	51                   	push   %cx
     1de:	52                   	push   %dx
     1df:	56                   	push   %si
     1e0:	57                   	push   %di
     1e1:	55                   	push   %bp
     1e2:	1e                   	push   %ds
     1e3:	06                   	push   %es
     1e4:	16                   	push   %ss
     1e5:	8e c0                	mov    %ax,%es
     1e7:	26 88 0f             	mov    %cl,%es:(%bx)
     1ea:	17                   	pop    %ss
     1eb:	07                   	pop    %es
     1ec:	1f                   	pop    %ds
     1ed:	5d                   	pop    %bp
     1ee:	5f                   	pop    %di
     1ef:	5e                   	pop    %si
     1f0:	5a                   	pop    %dx
     1f1:	59                   	pop    %cx
     1f2:	5b                   	pop    %bx
     1f3:	58                   	pop    %ax
     1f4:	cf                   	iret   

000001f5 <cstart>:
cstart():
/mnt/e/code/my_operating_system/os/kernel/start.c:10
#include "../include/global.h"
#include "../include/system_call.h"
#include "../include/fsystem.h"
#include "../include/proc.h"

int cstart(){
     1f5:	66 53                	push   %ebx
     1f7:	66 83 ec 08          	sub    $0x8,%esp
/mnt/e/code/my_operating_system/os/kernel/start.c:12
    // 初始化文件系统
    init_fsystem();
     1fb:	66 e8 1e 01 00 00    	calll  31f <init_fsystem>
/mnt/e/code/my_operating_system/os/kernel/start.c:14
    // 清屏
    clean_screen();
     201:	66 e8 db 14 00 00    	calll  16e2 <clean_screen>
/mnt/e/code/my_operating_system/os/kernel/start.c:16
    // 将光标设置为0
    set_cursor(0);
     207:	66 83 ec 0c          	sub    $0xc,%esp
     20b:	66 6a 00             	pushl  $0x0
     20e:	66 e8 f1 0a 00 00    	calll  d05 <set_cursor>
/mnt/e/code/my_operating_system/os/kernel/start.c:20


    // 加载文件到内存指定位置
    fs_load_by_name("test_a.bin", 0x2000, 0x0000);
     214:	66 83 c4 0c          	add    $0xc,%esp
     218:	66 6a 00             	pushl  $0x0
     21b:	66 68 00 20 00 00    	pushl  $0x2000
     221:	66 68 cf 18 00 00    	pushl  $0x18cf
     227:	66 e8 63 03 00 00    	calll  590 <fs_load_by_name>
/mnt/e/code/my_operating_system/os/kernel/start.c:21
    fs_load_by_name("test_b.bin", 0x3000, 0x0000);
     22d:	66 83 c4 0c          	add    $0xc,%esp
     231:	66 6a 00             	pushl  $0x0
     234:	66 68 00 30 00 00    	pushl  $0x3000
     23a:	66 68 da 18 00 00    	pushl  $0x18da
     240:	66 e8 4a 03 00 00    	calll  590 <fs_load_by_name>
/mnt/e/code/my_operating_system/os/kernel/start.c:22
    fs_load_by_name("ouch.bin", 0x4000, 0x0000);
     246:	66 83 c4 0c          	add    $0xc,%esp
     24a:	66 6a 00             	pushl  $0x0
     24d:	66 68 00 40 00 00    	pushl  $0x4000
     253:	66 68 e5 18 00 00    	pushl  $0x18e5
     259:	66 e8 31 03 00 00    	calll  590 <fs_load_by_name>
/mnt/e/code/my_operating_system/os/kernel/start.c:25
    // 初始化进程控制块

    for (int i = 0; i < CUR_PROCESS_NUM ; i++){
     25f:	66 83 c4 10          	add    $0x10,%esp
     263:	66 bb 00 00 00 00    	mov    $0x0,%ebx
     269:	eb 23                	jmp    28e <cstart+0x99>
/mnt/e/code/my_operating_system/os/kernel/start.c:26 (discriminator 3)
        init_process(i, 0x2000 + i * 0x1000);
     26b:	67 66 8d 43 02       	lea    0x2(%ebx),%eax
     270:	66 83 ec 08          	sub    $0x8,%esp
     274:	66 c1 e0 0c          	shl    $0xc,%eax
     278:	66 0f b7 c0          	movzwl %ax,%eax
     27c:	66 50                	push   %eax
     27e:	66 53                	push   %ebx
     280:	66 e8 7f 04 00 00    	calll  705 <init_process>
/mnt/e/code/my_operating_system/os/kernel/start.c:25 (discriminator 3)
    fs_load_by_name("test_a.bin", 0x2000, 0x0000);
    fs_load_by_name("test_b.bin", 0x3000, 0x0000);
    fs_load_by_name("ouch.bin", 0x4000, 0x0000);
    // 初始化进程控制块

    for (int i = 0; i < CUR_PROCESS_NUM ; i++){
     286:	66 83 c3 01          	add    $0x1,%ebx
     28a:	66 83 c4 10          	add    $0x10,%esp
/mnt/e/code/my_operating_system/os/kernel/start.c:25 (discriminator 1)
     28e:	66 83 fb 02          	cmp    $0x2,%ebx
     292:	7e d7                	jle    26b <cstart+0x76>
/mnt/e/code/my_operating_system/os/kernel/start.c:29
        init_process(i, 0x2000 + i * 0x1000);
    }
    // 初始化启动进程
    cur_process_index = 0;
     294:	c7 06 80 9f 00 00    	movw   $0x0,-0x6080
/mnt/e/code/my_operating_system/os/kernel/start.c:30
    cur_process = (PCB_t*)(&process_table[cur_process_index]);
     29a:	66 c7 06 84 9f 80 5b 	movl   $0x5b80,-0x607c
     2a1:	00 00 
/mnt/e/code/my_operating_system/os/kernel/start.c:33

    // 初始化 系统调用表
    install_system_call(2, test_system_call);
     2a3:	66 83 ec 08          	sub    $0x8,%esp
     2a7:	66 68 da 02 00 00    	pushl  $0x2da
     2ad:	66 6a 02             	pushl  $0x2
     2b0:	66 e8 0e 00 00 00    	calll  2c4 <install_system_call>
/mnt/e/code/my_operating_system/os/kernel/start.c:35
    return 0;
}
     2b6:	66 b8 00 00 00 00    	mov    $0x0,%eax
     2bc:	66 83 c4 18          	add    $0x18,%esp
     2c0:	66 5b                	pop    %ebx
     2c2:	66 c3                	retl   

000002c4 <install_system_call>:
install_system_call():
/mnt/e/code/my_operating_system/os/service/system_call.c:6
#include "../include/type.h"
#include "../include/stdio.h"
#include "../include/global.h"

void install_system_call(int system_call_number, void (*function)() ){
    system_call[system_call_number] = (u16) function;
     2c4:	67 66 8b 54 24 08    	mov    0x8(%esp),%edx
     2ca:	67 66 8b 44 24 04    	mov    0x4(%esp),%eax
     2d0:	67 89 94 00 a0 9f 00 	mov    %dx,0x9fa0(%eax,%eax,1)
     2d7:	00 
     2d8:	66 c3                	retl   

000002da <test_system_call>:
test_system_call():
/mnt/e/code/my_operating_system/os/service/system_call.c:12
    return ;
}



void test_system_call(){
     2da:	66 53                	push   %ebx
     2dc:	66 83 ec 08          	sub    $0x8,%esp
/mnt/e/code/my_operating_system/os/service/system_call.c:13
    int origin = get_cursor();
     2e0:	66 e8 91 0a 00 00    	calll  d77 <get_cursor>
     2e6:	66 89 c3             	mov    %eax,%ebx
/mnt/e/code/my_operating_system/os/service/system_call.c:14
    set_cursor(1800);
     2e9:	66 83 ec 0c          	sub    $0xc,%esp
     2ed:	66 68 08 07 00 00    	pushl  $0x708
     2f3:	66 e8 0c 0a 00 00    	calll  d05 <set_cursor>
/mnt/e/code/my_operating_system/os/service/system_call.c:15
    printf("test custom system call!!! ");
     2f9:	67 66 c7 04 24 ee 18 	movl   $0x18ee,(%esp)
     300:	00 00 
     302:	66 e8 46 10 00 00    	calll  134e <printf>
/mnt/e/code/my_operating_system/os/service/system_call.c:16
    set_cursor(origin);
     308:	66 0f b7 db          	movzwl %bx,%ebx
     30c:	67 66 89 1c 24       	mov    %ebx,(%esp)
     311:	66 e8 ee 09 00 00    	calll  d05 <set_cursor>
/mnt/e/code/my_operating_system/os/service/system_call.c:17
}
     317:	66 83 c4 18          	add    $0x18,%esp
     31b:	66 5b                	pop    %ebx
     31d:	66 c3                	retl   

0000031f <init_fsystem>:
init_fsystem():
/mnt/e/code/my_operating_system/os/service/fsystem.c:14
FileDescriptor root[56];
u16 root_sector;
u16 first_cluster_by_sector;
u16 cluster2sector;

void init_fsystem(){
     31f:	66 83 ec 0c          	sub    $0xc,%esp
/mnt/e/code/my_operating_system/os/service/fsystem.c:15
    cluster2sector = 1;
     323:	c7 06 40 5b 01 00    	movw   $0x1,0x5b40
/mnt/e/code/my_operating_system/os/service/fsystem.c:16
    root_sector = 37;
     329:	c7 06 20 50 25 00    	movw   $0x25,0x5020
/mnt/e/code/my_operating_system/os/service/fsystem.c:17
    first_cluster_by_sector = root_sector + 1;  
     32f:	c7 06 42 5b 26 00    	movw   $0x26,0x5b42
/mnt/e/code/my_operating_system/os/service/fsystem.c:18
    read_n_sector(root_sector,1, 0x1000, (u16)&root);
     335:	66 b8 40 54 00 00    	mov    $0x5440,%eax
     33b:	66 0f b7 c0          	movzwl %ax,%eax
     33f:	66 50                	push   %eax
     341:	66 68 00 10 00 00    	pushl  $0x1000
     347:	66 6a 01             	pushl  $0x1
     34a:	66 6a 25             	pushl  $0x25
     34d:	66 e8 09 12 00 00    	calll  155c <read_n_sector>
/mnt/e/code/my_operating_system/os/service/fsystem.c:19
    read_n_sector(1,2,0x1000, (u16)&FAT_table);// 这个会覆盖掉root吗？
     353:	66 b8 40 50 00 00    	mov    $0x5040,%eax
     359:	66 0f b7 c0          	movzwl %ax,%eax
     35d:	66 50                	push   %eax
     35f:	66 68 00 10 00 00    	pushl  $0x1000
     365:	66 6a 02             	pushl  $0x2
     368:	66 6a 01             	pushl  $0x1
     36b:	66 e8 eb 11 00 00    	calll  155c <read_n_sector>
/mnt/e/code/my_operating_system/os/service/fsystem.c:27
    // puti(FAT_table[0]);
    // puti(root[0].cluster_number);
    // puts(&root[0], 10);
    // puts(&root[1], 10);
    // puts(&root[2], 10);
}
     371:	66 83 c4 2c          	add    $0x2c,%esp
     375:	66 c3                	retl   

00000377 <_fs_find_descriptor_number_by_name>:
_fs_find_descriptor_number_by_name():
/mnt/e/code/my_operating_system/os/service/fsystem.c:29

u16 _fs_find_descriptor_number_by_name(char * file_name){
     377:	66 57                	push   %edi
     379:	66 56                	push   %esi
     37b:	66 53                	push   %ebx
     37d:	67 66 8b 7c 24 10    	mov    0x10(%esp),%edi
/mnt/e/code/my_operating_system/os/service/fsystem.c:30
    int file_name_length = strlen(file_name);
     383:	66 83 ec 0c          	sub    $0xc,%esp
     387:	66 57                	push   %edi
     389:	66 e8 06 14 00 00    	calll  1795 <strlen>
     38f:	66 89 c6             	mov    %eax,%esi
/mnt/e/code/my_operating_system/os/service/fsystem.c:31
    if (file_name_length >= 11) file_name_length = 11;
     392:	66 83 c4 10          	add    $0x10,%esp
     396:	66 83 f8 0a          	cmp    $0xa,%eax
     39a:	7e 06                	jle    3a2 <_fs_find_descriptor_number_by_name+0x2b>
     39c:	66 be 0b 00 00 00    	mov    $0xb,%esi
/mnt/e/code/my_operating_system/os/service/fsystem.c:33
    // TODO:这里的10是文件数，需要使用常量代替
    for (int i = 0; i < 10; i++){
     3a2:	66 bb 00 00 00 00    	mov    $0x0,%ebx
     3a8:	eb 2f                	jmp    3d9 <_fs_find_descriptor_number_by_name+0x62>
/mnt/e/code/my_operating_system/os/service/fsystem.c:34
        if (!strncmp((char *)&root[i], file_name, file_name_length)){
     3aa:	66 89 d8             	mov    %ebx,%eax
     3ad:	66 c1 e0 05          	shl    $0x5,%eax
     3b1:	66 05 40 54 00 00    	add    $0x5440,%eax
     3b7:	66 83 ec 04          	sub    $0x4,%esp
     3bb:	66 56                	push   %esi
     3bd:	66 57                	push   %edi
     3bf:	66 50                	push   %eax
     3c1:	66 e8 92 14 00 00    	calll  1859 <strncmp>
     3c7:	66 83 c4 10          	add    $0x10,%esp
     3cb:	66 85 c0             	test   %eax,%eax
     3ce:	75 05                	jne    3d5 <_fs_find_descriptor_number_by_name+0x5e>
/mnt/e/code/my_operating_system/os/service/fsystem.c:35
            return i;
     3d0:	66 89 d8             	mov    %ebx,%eax
     3d3:	eb 10                	jmp    3e5 <_fs_find_descriptor_number_by_name+0x6e>
/mnt/e/code/my_operating_system/os/service/fsystem.c:33 (discriminator 2)

u16 _fs_find_descriptor_number_by_name(char * file_name){
    int file_name_length = strlen(file_name);
    if (file_name_length >= 11) file_name_length = 11;
    // TODO:这里的10是文件数，需要使用常量代替
    for (int i = 0; i < 10; i++){
     3d5:	66 83 c3 01          	add    $0x1,%ebx
/mnt/e/code/my_operating_system/os/service/fsystem.c:33 (discriminator 1)
     3d9:	66 83 fb 09          	cmp    $0x9,%ebx
     3dd:	7e cb                	jle    3aa <_fs_find_descriptor_number_by_name+0x33>
/mnt/e/code/my_operating_system/os/service/fsystem.c:38
        if (!strncmp((char *)&root[i], file_name, file_name_length)){
            return i;
        }
    }
    return -1;
     3df:	66 b8 ff ff ff ff    	mov    $0xffffffff,%eax
/mnt/e/code/my_operating_system/os/service/fsystem.c:39
}
     3e5:	66 5b                	pop    %ebx
     3e7:	66 5e                	pop    %esi
     3e9:	66 5f                	pop    %edi
     3eb:	66 c3                	retl   

000003ed <_fs_find_cluster_code_by_name>:
_fs_find_cluster_code_by_name():
/mnt/e/code/my_operating_system/os/service/fsystem.c:41

u16 _fs_find_cluster_code_by_name(char * file_name){
     3ed:	66 83 ec 18          	sub    $0x18,%esp
/mnt/e/code/my_operating_system/os/service/fsystem.c:42
    int index = _fs_find_descriptor_number_by_name(file_name);
     3f1:	67 66 ff 74 24 1c    	pushl  0x1c(%esp)
     3f7:	66 e8 7a ff ff ff    	calll  377 <_fs_find_descriptor_number_by_name>
     3fd:	66 0f b7 c0          	movzwl %ax,%eax
/mnt/e/code/my_operating_system/os/service/fsystem.c:44
    if (index != -1)
        return root[index].cluster_code;
     401:	66 c1 e0 05          	shl    $0x5,%eax
     405:	67 66 0f b7 80 5a 54 	movzwl 0x545a(%eax),%eax
     40c:	00 00 
/mnt/e/code/my_operating_system/os/service/fsystem.c:46
    return 0;
}
     40e:	66 83 c4 1c          	add    $0x1c,%esp
     412:	66 c3                	retl   

00000414 <_fs_get_file_size_by_cluster_code>:
_fs_get_file_size_by_cluster_code():
/mnt/e/code/my_operating_system/os/service/fsystem.c:48

u16 _fs_get_file_size_by_cluster_code(u16 cluster_code){
     414:	67 66 0f b7 54 24 04 	movzwl 0x4(%esp),%edx
/mnt/e/code/my_operating_system/os/service/fsystem.c:49
    int size = 0;
     41b:	66 b8 00 00 00 00    	mov    $0x0,%eax
/mnt/e/code/my_operating_system/os/service/fsystem.c:50
    while (0x0002 <= cluster_code && cluster_code <= 0xFFEF){
     421:	eb 1b                	jmp    43e <_fs_get_file_size_by_cluster_code+0x2a>
/mnt/e/code/my_operating_system/os/service/fsystem.c:51
        size += 512*cluster2sector;
     423:	66 0f b7 0e 40 5b    	movzwl 0x5b40,%ecx
     429:	66 c1 e1 09          	shl    $0x9,%ecx
     42d:	66 01 c8             	add    %ecx,%eax
/mnt/e/code/my_operating_system/os/service/fsystem.c:52
        int sector_number = first_cluster_by_sector + (cluster_code-2)*cluster2sector;
     430:	66 0f b7 d2          	movzwl %dx,%edx
/mnt/e/code/my_operating_system/os/service/fsystem.c:53
        cluster_code = FAT_table[cluster_code];
     434:	67 66 0f b7 94 12 40 	movzwl 0x5040(%edx,%edx,1),%edx
     43b:	50 00 00 
/mnt/e/code/my_operating_system/os/service/fsystem.c:50
    return 0;
}

u16 _fs_get_file_size_by_cluster_code(u16 cluster_code){
    int size = 0;
    while (0x0002 <= cluster_code && cluster_code <= 0xFFEF){
     43e:	67 66 8d 4a fe       	lea    -0x2(%edx),%ecx
     443:	83 f9 ed             	cmp    $0xffed,%cx
     446:	76 db                	jbe    423 <_fs_get_file_size_by_cluster_code+0xf>
/mnt/e/code/my_operating_system/os/service/fsystem.c:56
        size += 512*cluster2sector;
        int sector_number = first_cluster_by_sector + (cluster_code-2)*cluster2sector;
        cluster_code = FAT_table[cluster_code];
    }
    return size;
}
     448:	66 f3 c3             	repz retl 

0000044b <_fs_show_file_by_descriptor_number>:
_fs_show_file_by_descriptor_number():
/mnt/e/code/my_operating_system/os/service/fsystem.c:58

void _fs_show_file_by_descriptor_number(u16 index){
     44b:	66 56                	push   %esi
     44d:	66 53                	push   %ebx
     44f:	66 83 ec 08          	sub    $0x8,%esp
/mnt/e/code/my_operating_system/os/service/fsystem.c:59
    int cluster_code = root[index].cluster_code;
     453:	67 66 0f b7 44 24 14 	movzwl 0x14(%esp),%eax
     45a:	66 89 c6             	mov    %eax,%esi
     45d:	66 c1 e6 05          	shl    $0x5,%esi
     461:	67 66 0f b7 9e 5a 54 	movzwl 0x545a(%esi),%ebx
     468:	00 00 
     46a:	66 81 c6 40 54 00 00 	add    $0x5440,%esi
/mnt/e/code/my_operating_system/os/service/fsystem.c:60
    printf("%d, %d\n" , index,cluster_code);
     471:	66 53                	push   %ebx
     473:	66 50                	push   %eax
     475:	66 68 0a 19 00 00    	pushl  $0x190a
     47b:	66 e8 cd 0e 00 00    	calll  134e <printf>
/mnt/e/code/my_operating_system/os/service/fsystem.c:62
    printf("%s   | %d byte |", (char *)&root[index],
                             _fs_get_file_size_by_cluster_code(cluster_code));
     481:	67 66 89 1c 24       	mov    %ebx,(%esp)
     486:	66 e8 88 ff ff ff    	calll  414 <_fs_get_file_size_by_cluster_code>
     48c:	66 83 c4 0c          	add    $0xc,%esp
/mnt/e/code/my_operating_system/os/service/fsystem.c:61
}

void _fs_show_file_by_descriptor_number(u16 index){
    int cluster_code = root[index].cluster_code;
    printf("%d, %d\n" , index,cluster_code);
    printf("%s   | %d byte |", (char *)&root[index],
     490:	66 0f b7 c0          	movzwl %ax,%eax
     494:	66 50                	push   %eax
     496:	66 56                	push   %esi
     498:	66 68 12 19 00 00    	pushl  $0x1912
     49e:	66 e8 aa 0e 00 00    	calll  134e <printf>
/mnt/e/code/my_operating_system/os/service/fsystem.c:63
                             _fs_get_file_size_by_cluster_code(cluster_code));
    while (0x0002 <= cluster_code && cluster_code <= 0xFFEF){
     4a4:	66 83 c4 10          	add    $0x10,%esp
     4a8:	eb 20                	jmp    4ca <_fs_show_file_by_descriptor_number+0x7f>
/mnt/e/code/my_operating_system/os/service/fsystem.c:64
        printf("-%d", cluster_code);
     4aa:	66 83 ec 08          	sub    $0x8,%esp
     4ae:	66 53                	push   %ebx
     4b0:	66 68 23 19 00 00    	pushl  $0x1923
     4b6:	66 e8 92 0e 00 00    	calll  134e <printf>
/mnt/e/code/my_operating_system/os/service/fsystem.c:65
        cluster_code = FAT_table[cluster_code];
     4bc:	67 66 0f b7 9c 1b 40 	movzwl 0x5040(%ebx,%ebx,1),%ebx
     4c3:	50 00 00 
     4c6:	66 83 c4 10          	add    $0x10,%esp
/mnt/e/code/my_operating_system/os/service/fsystem.c:63
void _fs_show_file_by_descriptor_number(u16 index){
    int cluster_code = root[index].cluster_code;
    printf("%d, %d\n" , index,cluster_code);
    printf("%s   | %d byte |", (char *)&root[index],
                             _fs_get_file_size_by_cluster_code(cluster_code));
    while (0x0002 <= cluster_code && cluster_code <= 0xFFEF){
     4ca:	67 66 8d 43 fe       	lea    -0x2(%ebx),%eax
     4cf:	66 3d ed ff 00 00    	cmp    $0xffed,%eax
     4d5:	76 d3                	jbe    4aa <_fs_show_file_by_descriptor_number+0x5f>
/mnt/e/code/my_operating_system/os/service/fsystem.c:67
        printf("-%d", cluster_code);
        cluster_code = FAT_table[cluster_code];
    }
    printf("-|\n");
     4d7:	66 83 ec 0c          	sub    $0xc,%esp
     4db:	66 68 27 19 00 00    	pushl  $0x1927
     4e1:	66 e8 67 0e 00 00    	calll  134e <printf>
/mnt/e/code/my_operating_system/os/service/fsystem.c:69
    return ;
}
     4e7:	66 83 c4 14          	add    $0x14,%esp
     4eb:	66 5b                	pop    %ebx
     4ed:	66 5e                	pop    %esi
     4ef:	66 c3                	retl   

000004f1 <_fs_load_by_cluster_code>:
_fs_load_by_cluster_code():
/mnt/e/code/my_operating_system/os/service/fsystem.c:71

u16 _fs_load_by_cluster_code(u16 cluster_code, u16 segment, u16 offset){
     4f1:	66 55                	push   %ebp
     4f3:	66 57                	push   %edi
     4f5:	66 56                	push   %esi
     4f7:	66 53                	push   %ebx
     4f9:	66 83 ec 0c          	sub    $0xc,%esp
     4fd:	67 66 0f b7 5c 24 20 	movzwl 0x20(%esp),%ebx
     504:	67 66 0f b7 6c 24 24 	movzwl 0x24(%esp),%ebp
     50b:	67 66 0f b7 74 24 28 	movzwl 0x28(%esp),%esi
/mnt/e/code/my_operating_system/os/service/fsystem.c:72
    int size = 0;
     512:	66 bf 00 00 00 00    	mov    $0x0,%edi
/mnt/e/code/my_operating_system/os/service/fsystem.c:73
    while (0x0002 <= cluster_code && cluster_code <= 0xFFEF){
     518:	eb 5b                	jmp    575 <_fs_load_by_cluster_code+0x84>
/mnt/e/code/my_operating_system/os/service/fsystem.c:74
        size += 512*cluster2sector;
     51a:	66 0f b7 16 40 5b    	movzwl 0x5b40,%edx
     520:	66 89 d0             	mov    %edx,%eax
     523:	66 c1 e0 09          	shl    $0x9,%eax
     527:	66 01 c7             	add    %eax,%edi
/mnt/e/code/my_operating_system/os/service/fsystem.c:75
        int sector_number = first_cluster_by_sector + (cluster_code-2)*cluster2sector;
     52a:	66 0f b7 0e 42 5b    	movzwl 0x5b42,%ecx
     530:	66 0f b7 db          	movzwl %bx,%ebx
     534:	67 66 8d 43 fe       	lea    -0x2(%ebx),%eax
     539:	66 0f af c2          	imul   %edx,%eax
     53d:	66 01 c8             	add    %ecx,%eax
/mnt/e/code/my_operating_system/os/service/fsystem.c:76
        read_n_sector(sector_number, cluster2sector, segment, offset);
     540:	66 0f b7 ce          	movzwl %si,%ecx
     544:	66 51                	push   %ecx
     546:	66 0f b7 cd          	movzwl %bp,%ecx
     54a:	66 51                	push   %ecx
     54c:	66 52                	push   %edx
     54e:	66 0f b7 c0          	movzwl %ax,%eax
     552:	66 50                	push   %eax
     554:	66 e8 02 10 00 00    	calll  155c <read_n_sector>
/mnt/e/code/my_operating_system/os/service/fsystem.c:77
        offset = offset+cluster2sector*512;
     55a:	66 0f b7 06 40 5b    	movzwl 0x5b40,%eax
     560:	66 c1 e0 09          	shl    $0x9,%eax
     564:	66 01 c6             	add    %eax,%esi
/mnt/e/code/my_operating_system/os/service/fsystem.c:78
        cluster_code = FAT_table[cluster_code];
     567:	67 66 0f b7 9c 1b 40 	movzwl 0x5040(%ebx,%ebx,1),%ebx
     56e:	50 00 00 
     571:	66 83 c4 10          	add    $0x10,%esp
/mnt/e/code/my_operating_system/os/service/fsystem.c:73
    return ;
}

u16 _fs_load_by_cluster_code(u16 cluster_code, u16 segment, u16 offset){
    int size = 0;
    while (0x0002 <= cluster_code && cluster_code <= 0xFFEF){
     575:	67 66 8d 43 fe       	lea    -0x2(%ebx),%eax
     57a:	83 f8 ed             	cmp    $0xffed,%ax
     57d:	76 9b                	jbe    51a <_fs_load_by_cluster_code+0x29>
/mnt/e/code/my_operating_system/os/service/fsystem.c:81
        read_n_sector(sector_number, cluster2sector, segment, offset);
        offset = offset+cluster2sector*512;
        cluster_code = FAT_table[cluster_code];
    }
    return size;
}
     57f:	66 89 f8             	mov    %edi,%eax
     582:	66 83 c4 0c          	add    $0xc,%esp
     586:	66 5b                	pop    %ebx
     588:	66 5e                	pop    %esi
     58a:	66 5f                	pop    %edi
     58c:	66 5d                	pop    %ebp
     58e:	66 c3                	retl   

00000590 <fs_load_by_name>:
fs_load_by_name():
/mnt/e/code/my_operating_system/os/service/fsystem.c:84


u16 fs_load_by_name(char * file_name, u16 segment, u16 offset){
     590:	66 56                	push   %esi
     592:	66 53                	push   %ebx
     594:	66 83 ec 10          	sub    $0x10,%esp
     598:	67 66 8b 5c 24 20    	mov    0x20(%esp),%ebx
     59e:	67 66 8b 74 24 24    	mov    0x24(%esp),%esi
/mnt/e/code/my_operating_system/os/service/fsystem.c:85
    int cluster_code = _fs_find_cluster_code_by_name(file_name);
     5a4:	67 66 ff 74 24 1c    	pushl  0x1c(%esp)
     5aa:	66 e8 3d fe ff ff    	calll  3ed <_fs_find_cluster_code_by_name>
     5b0:	66 0f b7 c0          	movzwl %ax,%eax
/mnt/e/code/my_operating_system/os/service/fsystem.c:86
    if (cluster_code){
     5b4:	66 83 c4 10          	add    $0x10,%esp
     5b8:	66 85 c0             	test   %eax,%eax
     5bb:	74 1e                	je     5db <fs_load_by_name+0x4b>
/mnt/e/code/my_operating_system/os/service/fsystem.c:87
        return _fs_load_by_cluster_code(cluster_code, segment, offset);
     5bd:	66 83 ec 04          	sub    $0x4,%esp
     5c1:	66 0f b7 f6          	movzwl %si,%esi
     5c5:	66 56                	push   %esi
     5c7:	66 0f b7 db          	movzwl %bx,%ebx
     5cb:	66 53                	push   %ebx
     5cd:	66 50                	push   %eax
     5cf:	66 e8 1c ff ff ff    	calll  4f1 <_fs_load_by_cluster_code>
     5d5:	66 83 c4 10          	add    $0x10,%esp
     5d9:	eb 06                	jmp    5e1 <fs_load_by_name+0x51>
/mnt/e/code/my_operating_system/os/service/fsystem.c:90
    }
    else {
        return 0;
     5db:	66 b8 00 00 00 00    	mov    $0x0,%eax
/mnt/e/code/my_operating_system/os/service/fsystem.c:92
    }
}
     5e1:	66 83 c4 04          	add    $0x4,%esp
     5e5:	66 5b                	pop    %ebx
     5e7:	66 5e                	pop    %esi
     5e9:	66 c3                	retl   

000005eb <fs_get_file_size>:
fs_get_file_size():
/mnt/e/code/my_operating_system/os/service/fsystem.c:95


u16 fs_get_file_size(char * file_name){
     5eb:	66 83 ec 18          	sub    $0x18,%esp
/mnt/e/code/my_operating_system/os/service/fsystem.c:96
    int cluster_code = _fs_find_cluster_code_by_name(file_name);
     5ef:	67 66 ff 74 24 1c    	pushl  0x1c(%esp)
     5f5:	66 e8 f2 fd ff ff    	calll  3ed <_fs_find_cluster_code_by_name>
/mnt/e/code/my_operating_system/os/service/fsystem.c:97
    return _fs_get_file_size_by_cluster_code(cluster_code);
     5fb:	66 0f b7 c0          	movzwl %ax,%eax
     5ff:	67 66 89 04 24       	mov    %eax,(%esp)
     604:	66 e8 0a fe ff ff    	calll  414 <_fs_get_file_size_by_cluster_code>
/mnt/e/code/my_operating_system/os/service/fsystem.c:98
}
     60a:	66 83 c4 1c          	add    $0x1c,%esp
     60e:	66 c3                	retl   

00000610 <fs_show_root_file_table>:
fs_show_root_file_table():
/mnt/e/code/my_operating_system/os/service/fsystem.c:100

void fs_show_root_file_table(){
     610:	66 53                	push   %ebx
     612:	66 83 ec 08          	sub    $0x8,%esp
/mnt/e/code/my_operating_system/os/service/fsystem.c:101
    printf("%s   | %s | %s\n", "file name ", "file size", "cluster");
     616:	66 68 2b 19 00 00    	pushl  $0x192b
     61c:	66 68 33 19 00 00    	pushl  $0x1933
     622:	66 68 3d 19 00 00    	pushl  $0x193d
     628:	66 68 48 19 00 00    	pushl  $0x1948
     62e:	66 e8 1a 0d 00 00    	calll  134e <printf>
/mnt/e/code/my_operating_system/os/service/fsystem.c:102
    printf("------------------------------------\n\r");
     634:	67 66 c7 04 24 20 22 	movl   $0x2220,(%esp)
     63b:	00 00 
     63d:	66 e8 0b 0d 00 00    	calll  134e <printf>
/mnt/e/code/my_operating_system/os/service/fsystem.c:104
    int file_number = 9;// TODO:文件数量需要设置！
    for(int i = 0; i < file_number; i++){
     643:	66 83 c4 10          	add    $0x10,%esp
     647:	66 bb 00 00 00 00    	mov    $0x0,%ebx
     64d:	eb 18                	jmp    667 <fs_show_root_file_table+0x57>
/mnt/e/code/my_operating_system/os/service/fsystem.c:105 (discriminator 3)
        _fs_show_file_by_descriptor_number(i);
     64f:	66 83 ec 0c          	sub    $0xc,%esp
     653:	66 0f b7 c3          	movzwl %bx,%eax
     657:	66 50                	push   %eax
     659:	66 e8 ec fd ff ff    	calll  44b <_fs_show_file_by_descriptor_number>
/mnt/e/code/my_operating_system/os/service/fsystem.c:104 (discriminator 3)

void fs_show_root_file_table(){
    printf("%s   | %s | %s\n", "file name ", "file size", "cluster");
    printf("------------------------------------\n\r");
    int file_number = 9;// TODO:文件数量需要设置！
    for(int i = 0; i < file_number; i++){
     65f:	66 83 c3 01          	add    $0x1,%ebx
     663:	66 83 c4 10          	add    $0x10,%esp
/mnt/e/code/my_operating_system/os/service/fsystem.c:104 (discriminator 1)
     667:	66 83 fb 08          	cmp    $0x8,%ebx
     66b:	7e e2                	jle    64f <fs_show_root_file_table+0x3f>
/mnt/e/code/my_operating_system/os/service/fsystem.c:108
        _fs_show_file_by_descriptor_number(i);
    }
    return ;
}
     66d:	66 83 c4 08          	add    $0x8,%esp
     671:	66 5b                	pop    %ebx
     673:	66 c3                	retl   

00000675 <fs_show_file_by_name>:
fs_show_file_by_name():
/mnt/e/code/my_operating_system/os/service/fsystem.c:110

void fs_show_file_by_name(char * file_name){
     675:	66 83 ec 18          	sub    $0x18,%esp
/mnt/e/code/my_operating_system/os/service/fsystem.c:111
    int descriptor_index = _fs_find_descriptor_number_by_name(file_name);
     679:	67 66 ff 74 24 1c    	pushl  0x1c(%esp)
     67f:	66 e8 f2 fc ff ff    	calll  377 <_fs_find_descriptor_number_by_name>
/mnt/e/code/my_operating_system/os/service/fsystem.c:112
    _fs_show_file_by_descriptor_number(descriptor_index);
     685:	66 0f b7 c0          	movzwl %ax,%eax
     689:	67 66 89 04 24       	mov    %eax,(%esp)
     68e:	66 e8 b7 fd ff ff    	calll  44b <_fs_show_file_by_descriptor_number>
/mnt/e/code/my_operating_system/os/service/fsystem.c:114
    return ;
}
     694:	66 83 c4 1c          	add    $0x1c,%esp
     698:	66 c3                	retl   

0000069a <fs_show_floppy_infomation>:
fs_show_floppy_infomation():
/mnt/e/code/my_operating_system/os/service/fsystem.c:117


void fs_show_floppy_infomation(){
     69a:	66 f3 c3             	repz retl 

0000069d <schedule_process>:
schedule_process():
/mnt/e/code/my_operating_system/os/service/proc.c:10
#include "../include/global.h"
#include "../include/system_call.h"
#include "../include/fsystem.h"
#include "../include/proc.h"

void schedule_process(){
     69d:	66 83 ec 18          	sub    $0x18,%esp
/mnt/e/code/my_operating_system/os/service/proc.c:11
    printf("!");
     6a1:	66 68 58 19 00 00    	pushl  $0x1958
     6a7:	66 e8 a1 0c 00 00    	calll  134e <printf>
/mnt/e/code/my_operating_system/os/service/proc.c:12
    for (int i = 0; i < 10000000; i++);
     6ad:	66 83 c4 10          	add    $0x10,%esp
     6b1:	66 b8 00 00 00 00    	mov    $0x0,%eax
     6b7:	eb 04                	jmp    6bd <schedule_process+0x20>
/mnt/e/code/my_operating_system/os/service/proc.c:12 (discriminator 3)
     6b9:	66 83 c0 01          	add    $0x1,%eax
/mnt/e/code/my_operating_system/os/service/proc.c:12 (discriminator 1)
     6bd:	66 3d 7f 96 98 00    	cmp    $0x98967f,%eax
     6c3:	7e f4                	jle    6b9 <schedule_process+0x1c>
/mnt/e/code/my_operating_system/os/service/proc.c:13
    cur_process_index = (cur_process_index + 1) % CUR_PROCESS_NUM;
     6c5:	66 0f b7 0e 80 9f    	movzwl -0x6080,%ecx
     6cb:	66 83 c1 01          	add    $0x1,%ecx
     6cf:	66 ba 56 55 55 55    	mov    $0x55555556,%edx
     6d5:	66 89 c8             	mov    %ecx,%eax
     6d8:	66 f7 ea             	imul   %edx
     6db:	67 66 8d 04 52       	lea    (%edx,%edx,2),%eax
     6e0:	66 29 c1             	sub    %eax,%ecx
     6e3:	89 0e 80 9f          	mov    %cx,-0x6080
/mnt/e/code/my_operating_system/os/service/proc.c:14
    cur_process = &process_table[cur_process_index];
     6e7:	66 0f b7 d1          	movzwl %cx,%edx
     6eb:	66 89 d0             	mov    %edx,%eax
     6ee:	66 c1 e0 06          	shl    $0x6,%eax
     6f2:	67 66 8d 84 90 80 5b 	lea    0x5b80(%eax,%edx,4),%eax
     6f9:	00 00 
     6fb:	66 a3 84 9f          	mov    %eax,0x9f84
/mnt/e/code/my_operating_system/os/service/proc.c:15
}
     6ff:	66 83 c4 0c          	add    $0xc,%esp
     703:	66 c3                	retl   

00000705 <init_process>:
init_process():
/mnt/e/code/my_operating_system/os/service/proc.c:18


void init_process(int process_index, u16 segment){
     705:	66 53                	push   %ebx
     707:	67 66 8b 4c 24 08    	mov    0x8(%esp),%ecx
     70d:	67 66 8b 54 24 0c    	mov    0xc(%esp),%edx
/mnt/e/code/my_operating_system/os/service/proc.c:20
    PCB_t* this_process = &process_table[process_index];
    this_process->regs.ss = segment;
     713:	66 89 c8             	mov    %ecx,%eax
     716:	66 c1 e0 06          	shl    $0x6,%eax
     71a:	67 66 8d 1c 88       	lea    (%eax,%ecx,4),%ebx
     71f:	67 89 93 80 5b 00 00 	mov    %dx,0x5b80(%ebx)
/mnt/e/code/my_operating_system/os/service/proc.c:21
    this_process->regs.sp = 0x5000;
     726:	67 c7 83 82 5b 00 00 	movw   $0x5000,0x5b82(%ebx)
     72d:	00 50 
/mnt/e/code/my_operating_system/os/service/proc.c:22
    this_process->regs.ds = segment;
     72f:	67 89 93 84 5b 00 00 	mov    %dx,0x5b84(%ebx)
/mnt/e/code/my_operating_system/os/service/proc.c:23
    this_process->regs.es = segment;
     736:	67 89 93 86 5b 00 00 	mov    %dx,0x5b86(%ebx)
/mnt/e/code/my_operating_system/os/service/proc.c:24
    this_process->regs.edi = 0;
     73d:	67 66 c7 83 88 5b 00 	movl   $0x0,0x5b88(%ebx)
     744:	00 00 00 00 00 
/mnt/e/code/my_operating_system/os/service/proc.c:25
    this_process->regs.esi = 0;
     749:	67 66 c7 83 8c 5b 00 	movl   $0x0,0x5b8c(%ebx)
     750:	00 00 00 00 00 
/mnt/e/code/my_operating_system/os/service/proc.c:26
    this_process->regs.ebp = 0x5000;
     755:	67 66 c7 83 90 5b 00 	movl   $0x5000,0x5b90(%ebx)
     75c:	00 00 50 00 00 
/mnt/e/code/my_operating_system/os/service/proc.c:27
    this_process->regs.kernel_esp = 0;
     761:	67 66 c7 83 94 5b 00 	movl   $0x0,0x5b94(%ebx)
     768:	00 00 00 00 00 
/mnt/e/code/my_operating_system/os/service/proc.c:28
    this_process->regs.ebx = 0;
     76d:	67 66 c7 83 98 5b 00 	movl   $0x0,0x5b98(%ebx)
     774:	00 00 00 00 00 
/mnt/e/code/my_operating_system/os/service/proc.c:29
    this_process->regs.edx = 0;
     779:	67 66 c7 83 9c 5b 00 	movl   $0x0,0x5b9c(%ebx)
     780:	00 00 00 00 00 
/mnt/e/code/my_operating_system/os/service/proc.c:30
    this_process->regs.ecx = 0;
     785:	67 66 c7 83 a0 5b 00 	movl   $0x0,0x5ba0(%ebx)
     78c:	00 00 00 00 00 
/mnt/e/code/my_operating_system/os/service/proc.c:31
    this_process->regs.eax = 0;
     791:	67 66 c7 83 a4 5b 00 	movl   $0x0,0x5ba4(%ebx)
     798:	00 00 00 00 00 
/mnt/e/code/my_operating_system/os/service/proc.c:32
    this_process->regs.ip = 0x0000;
     79d:	67 c7 83 a8 5b 00 00 	movw   $0x0,0x5ba8(%ebx)
     7a4:	00 00 
/mnt/e/code/my_operating_system/os/service/proc.c:33
    this_process->regs.cs = segment;
     7a6:	67 89 93 aa 5b 00 00 	mov    %dx,0x5baa(%ebx)
/mnt/e/code/my_operating_system/os/service/proc.c:34
    this_process->regs.flags = 0x1202;
     7ad:	67 c7 83 ac 5b 00 00 	movw   $0x1202,0x5bac(%ebx)
     7b4:	02 12 
/mnt/e/code/my_operating_system/os/service/proc.c:35
    this_process->pid = process_index;
     7b6:	67 66 89 8b b0 5b 00 	mov    %ecx,0x5bb0(%ebx)
     7bd:	00 
/mnt/e/code/my_operating_system/os/service/proc.c:37
    // this_process->p_name = 0;TODO:实现strcpy函数再说。
}
     7be:	66 5b                	pop    %ebx
     7c0:	66 c3                	retl   

000007c2 <parser>:
parser():
/mnt/e/code/my_operating_system/os/service/tty.c:90
    }
    return ;
}


void parser(){
     7c2:	66 56                	push   %esi
     7c4:	66 53                	push   %ebx
     7c6:	66 83 ec 74          	sub    $0x74,%esp
/mnt/e/code/my_operating_system/os/service/tty.c:94
    char arguments[10][10];
    int input_start = 0;
    int input_end = 0;
    int arguments_num = 0;
     7ca:	66 be 00 00 00 00    	mov    $0x0,%esi
/mnt/e/code/my_operating_system/os/service/tty.c:93


void parser(){
    char arguments[10][10];
    int input_start = 0;
    int input_end = 0;
     7d0:	66 bb 00 00 00 00    	mov    $0x0,%ebx
/mnt/e/code/my_operating_system/os/service/tty.c:92
}


void parser(){
    char arguments[10][10];
    int input_start = 0;
     7d6:	66 ba 00 00 00 00    	mov    $0x0,%edx
/mnt/e/code/my_operating_system/os/service/tty.c:96
    int input_end = 0;
    int arguments_num = 0;
    // 使用空格作为分隔符，将输入缓冲区的内容分割成几个参数分别存进arguments数组中
    while (input_end <= command_line_cursor){
     7dc:	eb 63                	jmp    841 <loader_code_segment+0x41>
/mnt/e/code/my_operating_system/os/service/tty.c:97
        if(input_buf[input_end] == ' ' || input_buf[input_end] == '\0'){
     7de:	67 66 0f b6 83 a0 a1 	movzbl 0xa1a0(%ebx),%eax
     7e5:	00 00 
     7e7:	3c 20                	cmp    $0x20,%al
     7e9:	0f 94 c1             	sete   %cl
     7ec:	84 c0                	test   %al,%al
     7ee:	0f 94 c0             	sete   %al
     7f1:	08 c1                	or     %al,%cl
     7f3:	74 48                	je     83d <loader_code_segment+0x3d>
/mnt/e/code/my_operating_system/os/service/tty.c:98
            if (input_start == input_end){ // 如果并没有参数，那么继续
     7f5:	66 39 da             	cmp    %ebx,%edx
     7f8:	75 0a                	jne    804 <loader_code_segment+0x4>
/mnt/e/code/my_operating_system/os/service/tty.c:99
                input_start++;
     7fa:	66 83 c2 01          	add    $0x1,%edx
/mnt/e/code/my_operating_system/os/service/tty.c:100
                input_end++;
     7fe:	66 83 c3 01          	add    $0x1,%ebx
/mnt/e/code/my_operating_system/os/service/tty.c:101
                continue;
     802:	eb 3d                	jmp    841 <loader_code_segment+0x41>
/mnt/e/code/my_operating_system/os/service/tty.c:104
            }
            else {// 如果有参数，并且已经读到末尾了，那就复制到相应的区域
                strncpy(arguments[arguments_num], input_buf+input_start, input_end-input_start);
     804:	66 89 d9             	mov    %ebx,%ecx
     807:	66 29 d1             	sub    %edx,%ecx
     80a:	67 66 8d 04 b6       	lea    (%esi,%esi,4),%eax
     80f:	67 66 8d 44 44 0c    	lea    0xc(%esp,%eax,2),%eax
     815:	66 83 ec 04          	sub    $0x4,%esp
     819:	66 51                	push   %ecx
     81b:	66 81 c2 a0 a1 00 00 	add    $0xa1a0,%edx
     822:	66 52                	push   %edx
     824:	66 50                	push   %eax
     826:	66 e8 85 0f 00 00    	calll  17b1 <strncpy>
/mnt/e/code/my_operating_system/os/service/tty.c:105
                input_end++;
     82c:	66 83 c3 01          	add    $0x1,%ebx
/mnt/e/code/my_operating_system/os/service/tty.c:107
                input_start = input_end;
                arguments_num++;
     830:	66 83 c6 01          	add    $0x1,%esi
     834:	66 83 c4 10          	add    $0x10,%esp
/mnt/e/code/my_operating_system/os/service/tty.c:106
                continue;
            }
            else {// 如果有参数，并且已经读到末尾了，那就复制到相应的区域
                strncpy(arguments[arguments_num], input_buf+input_start, input_end-input_start);
                input_end++;
                input_start = input_end;
     838:	66 89 da             	mov    %ebx,%edx
     83b:	eb 04                	jmp    841 <loader_code_segment+0x41>
/mnt/e/code/my_operating_system/os/service/tty.c:111
                arguments_num++;
            }
        }
        else {// 有参数，还没有读到末尾
            input_end++;
     83d:	66 83 c3 01          	add    $0x1,%ebx
/mnt/e/code/my_operating_system/os/service/tty.c:96
    char arguments[10][10];
    int input_start = 0;
    int input_end = 0;
    int arguments_num = 0;
    // 使用空格作为分隔符，将输入缓冲区的内容分割成几个参数分别存进arguments数组中
    while (input_end <= command_line_cursor){
     841:	66 3b 1e 00 50       	cmp    0x5000,%ebx
     846:	7e 96                	jle    7de <parser+0x1c>
/mnt/e/code/my_operating_system/os/service/tty.c:118
        }
    }

    // 完成分词，开始进行解析。

    if(!strcmp(arguments[0],"run")){// 如果返回0，就是相等了
     848:	66 83 ec 08          	sub    $0x8,%esp
     84c:	66 68 5a 19 00 00    	pushl  $0x195a
     852:	67 66 8d 44 24 18    	lea    0x18(%esp),%eax
     858:	66 50                	push   %eax
     85a:	66 e8 8d 0f 00 00    	calll  17ed <strcmp>
     860:	66 83 c4 10          	add    $0x10,%esp
     864:	66 85 c0             	test   %eax,%eax
     867:	75 34                	jne    89d <loader_code_segment+0x9d>
/mnt/e/code/my_operating_system/os/service/tty.c:123
        // 运行一个用户程序。
        // 先从软盘中加载一个指定程序到内存处，然后开始执行。
        // 考虑维护一个空闲空间的指针，然后每加载一个程序，如果可行的话。
        void (**my_program)();
        *my_program = 0x4000;
     869:	66 bb 00 00 00 00    	mov    $0x0,%ebx
     86f:	67 66 c7 03 00 40 00 	movl   $0x4000,(%ebx)
     876:	00 
/mnt/e/code/my_operating_system/os/service/tty.c:124
        fs_load_by_name(arguments[1],0x1000,(u16)my_program);
     877:	66 83 ec 04          	sub    $0x4,%esp
     87b:	66 6a 00             	pushl  $0x0
     87e:	66 68 00 10 00 00    	pushl  $0x1000
     884:	67 66 8d 44 24 22    	lea    0x22(%esp),%eax
     88a:	66 50                	push   %eax
     88c:	66 e8 fe fc ff ff    	calll  590 <fs_load_by_name>
/mnt/e/code/my_operating_system/os/service/tty.c:125
        (*my_program)();
     892:	67 66 ff 13          	calll  *(%ebx)
     896:	66 83 c4 10          	add    $0x10,%esp
     89a:	e9 1b 01             	jmp    9b8 <loader_code_segment+0x1b8>
/mnt/e/code/my_operating_system/os/service/tty.c:127
    }
    else if(!strcmp(arguments[0],"ls") && arguments_num == 1){
     89d:	66 83 ec 08          	sub    $0x8,%esp
     8a1:	66 68 5e 19 00 00    	pushl  $0x195e
     8a7:	67 66 8d 44 24 18    	lea    0x18(%esp),%eax
     8ad:	66 50                	push   %eax
     8af:	66 e8 38 0f 00 00    	calll  17ed <strcmp>
     8b5:	66 83 c4 10          	add    $0x10,%esp
     8b9:	66 85 c0             	test   %eax,%eax
     8bc:	75 23                	jne    8e1 <loader_code_segment+0xe1>
/mnt/e/code/my_operating_system/os/service/tty.c:127 (discriminator 1)
     8be:	66 83 fe 01          	cmp    $0x1,%esi
     8c2:	75 1d                	jne    8e1 <loader_code_segment+0xe1>
/mnt/e/code/my_operating_system/os/service/tty.c:128
        printf("\n\n");
     8c4:	66 83 ec 0c          	sub    $0xc,%esp
     8c8:	66 68 61 19 00 00    	pushl  $0x1961
     8ce:	66 e8 7a 0a 00 00    	calll  134e <printf>
/mnt/e/code/my_operating_system/os/service/tty.c:129
        fs_show_root_file_table();
     8d4:	66 e8 36 fd ff ff    	calll  610 <fs_show_root_file_table>
     8da:	66 83 c4 10          	add    $0x10,%esp
     8de:	e9 d7 00             	jmp    9b8 <loader_code_segment+0x1b8>
/mnt/e/code/my_operating_system/os/service/tty.c:131
    }
    else if(!strcmp(arguments[0],"reboot") && arguments_num == 1){
     8e1:	66 83 ec 08          	sub    $0x8,%esp
     8e5:	66 68 64 19 00 00    	pushl  $0x1964
     8eb:	67 66 8d 44 24 18    	lea    0x18(%esp),%eax
     8f1:	66 50                	push   %eax
     8f3:	66 e8 f4 0e 00 00    	calll  17ed <strcmp>
     8f9:	66 83 c4 10          	add    $0x10,%esp
     8fd:	66 85 c0             	test   %eax,%eax
     900:	75 23                	jne    925 <loader_code_segment+0x125>
/mnt/e/code/my_operating_system/os/service/tty.c:131 (discriminator 1)
     902:	66 83 fe 01          	cmp    $0x1,%esi
     906:	75 1d                	jne    925 <loader_code_segment+0x125>
/mnt/e/code/my_operating_system/os/service/tty.c:132
        printf("\n\n");
     908:	66 83 ec 0c          	sub    $0xc,%esp
     90c:	66 68 61 19 00 00    	pushl  $0x1961
     912:	66 e8 36 0a 00 00    	calll  134e <printf>
/mnt/e/code/my_operating_system/os/service/tty.c:133
        reboot();
     918:	66 e8 65 0e 00 00    	calll  1783 <reboot>
/mnt/e/code/my_operating_system/os/service/tty.c:131
    }
    else if(!strcmp(arguments[0],"ls") && arguments_num == 1){
        printf("\n\n");
        fs_show_root_file_table();
    }
    else if(!strcmp(arguments[0],"reboot") && arguments_num == 1){
     91e:	66 83 c4 10          	add    $0x10,%esp
     922:	e9 93 00             	jmp    9b8 <loader_code_segment+0x1b8>
/mnt/e/code/my_operating_system/os/service/tty.c:135
        printf("\n\n");
        reboot();
    }
    else if(!strcmp(arguments[0],"help") && arguments_num == 1){
     925:	66 83 ec 08          	sub    $0x8,%esp
     929:	66 68 6b 19 00 00    	pushl  $0x196b
     92f:	67 66 8d 44 24 18    	lea    0x18(%esp),%eax
     935:	66 50                	push   %eax
     937:	66 e8 b0 0e 00 00    	calll  17ed <strcmp>
     93d:	66 83 c4 10          	add    $0x10,%esp
     941:	66 85 c0             	test   %eax,%eax
     944:	75 58                	jne    99e <loader_code_segment+0x19e>
/mnt/e/code/my_operating_system/os/service/tty.c:135 (discriminator 1)
     946:	66 83 fe 01          	cmp    $0x1,%esi
     94a:	75 52                	jne    99e <loader_code_segment+0x19e>
/mnt/e/code/my_operating_system/os/service/tty.c:136
        printf("\n\n");
     94c:	66 83 ec 0c          	sub    $0xc,%esp
     950:	66 68 61 19 00 00    	pushl  $0x1961
     956:	66 e8 f2 09 00 00    	calll  134e <printf>
/mnt/e/code/my_operating_system/os/service/tty.c:137
        printf("ls        : show the file in the root folder.\n");
     95c:	67 66 c7 04 24 48 22 	movl   $0x2248,(%esp)
     963:	00 00 
     965:	66 e8 e3 09 00 00    	calll  134e <printf>
/mnt/e/code/my_operating_system/os/service/tty.c:138
        printf("run [name]: run the file in the root folder.\n");
     96b:	67 66 c7 04 24 78 22 	movl   $0x2278,(%esp)
     972:	00 00 
     974:	66 e8 d4 09 00 00    	calll  134e <printf>
/mnt/e/code/my_operating_system/os/service/tty.c:139
        printf("help      : show the help message.\n");
     97a:	67 66 c7 04 24 a8 22 	movl   $0x22a8,(%esp)
     981:	00 00 
     983:	66 e8 c5 09 00 00    	calll  134e <printf>
/mnt/e/code/my_operating_system/os/service/tty.c:140
        printf("reboot    : reboot the machine.\n");
     989:	67 66 c7 04 24 cc 22 	movl   $0x22cc,(%esp)
     990:	00 00 
     992:	66 e8 b6 09 00 00    	calll  134e <printf>
     998:	66 83 c4 10          	add    $0x10,%esp
     99c:	eb 1a                	jmp    9b8 <loader_code_segment+0x1b8>
/mnt/e/code/my_operating_system/os/service/tty.c:143
    }
    else {
        printf("\n%s : command not found! \n", input_buf);
     99e:	66 83 ec 08          	sub    $0x8,%esp
     9a2:	66 68 a0 a1 00 00    	pushl  $0xa1a0
     9a8:	66 68 70 19 00 00    	pushl  $0x1970
     9ae:	66 e8 9a 09 00 00    	calll  134e <printf>
     9b4:	66 83 c4 10          	add    $0x10,%esp
/mnt/e/code/my_operating_system/os/service/tty.c:145
    }
    int current_cursor = get_cursor();
     9b8:	66 e8 b9 03 00 00    	calll  d77 <get_cursor>
     9be:	66 0f b7 c0          	movzwl %ax,%eax
/mnt/e/code/my_operating_system/os/service/tty.c:146
    command_line_row = (current_cursor / 80);
     9c2:	66 ba 67 66 66 66    	mov    $0x66666667,%edx
     9c8:	66 f7 ea             	imul   %edx
     9cb:	66 c1 fa 05          	sar    $0x5,%edx
     9cf:	66 89 16 04 40       	mov    %edx,0x4004
/mnt/e/code/my_operating_system/os/service/tty.c:149
    // printf("arguments: %d|%s|%s|",arguments_num, arguments[0],arguments[1]);
    return ;
}
     9d4:	66 83 c4 74          	add    $0x74,%esp
     9d8:	66 5b                	pop    %ebx
     9da:	66 5e                	pop    %esi
     9dc:	66 c3                	retl   

000009de <create_a_line>:
create_a_line():
/mnt/e/code/my_operating_system/os/service/tty.c:152

// 转移光标到命令行下一行,更新缓冲区，并且打印信息
void create_a_line(){
     9de:	66 83 ec 2c          	sub    $0x2c,%esp
/mnt/e/code/my_operating_system/os/service/tty.c:153
    char message[30] = "walker@walker-pc ~ $ \0";
     9e2:	66 a1 f0 22          	mov    0x22f0,%eax
     9e6:	67 66 89 44 24 02    	mov    %eax,0x2(%esp)
     9ec:	66 a1 f4 22          	mov    0x22f4,%eax
     9f0:	67 66 89 44 24 06    	mov    %eax,0x6(%esp)
     9f6:	66 a1 f8 22          	mov    0x22f8,%eax
     9fa:	67 66 89 44 24 0a    	mov    %eax,0xa(%esp)
     a00:	66 a1 fc 22          	mov    0x22fc,%eax
     a04:	67 66 89 44 24 0e    	mov    %eax,0xe(%esp)
     a0a:	66 a1 00 23          	mov    0x2300,%eax
     a0e:	67 66 89 44 24 12    	mov    %eax,0x12(%esp)
     a14:	66 0f b7 06 04 23    	movzwl 0x2304,%eax
     a1a:	67 89 44 24 16       	mov    %ax,0x16(%esp)
     a1f:	66 0f b6 06 06 23    	movzbl 0x2306,%eax
     a25:	67 88 44 24 18       	mov    %al,0x18(%esp)
     a2a:	67 66 c7 44 24 19 00 	movl   $0x0,0x19(%esp)
     a31:	00 00 00 
     a34:	67 c7 44 24 1d 00 00 	movw   $0x0,0x1d(%esp)
     a3b:	67 c6 44 24 1f 00    	movb   $0x0,0x1f(%esp)
/mnt/e/code/my_operating_system/os/service/tty.c:154
    for (int i = 0; i < MAX_BUF; i++){
     a41:	66 b8 00 00 00 00    	mov    $0x0,%eax
     a47:	eb 0c                	jmp    a55 <create_a_line+0x77>
/mnt/e/code/my_operating_system/os/service/tty.c:155 (discriminator 3)
        input_buf[i] = 0;
     a49:	67 c6 80 a0 a1 00 00 	movb   $0x0,0xa1a0(%eax)
     a50:	00 
/mnt/e/code/my_operating_system/os/service/tty.c:154 (discriminator 3)
}

// 转移光标到命令行下一行,更新缓冲区，并且打印信息
void create_a_line(){
    char message[30] = "walker@walker-pc ~ $ \0";
    for (int i = 0; i < MAX_BUF; i++){
     a51:	66 83 c0 01          	add    $0x1,%eax
/mnt/e/code/my_operating_system/os/service/tty.c:154 (discriminator 1)
     a55:	66 83 f8 63          	cmp    $0x63,%eax
     a59:	7e ee                	jle    a49 <create_a_line+0x6b>
/mnt/e/code/my_operating_system/os/service/tty.c:157
        input_buf[i] = 0;
    }
    message_length = strlen(message);
     a5b:	66 83 ec 0c          	sub    $0xc,%esp
     a5f:	67 66 8d 44 24 0e    	lea    0xe(%esp),%eax
     a65:	66 50                	push   %eax
     a67:	66 e8 28 0d 00 00    	calll  1795 <strlen>
     a6d:	66 a3 04 50          	mov    %eax,0x5004
/mnt/e/code/my_operating_system/os/service/tty.c:158
    command_line_row = command_line_row + (command_line_cursor + message_length)/80 + 1;
     a71:	66 03 06 00 50       	add    0x5000,%eax
     a76:	66 89 c1             	mov    %eax,%ecx
     a79:	66 ba 67 66 66 66    	mov    $0x66666667,%edx
     a7f:	66 f7 ea             	imul   %edx
     a82:	66 c1 fa 05          	sar    $0x5,%edx
     a86:	66 c1 f9 1f          	sar    $0x1f,%ecx
     a8a:	66 29 ca             	sub    %ecx,%edx
     a8d:	66 89 d0             	mov    %edx,%eax
     a90:	66 03 06 04 40       	add    0x4004,%eax
     a95:	66 83 c0 01          	add    $0x1,%eax
     a99:	66 a3 04 40          	mov    %eax,0x4004
/mnt/e/code/my_operating_system/os/service/tty.c:159
    while(command_line_row > 23){
     a9d:	66 83 c4 10          	add    $0x10,%esp
     aa1:	eb 0c                	jmp    aaf <create_a_line+0xd1>
/mnt/e/code/my_operating_system/os/service/tty.c:160
        scroll_screen();
     aa3:	66 e8 53 0c 00 00    	calll  16fc <scroll_screen>
/mnt/e/code/my_operating_system/os/service/tty.c:161
        command_line_row--;
     aa9:	66 83 2e 04 40 01    	subl   $0x1,0x4004
/mnt/e/code/my_operating_system/os/service/tty.c:159
    for (int i = 0; i < MAX_BUF; i++){
        input_buf[i] = 0;
    }
    message_length = strlen(message);
    command_line_row = command_line_row + (command_line_cursor + message_length)/80 + 1;
    while(command_line_row > 23){
     aaf:	66 a1 04 40          	mov    0x4004,%eax
     ab3:	66 83 f8 17          	cmp    $0x17,%eax
     ab7:	7f ea                	jg     aa3 <create_a_line+0xc5>
/mnt/e/code/my_operating_system/os/service/tty.c:163
        scroll_screen();
        command_line_row--;
    }
    command_line_cursor = 0;
     ab9:	66 c7 06 00 50 00 00 	movl   $0x0,0x5000
     ac0:	00 00 
/mnt/e/code/my_operating_system/os/service/tty.c:164
    set_cursor(command_line_row * 80);
     ac2:	66 83 ec 0c          	sub    $0xc,%esp
     ac6:	67 66 8d 04 80       	lea    (%eax,%eax,4),%eax
     acb:	66 c1 e0 04          	shl    $0x4,%eax
     acf:	66 0f b7 d0          	movzwl %ax,%edx
     ad3:	66 52                	push   %edx
     ad5:	66 e8 2a 02 00 00    	calll  d05 <set_cursor>
/mnt/e/code/my_operating_system/os/service/tty.c:166
    // printf("%d", command_line_row);
    printf("%s", message);
     adb:	66 83 c4 08          	add    $0x8,%esp
     adf:	67 66 8d 44 24 0a    	lea    0xa(%esp),%eax
     ae5:	66 50                	push   %eax
     ae7:	66 68 8b 19 00 00    	pushl  $0x198b
     aed:	66 e8 5b 08 00 00    	calll  134e <printf>
/mnt/e/code/my_operating_system/os/service/tty.c:167
}
     af3:	66 83 c4 3c          	add    $0x3c,%esp
     af7:	66 c3                	retl   

00000af9 <tty>:
tty():
/mnt/e/code/my_operating_system/os/service/tty.c:20
int message_length = 0;
int command_line_cursor = 0; // 光标在输入区的偏移量
char input_buf[MAX_BUF]; // 输入缓存区


void tty(){
     af9:	66 56                	push   %esi
     afb:	66 53                	push   %ebx
     afd:	66 83 ec 04          	sub    $0x4,%esp
/mnt/e/code/my_operating_system/os/service/tty.c:22
    int keyboard_flag = 0;
    new_line_flag = 1;
     b01:	66 c7 06 00 40 01 00 	movl   $0x1,0x4000
     b08:	00 00 
/mnt/e/code/my_operating_system/os/service/tty.c:23
    command_line_row = -1;
     b0a:	66 c7 06 04 40 ff ff 	movl   $0xffffffff,0x4004
     b11:	ff ff 
/mnt/e/code/my_operating_system/os/service/tty.c:24
    clean_screen();
     b13:	66 e8 c9 0b 00 00    	calll  16e2 <clean_screen>
/mnt/e/code/my_operating_system/os/service/tty.c:25
    set_cursor(1974);
     b19:	66 83 ec 0c          	sub    $0xc,%esp
     b1d:	66 68 b6 07 00 00    	pushl  $0x7b6
     b23:	66 e8 dc 01 00 00    	calll  d05 <set_cursor>
/mnt/e/code/my_operating_system/os/service/tty.c:26
    set_cursor(0);
     b29:	67 66 c7 04 24 00 00 	movl   $0x0,(%esp)
     b30:	00 00 
     b32:	66 e8 cd 01 00 00    	calll  d05 <set_cursor>
/mnt/e/code/my_operating_system/os/service/tty.c:27
    print_my_name();
     b38:	66 e8 1b 0c 00 00    	calll  1759 <print_my_name>
     b3e:	66 83 c4 10          	add    $0x10,%esp
/mnt/e/code/my_operating_system/os/service/tty.c:30
    while (1){
        // 使用缓冲区数据更新
        if (new_line_flag){
     b42:	66 83 3e 00 40 00    	cmpl   $0x0,0x4000
     b48:	74 0f                	je     b59 <tty+0x60>
/mnt/e/code/my_operating_system/os/service/tty.c:31
            create_a_line();
     b4a:	66 e8 8e fe ff ff    	calll  9de <create_a_line>
/mnt/e/code/my_operating_system/os/service/tty.c:32
            new_line_flag = 0;
     b50:	66 c7 06 00 40 00 00 	movl   $0x0,0x4000
     b57:	00 00 
/mnt/e/code/my_operating_system/os/service/tty.c:35
        }

        if(command_line_row == 23 && message_length + command_line_cursor > 80){
     b59:	66 83 3e 04 40 17    	cmpl   $0x17,0x4004
     b5f:	75 2f                	jne    b90 <tty+0x97>
/mnt/e/code/my_operating_system/os/service/tty.c:35 (discriminator 1)
     b61:	66 a1 00 50          	mov    0x5000,%eax
     b65:	66 03 06 04 50       	add    0x5004,%eax
     b6a:	66 83 f8 50          	cmp    $0x50,%eax
     b6e:	7e 20                	jle    b90 <tty+0x97>
/mnt/e/code/my_operating_system/os/service/tty.c:36
            scroll_screen();
     b70:	66 e8 86 0b 00 00    	calll  16fc <scroll_screen>
/mnt/e/code/my_operating_system/os/service/tty.c:37
            command_line_row--;
     b76:	66 83 2e 04 40 01    	subl   $0x1,0x4004
/mnt/e/code/my_operating_system/os/service/tty.c:38
            set_cursor(1840);
     b7c:	66 83 ec 0c          	sub    $0xc,%esp
     b80:	66 68 30 07 00 00    	pushl  $0x730
     b86:	66 e8 79 01 00 00    	calll  d05 <set_cursor>
     b8c:	66 83 c4 10          	add    $0x10,%esp
/mnt/e/code/my_operating_system/os/service/tty.c:40
        }
        putc(' ');// 用来删除光标处的文字，与输入退格的时候光标-1配合使用
     b90:	66 83 ec 0c          	sub    $0xc,%esp
     b94:	66 6a 20             	pushl  $0x20
     b97:	66 e8 36 02 00 00    	calll  dd3 <putc>
/mnt/e/code/my_operating_system/os/service/tty.c:43

        // command_line_row = get_cursor() / 80;
        set_cursor(80*command_line_row + message_length);
     b9d:	66 8b 16 04 40       	mov    0x4004,%edx
     ba2:	67 66 8d 14 92       	lea    (%edx,%edx,4),%edx
     ba7:	66 89 d0             	mov    %edx,%eax
     baa:	66 c1 e0 04          	shl    $0x4,%eax
     bae:	03 06 04 50          	add    0x5004,%ax
     bb2:	66 0f b7 c0          	movzwl %ax,%eax
     bb6:	67 66 89 04 24       	mov    %eax,(%esp)
     bbb:	66 e8 44 01 00 00    	calll  d05 <set_cursor>
/mnt/e/code/my_operating_system/os/service/tty.c:44
        puts(input_buf, command_line_cursor);
     bc1:	66 83 c4 08          	add    $0x8,%esp
     bc5:	66 ff 36 00 50       	pushl  0x5000
     bca:	66 68 a0 a1 00 00    	pushl  $0xa1a0
     bd0:	66 e8 f2 03 00 00    	calll  fc8 <puts>
/mnt/e/code/my_operating_system/os/service/tty.c:47

        // 更新完了 检测键盘
        keyboard_flag = check_keyboard();
     bd6:	66 e8 f0 0a 00 00    	calll  16cc <check_keyboard>
/mnt/e/code/my_operating_system/os/service/tty.c:50

        // 如果返回1，则有输入，处理输入信息，否则继续循环。
        if (keyboard_flag){
     bdc:	66 83 c4 10          	add    $0x10,%esp
     be0:	85 c0                	test   %ax,%ax
     be2:	0f 84 5c ff          	je     b42 <tty+0x49>
/mnt/e/code/my_operating_system/os/service/tty.c:52
            // 处理键盘事件
            u16 keyboard_code =  get_keyboard();
     be6:	66 e8 f0 0a 00 00    	calll  16dc <get_keyboard>
/mnt/e/code/my_operating_system/os/service/tty.c:53
            u8 ascii_code = keyboard_code;
     bec:	66 89 c3             	mov    %eax,%ebx
/mnt/e/code/my_operating_system/os/service/tty.c:55
            u8 scan_code = keyboard_code >> 8;
            if (isprint(ascii_code)){
     bef:	66 83 ec 0c          	sub    $0xc,%esp
     bf3:	66 0f b6 c0          	movzbl %al,%eax
     bf7:	66 50                	push   %eax
     bf9:	66 e8 aa 08 00 00    	calll  14a9 <isprint>
     bff:	66 83 c4 10          	add    $0x10,%esp
     c03:	66 85 c0             	test   %eax,%eax
     c06:	74 20                	je     c28 <tty+0x12f>
/mnt/e/code/my_operating_system/os/service/tty.c:56
                if (command_line_cursor <= MAX_BUF){
     c08:	66 a1 00 50          	mov    0x5000,%eax
     c0c:	66 83 f8 64          	cmp    $0x64,%eax
     c10:	0f 8f 2e ff          	jg     b42 <tty+0x49>
/mnt/e/code/my_operating_system/os/service/tty.c:57
                    input_buf[command_line_cursor++] = ascii_code;
     c14:	67 66 8d 50 01       	lea    0x1(%eax),%edx
     c19:	66 89 16 00 50       	mov    %edx,0x5000
     c1e:	67 88 98 a0 a1 00 00 	mov    %bl,0xa1a0(%eax)
     c25:	e9 1a ff             	jmp    b42 <tty+0x49>
/mnt/e/code/my_operating_system/os/service/tty.c:60
                }
            }
            else if (ascii_code == 13){
     c28:	80 fb 0d             	cmp    $0xd,%bl
     c2b:	75 1e                	jne    c4b <tty+0x152>
/mnt/e/code/my_operating_system/os/service/tty.c:61
                new_line_flag = 1;
     c2d:	66 c7 06 00 40 01 00 	movl   $0x1,0x4000
     c34:	00 00 
/mnt/e/code/my_operating_system/os/service/tty.c:62
                input_buf[command_line_cursor] = '\0';
     c36:	66 a1 00 50          	mov    0x5000,%eax
     c3a:	67 c6 80 a0 a1 00 00 	movb   $0x0,0xa1a0(%eax)
     c41:	00 
/mnt/e/code/my_operating_system/os/service/tty.c:63
                parser();
     c42:	66 e8 7a fb ff ff    	calll  7c2 <parser>
     c48:	e9 f7 fe             	jmp    b42 <tty+0x49>
/mnt/e/code/my_operating_system/os/service/tty.c:65
            }
            else if (ascii_code == 8){
     c4b:	80 fb 08             	cmp    $0x8,%bl
     c4e:	75 3e                	jne    c8e <tty+0x195>
/mnt/e/code/my_operating_system/os/service/tty.c:66
                if(command_line_cursor){
     c50:	66 a1 00 50          	mov    0x5000,%eax
     c54:	66 85 c0             	test   %eax,%eax
     c57:	0f 84 e7 fe          	je     b42 <tty+0x49>
/mnt/e/code/my_operating_system/os/service/tty.c:67
                    input_buf[--command_line_cursor] = 0;
     c5b:	67 66 8d 50 ff       	lea    -0x1(%eax),%edx
     c60:	66 89 16 00 50       	mov    %edx,0x5000
     c65:	67 c6 80 9f a1 00 00 	movb   $0x0,0xa19f(%eax)
     c6c:	00 
/mnt/e/code/my_operating_system/os/service/tty.c:69
                    // 将光标设置为前一个位置，方便删除
                    int cur_cursor = get_cursor();
     c6d:	66 e8 04 01 00 00    	calll  d77 <get_cursor>
/mnt/e/code/my_operating_system/os/service/tty.c:70
                    set_cursor(cur_cursor-1);
     c73:	66 83 ec 0c          	sub    $0xc,%esp
     c77:	66 83 e8 01          	sub    $0x1,%eax
     c7b:	66 0f b7 c0          	movzwl %ax,%eax
     c7f:	66 50                	push   %eax
     c81:	66 e8 7e 00 00 00    	calll  d05 <set_cursor>
     c87:	66 83 c4 10          	add    $0x10,%esp
     c8b:	e9 b4 fe             	jmp    b42 <tty+0x49>
/mnt/e/code/my_operating_system/os/service/tty.c:73
                }
            }
            else if (ascii_code == 27){
     c8e:	80 fb 1b             	cmp    $0x1b,%bl
     c91:	0f 85 ad fe          	jne    b42 <tty+0x49>
/mnt/e/code/my_operating_system/os/service/tty.c:74
                __asm__("mov $0x4c00, %ax");
     c95:	b8 00 4c             	mov    $0x4c00,%ax
/mnt/e/code/my_operating_system/os/service/tty.c:75
                __asm__("int $0x40");
     c98:	cd 40                	int    $0x40
     c9a:	e9 a5 fe             	jmp    b42 <tty+0x49>

00000c9d <tty_scroll_screen>:
tty_scroll_screen():
/mnt/e/code/my_operating_system/os/service/tty.c:170
    // printf("%d", command_line_row);
    printf("%s", message);
}


void tty_scroll_screen(){
     c9d:	66 83 ec 0c          	sub    $0xc,%esp
/mnt/e/code/my_operating_system/os/service/tty.c:171
    if (get_cursor()/80 > 24){
     ca1:	66 e8 d0 00 00 00    	calll  d77 <get_cursor>
     ca7:	3d cf 07             	cmp    $0x7cf,%ax
     caa:	76 0c                	jbe    cb8 <tty_scroll_screen+0x1b>
/mnt/e/code/my_operating_system/os/service/tty.c:172
        scroll_screen();
     cac:	66 e8 4a 0a 00 00    	calll  16fc <scroll_screen>
/mnt/e/code/my_operating_system/os/service/tty.c:173
        command_line_row--;
     cb2:	66 83 2e 04 40 01    	subl   $0x1,0x4004
/mnt/e/code/my_operating_system/os/service/tty.c:176
    }
    return ;
     cb8:	66 83 c4 0c          	add    $0xc,%esp
     cbc:	66 c3                	retl   

00000cbe <_put_char>:
_put_char():
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:5
#include "../include/basic.h"
#include "../include/type.h"
#include "../include/string.h"

void _put_char(char c, u16 cursor_index){
     cbe:	66 53                	push   %ebx
     cc0:	66 83 ec 10          	sub    $0x10,%esp
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:7
    int _address = 0xb8000;
    int _offset = cursor_index * 2;
     cc4:	67 66 0f b7 5c 24 1c 	movzwl 0x1c(%esp),%ebx
     ccb:	66 01 db             	add    %ebx,%ebx
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:8
    write_memory_byte(_address+_offset, c);
     cce:	67 66 8d 83 00 80 0b 	lea    0xb8000(%ebx),%eax
     cd5:	00 
     cd6:	67 66 0f b6 54 24 18 	movzbl 0x18(%esp),%edx
     cdd:	66 52                	push   %edx
     cdf:	66 50                	push   %eax
     ce1:	66 e8 95 09 00 00    	calll  167c <write_memory_byte>
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:9
    write_memory_byte(_address+_offset+1, 0x1f);
     ce7:	66 81 c3 01 80 0b 00 	add    $0xb8001,%ebx
     cee:	66 83 c4 08          	add    $0x8,%esp
     cf2:	66 6a 1f             	pushl  $0x1f
     cf5:	66 53                	push   %ebx
     cf7:	66 e8 7f 09 00 00    	calll  167c <write_memory_byte>
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:11
    return ;
}
     cfd:	66 83 c4 18          	add    $0x18,%esp
     d01:	66 5b                	pop    %ebx
     d03:	66 c3                	retl   

00000d05 <set_cursor>:
set_cursor():
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:13

void set_cursor(u16 cursor_index){
     d05:	66 56                	push   %esi
     d07:	66 53                	push   %ebx
     d09:	66 83 ec 0c          	sub    $0xc,%esp
     d0d:	67 66 8b 5c 24 18    	mov    0x18(%esp),%ebx
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:16
    // short cursor_index = 80 * row + column;     // 计算光标寄存器的值
    u8 low_eight = cursor_index; // 取低八位，高位被截断
    u8 high_eight = cursor_index >> 8; // 取高八位
     d13:	66 89 d8             	mov    %ebx,%eax
     d16:	c1 e8 08             	shr    $0x8,%ax
     d19:	66 89 c6             	mov    %eax,%esi
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:17
    write_port_byte(0x3d4,0x0e);// 指定索引寄存器为光标寄存器的高八位
     d1c:	66 6a 0e             	pushl  $0xe
     d1f:	66 68 d4 03 00 00    	pushl  $0x3d4
     d25:	66 e8 05 09 00 00    	calll  1630 <write_port_byte>
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:18
    write_port_byte(0x3d5, high_eight);// 将光标索引高八位写入端口
     d2b:	66 83 c4 08          	add    $0x8,%esp
     d2f:	66 89 f0             	mov    %esi,%eax
     d32:	66 0f b6 f0          	movzbl %al,%esi
     d36:	66 56                	push   %esi
     d38:	66 68 d5 03 00 00    	pushl  $0x3d5
     d3e:	66 e8 ec 08 00 00    	calll  1630 <write_port_byte>
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:19
    write_port_byte(0x3d4,0x0f);// 指定索引寄存器为光标寄存器的低八位
     d44:	66 83 c4 08          	add    $0x8,%esp
     d48:	66 6a 0f             	pushl  $0xf
     d4b:	66 68 d4 03 00 00    	pushl  $0x3d4
     d51:	66 e8 d9 08 00 00    	calll  1630 <write_port_byte>
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:20
    write_port_byte(0x3d5, low_eight);// 将光标索引低八位写入端口
     d57:	66 83 c4 08          	add    $0x8,%esp
     d5b:	66 0f b6 db          	movzbl %bl,%ebx
     d5f:	66 53                	push   %ebx
     d61:	66 68 d5 03 00 00    	pushl  $0x3d5
     d67:	66 e8 c3 08 00 00    	calll  1630 <write_port_byte>
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:22
    return ;
}
     d6d:	66 83 c4 14          	add    $0x14,%esp
     d71:	66 5b                	pop    %ebx
     d73:	66 5e                	pop    %esi
     d75:	66 c3                	retl   

00000d77 <get_cursor>:
get_cursor():
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:24

u16 get_cursor(){
     d77:	66 53                	push   %ebx
     d79:	66 83 ec 10          	sub    $0x10,%esp
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:27
    u8 low_eight = 0, high_eight = 0;
    u16 cursor_index = 0;
    write_port_byte(0x3d4,0x0e);// 指定索引寄存器为光标寄存器的高八位
     d7d:	66 6a 0e             	pushl  $0xe
     d80:	66 68 d4 03 00 00    	pushl  $0x3d4
     d86:	66 e8 a4 08 00 00    	calll  1630 <write_port_byte>
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:28
    high_eight = read_port_byte(0x3d5);// 将光标索引高八位写入端口
     d8c:	67 66 c7 04 24 d5 03 	movl   $0x3d5,(%esp)
     d93:	00 00 
     d95:	66 e8 bd 08 00 00    	calll  1658 <read_port_byte>
     d9b:	66 89 c3             	mov    %eax,%ebx
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:29
    write_port_byte(0x3d4,0x0f);// 指定索引寄存器为光标寄存器的低八位
     d9e:	66 83 c4 08          	add    $0x8,%esp
     da2:	66 6a 0f             	pushl  $0xf
     da5:	66 68 d4 03 00 00    	pushl  $0x3d4
     dab:	66 e8 7f 08 00 00    	calll  1630 <write_port_byte>
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:30
    low_eight = read_port_byte(0x3d5);// 将光标索引低八位写入端口
     db1:	67 66 c7 04 24 d5 03 	movl   $0x3d5,(%esp)
     db8:	00 00 
     dba:	66 e8 98 08 00 00    	calll  1658 <read_port_byte>
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:32
    cursor_index = high_eight;
    cursor_index = (cursor_index << 8) + low_eight;
     dc0:	66 c1 e3 08          	shl    $0x8,%ebx
     dc4:	66 0f b6 c0          	movzbl %al,%eax
     dc8:	66 01 d8             	add    %ebx,%eax
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:34
    return cursor_index;
}
     dcb:	66 83 c4 18          	add    $0x18,%esp
     dcf:	66 5b                	pop    %ebx
     dd1:	66 c3                	retl   

00000dd3 <putc>:
putc():
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:36

void putc(char c){
     dd3:	66 57                	push   %edi
     dd5:	66 56                	push   %esi
     dd7:	66 53                	push   %ebx
     dd9:	67 66 8b 7c 24 10    	mov    0x10(%esp),%edi
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:37
    u16 cursor_index = get_cursor();
     ddf:	66 e8 92 ff ff ff    	calll  d77 <get_cursor>
     de5:	66 89 c6             	mov    %eax,%esi
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:38
    u16 row = cursor_index / 80;
     de8:	66 0f b7 d8          	movzwl %ax,%ebx
     dec:	66 69 db cd cc 00 00 	imul   $0xcccd,%ebx,%ebx
     df3:	66 c1 eb 10          	shr    $0x10,%ebx
     df7:	c1 eb 06             	shr    $0x6,%bx
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:40
    u16 col = cursor_index % 80;
    if (cursor_index >= 1920){
     dfa:	3d 7f 07             	cmp    $0x77f,%ax
     dfd:	76 0c                	jbe    e0b <putc+0x38>
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:41
        scroll_screen();
     dff:	66 e8 f7 08 00 00    	calll  16fc <scroll_screen>
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:42
        cursor_index = 1840;
     e05:	66 be 30 07 00 00    	mov    $0x730,%esi
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:44
    }
    switch (c) {
     e0b:	66 89 f8             	mov    %edi,%eax
     e0e:	3c 0a                	cmp    $0xa,%al
     e10:	74 06                	je     e18 <putc+0x45>
     e12:	3c 0d                	cmp    $0xd,%al
     e14:	74 25                	je     e3b <putc+0x68>
     e16:	eb 45                	jmp    e5d <putc+0x8a>
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:46
        case '\n':
            set_cursor((row+1)*80); // 回车，移到下一行
     e18:	66 83 ec 0c          	sub    $0xc,%esp
     e1c:	67 66 8d 5c 9b 05    	lea    0x5(%ebx,%ebx,4),%ebx
     e22:	66 89 d8             	mov    %ebx,%eax
     e25:	66 c1 e0 04          	shl    $0x4,%eax
     e29:	66 0f b7 c0          	movzwl %ax,%eax
     e2d:	66 50                	push   %eax
     e2f:	66 e8 d0 fe ff ff    	calll  d05 <set_cursor>
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:47
            break;
     e35:	66 83 c4 10          	add    $0x10,%esp
     e39:	eb 52                	jmp    e8d <putc+0xba>
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:49
        case '\r':
            set_cursor(row*80);    // 移到本行开头处
     e3b:	66 83 ec 0c          	sub    $0xc,%esp
     e3f:	67 66 8d 1c 9b       	lea    (%ebx,%ebx,4),%ebx
     e44:	66 89 d8             	mov    %ebx,%eax
     e47:	66 c1 e0 04          	shl    $0x4,%eax
     e4b:	66 0f b7 c0          	movzwl %ax,%eax
     e4f:	66 50                	push   %eax
     e51:	66 e8 ae fe ff ff    	calll  d05 <set_cursor>
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:50
            break;
     e57:	66 83 c4 10          	add    $0x10,%esp
     e5b:	eb 30                	jmp    e8d <putc+0xba>
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:52
        default:
            _put_char(c, cursor_index);
     e5d:	66 83 ec 08          	sub    $0x8,%esp
     e61:	66 0f b7 c6          	movzwl %si,%eax
     e65:	66 50                	push   %eax
     e67:	66 89 f8             	mov    %edi,%eax
     e6a:	66 0f be f8          	movsbl %al,%edi
     e6e:	66 57                	push   %edi
     e70:	66 e8 48 fe ff ff    	calll  cbe <_put_char>
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:53
            set_cursor(cursor_index+1);
     e76:	66 83 c6 01          	add    $0x1,%esi
     e7a:	66 0f b7 f6          	movzwl %si,%esi
     e7e:	67 66 89 34 24       	mov    %esi,(%esp)
     e83:	66 e8 7c fe ff ff    	calll  d05 <set_cursor>
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:54
            break;
     e89:	66 83 c4 10          	add    $0x10,%esp
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:57
    }
    return ;
}
     e8d:	66 5b                	pop    %ebx
     e8f:	66 5e                	pop    %esi
     e91:	66 5f                	pop    %edi
     e93:	66 c3                	retl   

00000e95 <_putc>:
_putc():
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:59

void _putc(char c){
     e95:	66 56                	push   %esi
     e97:	66 53                	push   %ebx
     e99:	66 83 ec 04          	sub    $0x4,%esp
     e9d:	67 66 8b 5c 24 10    	mov    0x10(%esp),%ebx
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:60
    u16 cursor_index = get_cursor();
     ea3:	66 e8 ce fe ff ff    	calll  d77 <get_cursor>
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:61
    u16 row = cursor_index / 80;
     ea9:	66 0f b7 d0          	movzwl %ax,%edx
     ead:	66 69 d2 cd cc 00 00 	imul   $0xcccd,%edx,%edx
     eb4:	66 c1 ea 10          	shr    $0x10,%edx
     eb8:	c1 ea 06             	shr    $0x6,%dx
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:62
    u16 col = cursor_index % 80;
     ebb:	67 66 8d 34 92       	lea    (%edx,%edx,4),%esi
     ec0:	66 c1 e6 04          	shl    $0x4,%esi
     ec4:	66 89 f1             	mov    %esi,%ecx
     ec7:	66 89 c6             	mov    %eax,%esi
     eca:	66 29 ce             	sub    %ecx,%esi
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:63
    switch (c) {
     ecd:	80 fb 0a             	cmp    $0xa,%bl
     ed0:	74 07                	je     ed9 <_putc+0x44>
     ed2:	80 fb 0d             	cmp    $0xd,%bl
     ed5:	74 2b                	je     f02 <_putc+0x6d>
     ed7:	eb 4b                	jmp    f24 <_putc+0x8f>
     ed9:	66 89 f1             	mov    %esi,%ecx
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:65
        case '\n':
            set_cursor((row+1)*80+col); // 回车，移到下一行
     edc:	66 83 ec 0c          	sub    $0xc,%esp
     ee0:	67 66 8d 54 92 05    	lea    0x5(%edx,%edx,4),%edx
     ee6:	66 89 d0             	mov    %edx,%eax
     ee9:	66 c1 e0 04          	shl    $0x4,%eax
     eed:	66 01 c1             	add    %eax,%ecx
     ef0:	66 0f b7 c9          	movzwl %cx,%ecx
     ef4:	66 51                	push   %ecx
     ef6:	66 e8 09 fe ff ff    	calll  d05 <set_cursor>
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:66
            break;
     efc:	66 83 c4 10          	add    $0x10,%esp
     f00:	eb 3c                	jmp    f3e <_putc+0xa9>
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:68
        case '\r':
            set_cursor(row*80);    // 移到本行开头处
     f02:	66 83 ec 0c          	sub    $0xc,%esp
     f06:	67 66 8d 14 92       	lea    (%edx,%edx,4),%edx
     f0b:	66 89 d0             	mov    %edx,%eax
     f0e:	66 c1 e0 04          	shl    $0x4,%eax
     f12:	66 0f b7 c0          	movzwl %ax,%eax
     f16:	66 50                	push   %eax
     f18:	66 e8 e7 fd ff ff    	calll  d05 <set_cursor>
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:69
            break;
     f1e:	66 83 c4 10          	add    $0x10,%esp
     f22:	eb 1a                	jmp    f3e <_putc+0xa9>
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:71
        default:
            _put_char(c, cursor_index);
     f24:	66 83 ec 08          	sub    $0x8,%esp
     f28:	66 0f b7 c0          	movzwl %ax,%eax
     f2c:	66 50                	push   %eax
     f2e:	66 0f be db          	movsbl %bl,%ebx
     f32:	66 53                	push   %ebx
     f34:	66 e8 84 fd ff ff    	calll  cbe <_put_char>
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:73
            // set_cursor(cursor_index+1);
            break;
     f3a:	66 83 c4 10          	add    $0x10,%esp
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:76
    }
    return ;
}
     f3e:	66 83 c4 04          	add    $0x4,%esp
     f42:	66 5b                	pop    %ebx
     f44:	66 5e                	pop    %esi
     f46:	66 c3                	retl   

00000f48 <puti>:
puti():
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:78

void puti(u32 n){
     f48:	66 56                	push   %esi
     f4a:	66 53                	push   %ebx
     f4c:	66 83 ec 44          	sub    $0x44,%esp
     f50:	67 66 8b 4c 24 50    	mov    0x50(%esp),%ecx
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:79
    int len = 0;
     f56:	66 bb 00 00 00 00    	mov    $0x0,%ebx
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:81
    int num[INT_LENGTH];  // 临时存放各位数，从低位放到高位，之后倒序输出即可
    while (n != 0){
     f5c:	eb 2d                	jmp    f8b <puti+0x43>
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:82
        num[len] = n % 10;
     f5e:	66 ba cd cc cc cc    	mov    $0xcccccccd,%edx
     f64:	66 89 c8             	mov    %ecx,%eax
     f67:	66 f7 e2             	mul    %edx
     f6a:	66 c1 ea 03          	shr    $0x3,%edx
     f6e:	66 89 d6             	mov    %edx,%esi
     f71:	67 66 8d 14 92       	lea    (%edx,%edx,4),%edx
     f76:	67 66 8d 04 12       	lea    (%edx,%edx,1),%eax
     f7b:	66 29 c1             	sub    %eax,%ecx
     f7e:	67 66 89 4c 9c 04    	mov    %ecx,0x4(%esp,%ebx,4)
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:83
        n = n / 10;
     f84:	66 89 f1             	mov    %esi,%ecx
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:84
        len++;
     f87:	66 83 c3 01          	add    $0x1,%ebx
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:81
}

void puti(u32 n){
    int len = 0;
    int num[INT_LENGTH];  // 临时存放各位数，从低位放到高位，之后倒序输出即可
    while (n != 0){
     f8b:	66 85 c9             	test   %ecx,%ecx
     f8e:	75 ce                	jne    f5e <puti+0x16>
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:86
        num[len] = n % 10;
        n = n / 10;
        len++;
    }
    for (int i = len-1; i >= 0; i--){
     f90:	66 83 eb 01          	sub    $0x1,%ebx
     f94:	eb 23                	jmp    fb9 <puti+0x71>
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:87 (discriminator 3)
        putc(num[i]+'0');
     f96:	66 83 ec 0c          	sub    $0xc,%esp
     f9a:	67 66 0f b6 44 9c 10 	movzbl 0x10(%esp,%ebx,4),%eax
     fa1:	66 83 c0 30          	add    $0x30,%eax
     fa5:	66 0f be c0          	movsbl %al,%eax
     fa9:	66 50                	push   %eax
     fab:	66 e8 22 fe ff ff    	calll  dd3 <putc>
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:86 (discriminator 3)
    while (n != 0){
        num[len] = n % 10;
        n = n / 10;
        len++;
    }
    for (int i = len-1; i >= 0; i--){
     fb1:	66 83 eb 01          	sub    $0x1,%ebx
     fb5:	66 83 c4 10          	add    $0x10,%esp
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:86 (discriminator 1)
     fb9:	66 85 db             	test   %ebx,%ebx
     fbc:	79 d8                	jns    f96 <puti+0x4e>
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:90
        putc(num[i]+'0');
    }
    return ;
}
     fbe:	66 83 c4 44          	add    $0x44,%esp
     fc2:	66 5b                	pop    %ebx
     fc4:	66 5e                	pop    %esi
     fc6:	66 c3                	retl   

00000fc8 <puts>:
puts():
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:92

void puts(char * str, int size){
     fc8:	66 57                	push   %edi
     fca:	66 56                	push   %esi
     fcc:	66 53                	push   %ebx
     fce:	67 66 8b 7c 24 10    	mov    0x10(%esp),%edi
     fd4:	67 66 8b 74 24 14    	mov    0x14(%esp),%esi
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:93
    int i = 0;
     fda:	66 bb 00 00 00 00    	mov    $0x0,%ebx
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:94
    while (i < size){
     fe0:	eb 1a                	jmp    ffc <puts+0x34>
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:95
        putc(str[i]);
     fe2:	66 83 ec 0c          	sub    $0xc,%esp
     fe6:	67 66 0f be 04 1f    	movsbl (%edi,%ebx,1),%eax
     fec:	66 50                	push   %eax
     fee:	66 e8 df fd ff ff    	calll  dd3 <putc>
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:96
        i++;
     ff4:	66 83 c3 01          	add    $0x1,%ebx
     ff8:	66 83 c4 10          	add    $0x10,%esp
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:94
    return ;
}

void puts(char * str, int size){
    int i = 0;
    while (i < size){
     ffc:	66 39 f3             	cmp    %esi,%ebx
     fff:	7c e1                	jl     fe2 <puts+0x1a>
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:99
        putc(str[i]);
        i++;
    }
    return ;
}
    1001:	66 5b                	pop    %ebx
    1003:	66 5e                	pop    %esi
    1005:	66 5f                	pop    %edi
    1007:	66 c3                	retl   

00001009 <sprintf>:
sprintf():
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:103



void sprintf(char * dest , char * format, ...){
    1009:	66 55                	push   %ebp
    100b:	66 57                	push   %edi
    100d:	66 56                	push   %esi
    100f:	66 53                	push   %ebx
    1011:	66 83 ec 5c          	sub    $0x5c,%esp
    1015:	67 66 8b 6c 24 70    	mov    0x70(%esp),%ebp
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:106
    int arg_num = 0;
    int src_index = 0;   // 源字符串索引，总是指向未读的一位
    int des_index = 0;   // 目标字符串索引，总是指向未写的一位。
    101b:	66 bb 00 00 00 00    	mov    $0x0,%ebx
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:105



void sprintf(char * dest , char * format, ...){
    int arg_num = 0;
    int src_index = 0;   // 源字符串索引，总是指向未读的一位
    1021:	66 bf 00 00 00 00    	mov    $0x0,%edi
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:104
}



void sprintf(char * dest , char * format, ...){
    int arg_num = 0;
    1027:	66 ba 00 00 00 00    	mov    $0x0,%edx
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:108
    int src_index = 0;   // 源字符串索引，总是指向未读的一位
    int des_index = 0;   // 目标字符串索引，总是指向未写的一位。
    int* arg_addr = &format+1; // 边长参数第一个参数的地址。
    while (format[src_index] != 0){
    102d:	e9 33 01             	jmp    1163 <sprintf+0x15a>
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:109
        if (format[src_index] == '%'){
    1030:	3c 25                	cmp    $0x25,%al
    1032:	0f 85 1b 01          	jne    1151 <sprintf+0x148>
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:111
            src_index++;
            switch(format[src_index]){
    1036:	67 66 0f b6 44 39 01 	movzbl 0x1(%ecx,%edi,1),%eax
    103d:	3c 64                	cmp    $0x64,%al
    103f:	74 28                	je     1069 <sprintf+0x60>
    1041:	3c 73                	cmp    $0x73,%al
    1043:	0f 84 b5 00          	je     10fc <sprintf+0xf3>
    1047:	3c 63                	cmp    $0x63,%al
    1049:	0f 85 fe 00          	jne    114b <sprintf+0x142>
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:113
                case 'c':{
                    dest[des_index++] =*(arg_addr + arg_num++);
    104d:	67 66 8b 44 94 78    	mov    0x78(%esp,%edx,4),%eax
    1053:	67 88 44 1d 00       	mov    %al,0x0(%ebp,%ebx,1)
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:114
                    src_index++;
    1058:	66 83 c7 02          	add    $0x2,%edi
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:113
    while (format[src_index] != 0){
        if (format[src_index] == '%'){
            src_index++;
            switch(format[src_index]){
                case 'c':{
                    dest[des_index++] =*(arg_addr + arg_num++);
    105c:	67 66 8d 5b 01       	lea    0x1(%ebx),%ebx
    1061:	67 66 8d 52 01       	lea    0x1(%edx),%edx
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:115
                    src_index++;
                    break;
    1066:	e9 fa 00             	jmp    1163 <sprintf+0x15a>
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:118
                }
                case 'd':{
                    int n = *(arg_addr + arg_num++);
    1069:	67 66 8d 42 01       	lea    0x1(%edx),%eax
    106e:	67 66 89 44 24 08    	mov    %eax,0x8(%esp)
    1074:	67 66 8b 4c 94 78    	mov    0x78(%esp,%edx,4),%ecx
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:119
                    int len = 0; 
    107a:	66 be 00 00 00 00    	mov    $0x0,%esi
    1080:	67 66 89 7c 24 0c    	mov    %edi,0xc(%esp)
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:121
                    int num[INT_LENGTH];
                    while (n != 0){
    1086:	eb 37                	jmp    10bf <sprintf+0xb6>
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:122
                        num[len] = n % 10;
    1088:	66 ba 67 66 66 66    	mov    $0x66666667,%edx
    108e:	66 89 c8             	mov    %ecx,%eax
    1091:	66 f7 ea             	imul   %edx
    1094:	66 c1 fa 02          	sar    $0x2,%edx
    1098:	66 89 c8             	mov    %ecx,%eax
    109b:	66 c1 f8 1f          	sar    $0x1f,%eax
    109f:	66 29 c2             	sub    %eax,%edx
    10a2:	66 89 d7             	mov    %edx,%edi
    10a5:	67 66 8d 14 92       	lea    (%edx,%edx,4),%edx
    10aa:	67 66 8d 04 12       	lea    (%edx,%edx,1),%eax
    10af:	66 29 c1             	sub    %eax,%ecx
    10b2:	67 66 89 4c b4 14    	mov    %ecx,0x14(%esp,%esi,4)
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:123
                        n = n / 10;
    10b8:	66 89 f9             	mov    %edi,%ecx
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:124
                        len++;
    10bb:	66 83 c6 01          	add    $0x1,%esi
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:121
                }
                case 'd':{
                    int n = *(arg_addr + arg_num++);
                    int len = 0; 
                    int num[INT_LENGTH];
                    while (n != 0){
    10bf:	66 85 c9             	test   %ecx,%ecx
    10c2:	75 c4                	jne    1088 <sprintf+0x7f>
    10c4:	67 66 8b 7c 24 0c    	mov    0xc(%esp),%edi
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:126
                        num[len] = n % 10;
                        n = n / 10;
                        len++;
                    }
                    for (int i = len-1; i >= 0; i--){
    10ca:	67 66 8d 46 ff       	lea    -0x1(%esi),%eax
    10cf:	eb 1a                	jmp    10eb <sprintf+0xe2>
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:127 (discriminator 3)
                        dest[des_index++] = num[i]+'0';
    10d1:	67 66 0f b6 74 84 14 	movzbl 0x14(%esp,%eax,4),%esi
    10d8:	67 66 8d 56 30       	lea    0x30(%esi),%edx
    10dd:	67 88 54 1d 00       	mov    %dl,0x0(%ebp,%ebx,1)
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:126 (discriminator 3)
                    while (n != 0){
                        num[len] = n % 10;
                        n = n / 10;
                        len++;
                    }
                    for (int i = len-1; i >= 0; i--){
    10e2:	66 83 e8 01          	sub    $0x1,%eax
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:127 (discriminator 3)
                        dest[des_index++] = num[i]+'0';
    10e6:	67 66 8d 5b 01       	lea    0x1(%ebx),%ebx
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:126 (discriminator 1)
                    while (n != 0){
                        num[len] = n % 10;
                        n = n / 10;
                        len++;
                    }
                    for (int i = len-1; i >= 0; i--){
    10eb:	66 85 c0             	test   %eax,%eax
    10ee:	79 e1                	jns    10d1 <sprintf+0xc8>
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:129
                        dest[des_index++] = num[i]+'0';
                    }
                    src_index++;
    10f0:	66 83 c7 02          	add    $0x2,%edi
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:118
                    dest[des_index++] =*(arg_addr + arg_num++);
                    src_index++;
                    break;
                }
                case 'd':{
                    int n = *(arg_addr + arg_num++);
    10f4:	67 66 8b 54 24 08    	mov    0x8(%esp),%edx
    10fa:	eb 67                	jmp    1163 <sprintf+0x15a>
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:133
                    }
                    src_index++;
                    break;
                }
                case 's':{
                    char * str = *(char **)(arg_addr + arg_num++);
    10fc:	67 66 8d 42 01       	lea    0x1(%edx),%eax
    1101:	67 66 89 44 24 08    	mov    %eax,0x8(%esp)
    1107:	67 66 8b 74 94 78    	mov    0x78(%esp,%edx,4),%esi
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:134
                    u32 str_len = strlen(str);
    110d:	66 83 ec 0c          	sub    $0xc,%esp
    1111:	66 56                	push   %esi
    1113:	66 e8 7c 06 00 00    	calll  1795 <strlen>
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:136
                    u32 i = 0;
                    while (i < str_len){
    1119:	66 83 c4 10          	add    $0x10,%esp
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:135
                    break;
                }
                case 's':{
                    char * str = *(char **)(arg_addr + arg_num++);
                    u32 str_len = strlen(str);
                    u32 i = 0;
    111d:	66 ba 00 00 00 00    	mov    $0x0,%edx
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:136
                    while (i < str_len){
    1123:	eb 15                	jmp    113a <sprintf+0x131>
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:137
                        dest[des_index++] = str[i++];
    1125:	67 66 0f b6 0c 16    	movzbl (%esi,%edx,1),%ecx
    112b:	67 88 4c 1d 00       	mov    %cl,0x0(%ebp,%ebx,1)
    1130:	67 66 8d 52 01       	lea    0x1(%edx),%edx
    1135:	67 66 8d 5b 01       	lea    0x1(%ebx),%ebx
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:136
                }
                case 's':{
                    char * str = *(char **)(arg_addr + arg_num++);
                    u32 str_len = strlen(str);
                    u32 i = 0;
                    while (i < str_len){
    113a:	66 39 c2             	cmp    %eax,%edx
    113d:	72 e6                	jb     1125 <sprintf+0x11c>
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:139
                        dest[des_index++] = str[i++];
                    }
                    src_index++;
    113f:	66 83 c7 02          	add    $0x2,%edi
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:133
                    }
                    src_index++;
                    break;
                }
                case 's':{
                    char * str = *(char **)(arg_addr + arg_num++);
    1143:	67 66 8b 54 24 08    	mov    0x8(%esp),%edx
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:140
                    u32 i = 0;
                    while (i < str_len){
                        dest[des_index++] = str[i++];
                    }
                    src_index++;
                    break;
    1149:	eb 18                	jmp    1163 <sprintf+0x15a>
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:143
                }
                default :
                    src_index++;
    114b:	66 83 c7 02          	add    $0x2,%edi
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:144
                    break;
    114f:	eb 12                	jmp    1163 <sprintf+0x15a>
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:147
            }
        }
        else if (format[src_index] == '\\') {
    1151:	3c 5c                	cmp    $0x5c,%al
    1153:	74 0e                	je     1163 <sprintf+0x15a>
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:166
                        break;
                }
            }
        }
        else {
            dest[des_index++] = format[src_index++];
    1155:	66 83 c7 01          	add    $0x1,%edi
    1159:	67 88 44 1d 00       	mov    %al,0x0(%ebp,%ebx,1)
    115e:	67 66 8d 5b 01       	lea    0x1(%ebx),%ebx
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:108
void sprintf(char * dest , char * format, ...){
    int arg_num = 0;
    int src_index = 0;   // 源字符串索引，总是指向未读的一位
    int des_index = 0;   // 目标字符串索引，总是指向未写的一位。
    int* arg_addr = &format+1; // 边长参数第一个参数的地址。
    while (format[src_index] != 0){
    1163:	67 66 8b 4c 24 74    	mov    0x74(%esp),%ecx
    1169:	67 66 0f b6 04 39    	movzbl (%ecx,%edi,1),%eax
    116f:	84 c0                	test   %al,%al
    1171:	0f 85 bb fe          	jne    1030 <sprintf+0x27>
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:169
        }
        else {
            dest[des_index++] = format[src_index++];
        }
    }
    dest[des_index] = 0;
    1175:	67 c6 44 1d 00 00    	movb   $0x0,0x0(%ebp,%ebx,1)
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:171
    return ;
}
    117b:	66 83 c4 5c          	add    $0x5c,%esp
    117f:	66 5b                	pop    %ebx
    1181:	66 5e                	pop    %esi
    1183:	66 5f                	pop    %edi
    1185:	66 5d                	pop    %ebp
    1187:	66 c3                	retl   

00001189 <vprintf>:
vprintf():
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:174


void vprintf(char * format, va_list va){
    1189:	66 55                	push   %ebp
    118b:	66 57                	push   %edi
    118d:	66 56                	push   %esi
    118f:	66 53                	push   %ebx
    1191:	66 81 ec 5c 04 00 00 	sub    $0x45c,%esp
    1198:	67 66 8b ac 24 70 04 	mov    0x470(%esp),%ebp
    119f:	00 00 
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:178
    char buf[BUF_LENGTH];
    int arg_num = 0;
    int src_index = 0;   // 源字符串索引，总是指向未读的一位
    int des_index = 0;   // 目标字符串索引，总是指向未写的一位。
    11a1:	66 bb 00 00 00 00    	mov    $0x0,%ebx
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:177


void vprintf(char * format, va_list va){
    char buf[BUF_LENGTH];
    int arg_num = 0;
    int src_index = 0;   // 源字符串索引，总是指向未读的一位
    11a7:	66 bf 00 00 00 00    	mov    $0x0,%edi
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:176
}


void vprintf(char * format, va_list va){
    char buf[BUF_LENGTH];
    int arg_num = 0;
    11ad:	66 ba 00 00 00 00    	mov    $0x0,%edx
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:180
    int src_index = 0;   // 源字符串索引，总是指向未读的一位
    int des_index = 0;   // 目标字符串索引，总是指向未写的一位。
    int* arg_addr = va; // 边长参数第一个参数的地址。
    while (format[src_index] != 0){
    11b3:	e9 4c 01             	jmp    1302 <vprintf+0x179>
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:181
        if (format[src_index] == '%'){
    11b6:	3c 25                	cmp    $0x25,%al
    11b8:	0f 85 34 01          	jne    12f0 <vprintf+0x167>
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:183
            src_index++;
            switch(format[src_index]){
    11bc:	67 66 0f b6 44 3d 01 	movzbl 0x1(%ebp,%edi,1),%eax
    11c3:	3c 64                	cmp    $0x64,%al
    11c5:	74 30                	je     11f7 <vprintf+0x6e>
    11c7:	3c 73                	cmp    $0x73,%al
    11c9:	0f 84 c6 00          	je     1293 <vprintf+0x10a>
    11cd:	3c 63                	cmp    $0x63,%al
    11cf:	0f 85 17 01          	jne    12ea <vprintf+0x161>
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:185
                case 'c':{
                    buf[des_index++] =*(arg_addr + arg_num++);
    11d3:	67 66 8b 84 24 74 04 	mov    0x474(%esp),%eax
    11da:	00 00 
    11dc:	67 66 8b 04 90       	mov    (%eax,%edx,4),%eax
    11e1:	67 88 44 1c 50       	mov    %al,0x50(%esp,%ebx,1)
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:186
                    src_index++;
    11e6:	66 83 c7 02          	add    $0x2,%edi
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:185
    while (format[src_index] != 0){
        if (format[src_index] == '%'){
            src_index++;
            switch(format[src_index]){
                case 'c':{
                    buf[des_index++] =*(arg_addr + arg_num++);
    11ea:	67 66 8d 5b 01       	lea    0x1(%ebx),%ebx
    11ef:	67 66 8d 52 01       	lea    0x1(%edx),%edx
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:187
                    src_index++;
                    break;
    11f4:	e9 0b 01             	jmp    1302 <vprintf+0x179>
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:190
                }
                case 'd':{
                    int n = *(arg_addr + arg_num++);
    11f7:	67 66 8d 42 01       	lea    0x1(%edx),%eax
    11fc:	67 66 89 44 24 08    	mov    %eax,0x8(%esp)
    1202:	67 66 8b 84 24 74 04 	mov    0x474(%esp),%eax
    1209:	00 00 
    120b:	67 66 8b 34 90       	mov    (%eax,%edx,4),%esi
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:191
                    int len = 0; 
    1210:	66 b9 00 00 00 00    	mov    $0x0,%ecx
    1216:	67 66 89 7c 24 0c    	mov    %edi,0xc(%esp)
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:193
                    int num[INT_LENGTH];
                    while (n != 0){
    121c:	eb 3a                	jmp    1258 <vprintf+0xcf>
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:194
                        num[len] = n % 10;
    121e:	66 ba 67 66 66 66    	mov    $0x66666667,%edx
    1224:	66 89 f0             	mov    %esi,%eax
    1227:	66 f7 ea             	imul   %edx
    122a:	66 c1 fa 02          	sar    $0x2,%edx
    122e:	66 89 f0             	mov    %esi,%eax
    1231:	66 c1 f8 1f          	sar    $0x1f,%eax
    1235:	66 29 c2             	sub    %eax,%edx
    1238:	66 89 d7             	mov    %edx,%edi
    123b:	67 66 8d 14 92       	lea    (%edx,%edx,4),%edx
    1240:	67 66 8d 04 12       	lea    (%edx,%edx,1),%eax
    1245:	66 89 f2             	mov    %esi,%edx
    1248:	66 29 c2             	sub    %eax,%edx
    124b:	67 66 89 54 8c 14    	mov    %edx,0x14(%esp,%ecx,4)
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:195
                        n = n / 10;
    1251:	66 89 fe             	mov    %edi,%esi
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:196
                        len++;
    1254:	66 83 c1 01          	add    $0x1,%ecx
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:193
                }
                case 'd':{
                    int n = *(arg_addr + arg_num++);
                    int len = 0; 
                    int num[INT_LENGTH];
                    while (n != 0){
    1258:	66 85 f6             	test   %esi,%esi
    125b:	75 c1                	jne    121e <vprintf+0x95>
    125d:	67 66 8b 7c 24 0c    	mov    0xc(%esp),%edi
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:198
                        num[len] = n % 10;
                        n = n / 10;
                        len++;
                    }
                    for (int i = len-1; i >= 0; i--){
    1263:	66 83 e9 01          	sub    $0x1,%ecx
    1267:	eb 19                	jmp    1282 <vprintf+0xf9>
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:199 (discriminator 3)
                        buf[des_index++] = num[i]+'0';
    1269:	67 66 0f b6 44 8c 14 	movzbl 0x14(%esp,%ecx,4),%eax
    1270:	66 83 c0 30          	add    $0x30,%eax
    1274:	67 88 44 1c 50       	mov    %al,0x50(%esp,%ebx,1)
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:198 (discriminator 3)
                    while (n != 0){
                        num[len] = n % 10;
                        n = n / 10;
                        len++;
                    }
                    for (int i = len-1; i >= 0; i--){
    1279:	66 83 e9 01          	sub    $0x1,%ecx
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:199 (discriminator 3)
                        buf[des_index++] = num[i]+'0';
    127d:	67 66 8d 5b 01       	lea    0x1(%ebx),%ebx
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:198 (discriminator 1)
                    while (n != 0){
                        num[len] = n % 10;
                        n = n / 10;
                        len++;
                    }
                    for (int i = len-1; i >= 0; i--){
    1282:	66 85 c9             	test   %ecx,%ecx
    1285:	79 e2                	jns    1269 <vprintf+0xe0>
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:201
                        buf[des_index++] = num[i]+'0';
                    }
                    src_index++;
    1287:	66 83 c7 02          	add    $0x2,%edi
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:190
                    buf[des_index++] =*(arg_addr + arg_num++);
                    src_index++;
                    break;
                }
                case 'd':{
                    int n = *(arg_addr + arg_num++);
    128b:	67 66 8b 54 24 08    	mov    0x8(%esp),%edx
    1291:	eb 6f                	jmp    1302 <vprintf+0x179>
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:205
                    }
                    src_index++;
                    break;
                }
                case 's':{
                    char * str = *(char **)(arg_addr + arg_num++);
    1293:	67 66 8d 42 01       	lea    0x1(%edx),%eax
    1298:	67 66 89 44 24 08    	mov    %eax,0x8(%esp)
    129e:	67 66 8b 84 24 74 04 	mov    0x474(%esp),%eax
    12a5:	00 00 
    12a7:	67 66 8b 34 90       	mov    (%eax,%edx,4),%esi
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:206
                    u32 str_len = strlen(str);
    12ac:	66 83 ec 0c          	sub    $0xc,%esp
    12b0:	66 56                	push   %esi
    12b2:	66 e8 dd 04 00 00    	calll  1795 <strlen>
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:208
                    u32 i = 0;
                    while (i < str_len){
    12b8:	66 83 c4 10          	add    $0x10,%esp
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:207
                    break;
                }
                case 's':{
                    char * str = *(char **)(arg_addr + arg_num++);
                    u32 str_len = strlen(str);
                    u32 i = 0;
    12bc:	66 ba 00 00 00 00    	mov    $0x0,%edx
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:208
                    while (i < str_len){
    12c2:	eb 15                	jmp    12d9 <vprintf+0x150>
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:209
                        buf[des_index++] = str[i++];
    12c4:	67 66 0f b6 0c 16    	movzbl (%esi,%edx,1),%ecx
    12ca:	67 88 4c 1c 50       	mov    %cl,0x50(%esp,%ebx,1)
    12cf:	67 66 8d 52 01       	lea    0x1(%edx),%edx
    12d4:	67 66 8d 5b 01       	lea    0x1(%ebx),%ebx
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:208
                }
                case 's':{
                    char * str = *(char **)(arg_addr + arg_num++);
                    u32 str_len = strlen(str);
                    u32 i = 0;
                    while (i < str_len){
    12d9:	66 39 c2             	cmp    %eax,%edx
    12dc:	72 e6                	jb     12c4 <vprintf+0x13b>
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:211
                        buf[des_index++] = str[i++];
                    }
                    src_index++;
    12de:	66 83 c7 02          	add    $0x2,%edi
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:205
                    }
                    src_index++;
                    break;
                }
                case 's':{
                    char * str = *(char **)(arg_addr + arg_num++);
    12e2:	67 66 8b 54 24 08    	mov    0x8(%esp),%edx
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:212
                    u32 i = 0;
                    while (i < str_len){
                        buf[des_index++] = str[i++];
                    }
                    src_index++;
                    break;
    12e8:	eb 18                	jmp    1302 <vprintf+0x179>
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:215
                }
                default :
                    src_index++;
    12ea:	66 83 c7 02          	add    $0x2,%edi
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:216
                    break;
    12ee:	eb 12                	jmp    1302 <vprintf+0x179>
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:219
            }
        }
        else if (format[src_index] == '\\') {
    12f0:	3c 5c                	cmp    $0x5c,%al
    12f2:	74 0e                	je     1302 <vprintf+0x179>
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:238
                        break;
                }
            }
        }
        else {
            buf[des_index++] = format[src_index++];
    12f4:	66 83 c7 01          	add    $0x1,%edi
    12f8:	67 88 44 1c 50       	mov    %al,0x50(%esp,%ebx,1)
    12fd:	67 66 8d 5b 01       	lea    0x1(%ebx),%ebx
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:180
    char buf[BUF_LENGTH];
    int arg_num = 0;
    int src_index = 0;   // 源字符串索引，总是指向未读的一位
    int des_index = 0;   // 目标字符串索引，总是指向未写的一位。
    int* arg_addr = va; // 边长参数第一个参数的地址。
    while (format[src_index] != 0){
    1302:	67 66 0f b6 44 3d 00 	movzbl 0x0(%ebp,%edi,1),%eax
    1309:	84 c0                	test   %al,%al
    130b:	0f 85 a7 fe          	jne    11b6 <vprintf+0x2d>
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:241
        }
        else {
            buf[des_index++] = format[src_index++];
        }
    }
    buf[des_index] = 0;
    130f:	67 c6 44 1c 50 00    	movb   $0x0,0x50(%esp,%ebx,1)
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:242
    for (int i = 0; i < des_index; i++){
    1315:	66 be 00 00 00 00    	mov    $0x0,%esi
    131b:	eb 1b                	jmp    1338 <vprintf+0x1af>
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:243 (discriminator 3)
        putc(buf[i]);
    131d:	66 83 ec 0c          	sub    $0xc,%esp
    1321:	67 66 0f be 44 34 5c 	movsbl 0x5c(%esp,%esi,1),%eax
    1328:	66 50                	push   %eax
    132a:	66 e8 a3 fa ff ff    	calll  dd3 <putc>
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:242 (discriminator 3)
        else {
            buf[des_index++] = format[src_index++];
        }
    }
    buf[des_index] = 0;
    for (int i = 0; i < des_index; i++){
    1330:	66 83 c6 01          	add    $0x1,%esi
    1334:	66 83 c4 10          	add    $0x10,%esp
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:242 (discriminator 1)
    1338:	66 39 f3             	cmp    %esi,%ebx
    133b:	7f e0                	jg     131d <vprintf+0x194>
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:246
        putc(buf[i]);
    }
    return ;
}
    133d:	66 81 c4 5c 04 00 00 	add    $0x45c,%esp
    1344:	66 5b                	pop    %ebx
    1346:	66 5e                	pop    %esi
    1348:	66 5f                	pop    %edi
    134a:	66 5d                	pop    %ebp
    134c:	66 c3                	retl   

0000134e <printf>:
printf():
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:248

void printf(char * format, ...){
    134e:	66 83 ec 14          	sub    $0x14,%esp
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:249
    vprintf(format, &format+1);// 其实这里由于format是个指针，是32位的，所以这里对format的地址+1，也会加4个字节。
    1352:	67 66 8d 44 24 1c    	lea    0x1c(%esp),%eax
    1358:	66 50                	push   %eax
    135a:	67 66 ff 74 24 1c    	pushl  0x1c(%esp)
    1360:	66 e8 23 fe ff ff    	calll  1189 <vprintf>
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:251
    return ;
}
    1366:	66 83 c4 1c          	add    $0x1c,%esp
    136a:	66 c3                	retl   

0000136c <isalpha>:
isalpha():
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:270
//     return ;
// }



int isalpha (int ch){
    136c:	67 66 8b 44 24 04    	mov    0x4(%esp),%eax
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:271
    if ('a' <= ch && ch <= 'z')
    1372:	67 66 8d 50 9f       	lea    -0x61(%eax),%edx
    1377:	66 83 fa 19          	cmp    $0x19,%edx
    137b:	76 12                	jbe    138f <isalpha+0x23>
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:273
        return 1;
    if ('A' <= ch && ch <= 'Z')
    137d:	66 83 e8 41          	sub    $0x41,%eax
    1381:	66 83 f8 19          	cmp    $0x19,%eax
    1385:	77 10                	ja     1397 <isalpha+0x2b>
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:274
        return 1;
    1387:	66 b8 01 00 00 00    	mov    $0x1,%eax
    138d:	66 c3                	retl   
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:272



int isalpha (int ch){
    if ('a' <= ch && ch <= 'z')
        return 1;
    138f:	66 b8 01 00 00 00    	mov    $0x1,%eax
    1395:	66 c3                	retl   
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:275
    if ('A' <= ch && ch <= 'Z')
        return 1;
    return 0;
    1397:	66 b8 00 00 00 00    	mov    $0x0,%eax
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:276
}
    139d:	66 c3                	retl   

0000139f <isdigit>:
isdigit():
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:278
int isdigit (int ch){
    if ('0' <= ch && ch <= '9')
    139f:	67 66 8b 44 24 04    	mov    0x4(%esp),%eax
    13a5:	66 83 e8 30          	sub    $0x30,%eax
    13a9:	66 83 f8 09          	cmp    $0x9,%eax
    13ad:	77 08                	ja     13b7 <isdigit+0x18>
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:279
        return 1;
    13af:	66 b8 01 00 00 00    	mov    $0x1,%eax
    13b5:	66 c3                	retl   
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:280
    return 0;
    13b7:	66 b8 00 00 00 00    	mov    $0x0,%eax
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:281
}
    13bd:	66 c3                	retl   

000013bf <isalnum>:
isalnum():
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:283

int isalnum (int ch){
    13bf:	66 53                	push   %ebx
    13c1:	67 66 8b 5c 24 08    	mov    0x8(%esp),%ebx
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:284
    if ( isalpha(ch) || isdigit(ch) ){
    13c7:	66 53                	push   %ebx
    13c9:	66 e8 9d ff ff ff    	calll  136c <isalpha>
    13cf:	66 83 c4 04          	add    $0x4,%esp
    13d3:	66 85 c0             	test   %eax,%eax
    13d6:	75 13                	jne    13eb <isalnum+0x2c>
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:284 (discriminator 1)
    13d8:	66 53                	push   %ebx
    13da:	66 e8 bf ff ff ff    	calll  139f <isdigit>
    13e0:	66 83 c4 04          	add    $0x4,%esp
    13e4:	66 85 c0             	test   %eax,%eax
    13e7:	75 0a                	jne    13f3 <isalnum+0x34>
    13e9:	eb 0e                	jmp    13f9 <isalnum+0x3a>
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:285
        return 1;
    13eb:	66 b8 01 00 00 00    	mov    $0x1,%eax
    13f1:	eb 06                	jmp    13f9 <isalnum+0x3a>
    13f3:	66 b8 01 00 00 00    	mov    $0x1,%eax
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:288
    }
    return 0;
}
    13f9:	66 5b                	pop    %ebx
    13fb:	66 c3                	retl   

000013fd <ispunct>:
ispunct():
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:289
int ispunct (int ch){
    13fd:	66 83 ec 30          	sub    $0x30,%esp
    1401:	67 66 8b 4c 24 34    	mov    0x34(%esp),%ecx
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:290
    char punct[34] =  "!\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~";
    1407:	67 66 c7 44 24 0e 21 	movl   $0x24232221,0xe(%esp)
    140e:	22 23 24 
    1411:	67 66 c7 44 24 12 25 	movl   $0x28272625,0x12(%esp)
    1418:	26 27 28 
    141b:	67 66 c7 44 24 16 29 	movl   $0x2c2b2a29,0x16(%esp)
    1422:	2a 2b 2c 
    1425:	67 66 c7 44 24 1a 2d 	movl   $0x3a2f2e2d,0x1a(%esp)
    142c:	2e 2f 3a 
    142f:	67 66 c7 44 24 1e 3b 	movl   $0x3e3d3c3b,0x1e(%esp)
    1436:	3c 3d 3e 
    1439:	67 66 c7 44 24 22 3f 	movl   $0x5c5b403f,0x22(%esp)
    1440:	40 5b 5c 
    1443:	67 66 c7 44 24 26 5d 	movl   $0x605f5e5d,0x26(%esp)
    144a:	5e 5f 60 
    144d:	67 66 c7 44 24 2a 7b 	movl   $0x7e7d7c7b,0x2a(%esp)
    1454:	7c 7d 7e 
    1457:	67 c7 44 24 2e 00 00 	movw   $0x0,0x2e(%esp)
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:291
    for (int i = 0; i < 33; i++){
    145e:	66 b8 00 00 00 00    	mov    $0x0,%eax
    1464:	eb 10                	jmp    1476 <ispunct+0x79>
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:292
        if (ch == punct[i])
    1466:	67 66 0f be 54 04 0e 	movsbl 0xe(%esp,%eax,1),%edx
    146d:	66 39 ca             	cmp    %ecx,%edx
    1470:	74 12                	je     1484 <ispunct+0x87>
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:291 (discriminator 2)
    }
    return 0;
}
int ispunct (int ch){
    char punct[34] =  "!\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~";
    for (int i = 0; i < 33; i++){
    1472:	66 83 c0 01          	add    $0x1,%eax
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:291 (discriminator 1)
    1476:	66 83 f8 20          	cmp    $0x20,%eax
    147a:	7e ea                	jle    1466 <ispunct+0x69>
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:295
        if (ch == punct[i])
            return 1;
    }
    return 0;
    147c:	66 b8 00 00 00 00    	mov    $0x0,%eax
    1482:	eb 06                	jmp    148a <ispunct+0x8d>
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:293
}
int ispunct (int ch){
    char punct[34] =  "!\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~";
    for (int i = 0; i < 33; i++){
        if (ch == punct[i])
            return 1;
    1484:	66 b8 01 00 00 00    	mov    $0x1,%eax
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:296
    }
    return 0;
}
    148a:	66 83 c4 30          	add    $0x30,%esp
    148e:	66 c3                	retl   

00001490 <isblank>:
isblank():
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:298
int isblank (int ch){
    if (ch == ' ')
    1490:	67 66 83 7c 24 04 20 	cmpl   $0x20,0x4(%esp)
    1497:	75 08                	jne    14a1 <isblank+0x11>
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:299
        return 1;
    1499:	66 b8 01 00 00 00    	mov    $0x1,%eax
    149f:	66 c3                	retl   
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:300
    return 0;
    14a1:	66 b8 00 00 00 00    	mov    $0x0,%eax
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:301
}
    14a7:	66 c3                	retl   

000014a9 <isprint>:
isprint():
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:302
int isprint (int ch){
    14a9:	66 53                	push   %ebx
    14ab:	67 66 8b 5c 24 08    	mov    0x8(%esp),%ebx
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:303
    if (isalpha(ch) || isdigit(ch) || isalnum(ch) || ispunct(ch) || isblank(ch)){
    14b1:	66 53                	push   %ebx
    14b3:	66 e8 b3 fe ff ff    	calll  136c <isalpha>
    14b9:	66 83 c4 04          	add    $0x4,%esp
    14bd:	66 85 c0             	test   %eax,%eax
    14c0:	75 46                	jne    1508 <isprint+0x5f>
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:303 (discriminator 1)
    14c2:	66 53                	push   %ebx
    14c4:	66 e8 d5 fe ff ff    	calll  139f <isdigit>
    14ca:	66 83 c4 04          	add    $0x4,%esp
    14ce:	66 85 c0             	test   %eax,%eax
    14d1:	75 3d                	jne    1510 <isprint+0x67>
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:303 (discriminator 2)
    14d3:	66 53                	push   %ebx
    14d5:	66 e8 e4 fe ff ff    	calll  13bf <isalnum>
    14db:	66 83 c4 04          	add    $0x4,%esp
    14df:	66 85 c0             	test   %eax,%eax
    14e2:	75 34                	jne    1518 <isprint+0x6f>
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:303 (discriminator 3)
    14e4:	66 53                	push   %ebx
    14e6:	66 e8 11 ff ff ff    	calll  13fd <ispunct>
    14ec:	66 83 c4 04          	add    $0x4,%esp
    14f0:	66 85 c0             	test   %eax,%eax
    14f3:	75 2b                	jne    1520 <isprint+0x77>
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:303 (discriminator 4)
    14f5:	66 53                	push   %ebx
    14f7:	66 e8 93 ff ff ff    	calll  1490 <isblank>
    14fd:	66 83 c4 04          	add    $0x4,%esp
    1501:	66 85 c0             	test   %eax,%eax
    1504:	75 22                	jne    1528 <isprint+0x7f>
    1506:	eb 26                	jmp    152e <isprint+0x85>
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:304
        return 1;
    1508:	66 b8 01 00 00 00    	mov    $0x1,%eax
    150e:	eb 1e                	jmp    152e <isprint+0x85>
    1510:	66 b8 01 00 00 00    	mov    $0x1,%eax
    1516:	eb 16                	jmp    152e <isprint+0x85>
    1518:	66 b8 01 00 00 00    	mov    $0x1,%eax
    151e:	eb 0e                	jmp    152e <isprint+0x85>
    1520:	66 b8 01 00 00 00    	mov    $0x1,%eax
    1526:	eb 06                	jmp    152e <isprint+0x85>
    1528:	66 b8 01 00 00 00    	mov    $0x1,%eax
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:307
    }
    return 0;
}
    152e:	66 5b                	pop    %ebx
    1530:	66 c3                	retl   

00001532 <iscntrl>:
iscntrl():
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:308
int iscntrl (int ch){
    1532:	67 66 8b 44 24 04    	mov    0x4(%esp),%eax
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:310
    //he control characters are the characters with the codes 0x00-0x1F and 0x7F.
    if (0 <= ch && ch <= 0x1f)
    1538:	66 83 f8 1f          	cmp    $0x1f,%eax
    153c:	76 0e                	jbe    154c <iscntrl+0x1a>
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:312
        return 1;
    if (ch == 0x7f)
    153e:	66 83 f8 7f          	cmp    $0x7f,%eax
    1542:	75 10                	jne    1554 <iscntrl+0x22>
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:313
        return 1;
    1544:	66 b8 01 00 00 00    	mov    $0x1,%eax
    154a:	66 c3                	retl   
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:311
    return 0;
}
int iscntrl (int ch){
    //he control characters are the characters with the codes 0x00-0x1F and 0x7F.
    if (0 <= ch && ch <= 0x1f)
        return 1;
    154c:	66 b8 01 00 00 00    	mov    $0x1,%eax
    1552:	66 c3                	retl   
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:314
    if (ch == 0x7f)
        return 1;
    return 0;
    1554:	66 b8 00 00 00 00    	mov    $0x0,%eax
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:315
}
    155a:	66 c3                	retl   

0000155c <read_n_sector>:
read_n_sector():
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:321

/* tested
读取指定逻辑扇区号的扇区到指定内存地址处
注意一次最多写一个段，也就是64k 最多读128个扇区。
够用了够用了 */
void read_n_sector(u16 sector_code, u16 number,  u16 segment, u16 offset){
    155c:	66 55                	push   %ebp
    155e:	66 57                	push   %edi
    1560:	66 56                	push   %esi
    1562:	66 53                	push   %ebx
    1564:	66 83 ec 1c          	sub    $0x1c,%esp
    1568:	67 66 0f b7 7c 24 30 	movzwl 0x30(%esp),%edi
    156f:	67 66 0f b7 74 24 34 	movzwl 0x34(%esp),%esi
    1576:	67 66 0f b7 44 24 38 	movzwl 0x38(%esp),%eax
    157d:	67 89 44 24 0c       	mov    %ax,0xc(%esp)
    1582:	67 66 0f b7 44 24 3c 	movzwl 0x3c(%esp),%eax
    1589:	67 89 44 24 0e       	mov    %ax,0xe(%esp)
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:322
    for (int i = 0; i < number; i++){
    158e:	66 bb 00 00 00 00    	mov    $0x0,%ebx
    1594:	eb 7d                	jmp    1613 <read_n_sector+0xb7>
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:323 (discriminator 3)
        int sector = (sector_code+i) % 18+1;
    1596:	66 0f b7 ef          	movzwl %di,%ebp
    159a:	66 01 dd             	add    %ebx,%ebp
    159d:	66 ba 39 8e e3 38    	mov    $0x38e38e39,%edx
    15a3:	66 89 e8             	mov    %ebp,%eax
    15a6:	66 f7 ea             	imul   %edx
    15a9:	66 c1 fa 02          	sar    $0x2,%edx
    15ad:	66 89 e8             	mov    %ebp,%eax
    15b0:	66 c1 f8 1f          	sar    $0x1f,%eax
    15b4:	66 29 c2             	sub    %eax,%edx
    15b7:	66 89 d1             	mov    %edx,%ecx
    15ba:	67 66 8d 14 d2       	lea    (%edx,%edx,8),%edx
    15bf:	67 66 8d 04 12       	lea    (%edx,%edx,1),%eax
    15c4:	66 89 ea             	mov    %ebp,%edx
    15c7:	66 29 c2             	sub    %eax,%edx
    15ca:	66 83 c2 01          	add    $0x1,%edx
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:325 (discriminator 3)
        int mid = (sector_code+i) / 18;
        int cylinder = mid >> 1;
    15ce:	66 89 cd             	mov    %ecx,%ebp
    15d1:	66 d1 fd             	sar    %ebp
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:327 (discriminator 3)
        int head = mid & 1;
        read_sector(head, cylinder,sector,segment, offset + i*512);
    15d4:	66 83 ec 0c          	sub    $0xc,%esp
    15d8:	66 89 d8             	mov    %ebx,%eax
    15db:	66 c1 e0 09          	shl    $0x9,%eax
    15df:	67 03 44 24 1a       	add    0x1a(%esp),%ax
    15e4:	66 0f b7 c0          	movzwl %ax,%eax
    15e8:	66 50                	push   %eax
    15ea:	67 66 0f b7 44 24 1c 	movzwl 0x1c(%esp),%eax
    15f1:	66 50                	push   %eax
    15f3:	66 0f b7 d2          	movzwl %dx,%edx
    15f7:	66 52                	push   %edx
    15f9:	66 0f b7 ed          	movzwl %bp,%ebp
    15fd:	66 55                	push   %ebp
    15ff:	66 83 e1 01          	and    $0x1,%ecx
    1603:	66 51                	push   %ecx
    1605:	66 e8 1a 01 00 00    	calll  1725 <read_sector>
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:322 (discriminator 3)
/* tested
读取指定逻辑扇区号的扇区到指定内存地址处
注意一次最多写一个段，也就是64k 最多读128个扇区。
够用了够用了 */
void read_n_sector(u16 sector_code, u16 number,  u16 segment, u16 offset){
    for (int i = 0; i < number; i++){
    160b:	66 83 c3 01          	add    $0x1,%ebx
    160f:	66 83 c4 20          	add    $0x20,%esp
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:322 (discriminator 1)
    1613:	66 0f b7 c6          	movzwl %si,%eax
    1617:	66 39 c3             	cmp    %eax,%ebx
    161a:	0f 8c 78 ff          	jl     1596 <read_n_sector+0x3a>
/mnt/e/code/my_operating_system/os/service/../lib/stdio.c:330
        int cylinder = mid >> 1;
        int head = mid & 1;
        read_sector(head, cylinder,sector,segment, offset + i*512);
    }
    return ;
}
    161e:	66 83 c4 1c          	add    $0x1c,%esp
    1622:	66 5b                	pop    %ebx
    1624:	66 5e                	pop    %esi
    1626:	66 5f                	pop    %edi
    1628:	66 5d                	pop    %ebp
    162a:	66 c3                	retl   
    162c:	66 90                	xchg   %eax,%eax
    162e:	66 90                	xchg   %eax,%eax

00001630 <write_port_byte>:
write_port_byte():
    1630:	66 55                	push   %ebp
    1632:	66 89 e5             	mov    %esp,%ebp
    1635:	53                   	push   %bx
    1636:	51                   	push   %cx
    1637:	52                   	push   %dx
    1638:	56                   	push   %si
    1639:	57                   	push   %di
    163a:	55                   	push   %bp
    163b:	1e                   	push   %ds
    163c:	06                   	push   %es
    163d:	16                   	push   %ss
    163e:	67 8b 5d 08          	mov    0x8(%ebp),%bx
    1642:	67 8a 45 0c          	mov    0xc(%ebp),%al
    1646:	cd 34                	int    $0x34
    1648:	17                   	pop    %ss
    1649:	07                   	pop    %es
    164a:	1f                   	pop    %ds
    164b:	5d                   	pop    %bp
    164c:	5f                   	pop    %di
    164d:	5e                   	pop    %si
    164e:	5a                   	pop    %dx
    164f:	59                   	pop    %cx
    1650:	5b                   	pop    %bx
    1651:	66 89 ec             	mov    %ebp,%esp
    1654:	66 5d                	pop    %ebp
    1656:	66 c3                	retl   

00001658 <read_port_byte>:
read_port_byte():
    1658:	66 55                	push   %ebp
    165a:	66 89 e5             	mov    %esp,%ebp
    165d:	53                   	push   %bx
    165e:	51                   	push   %cx
    165f:	52                   	push   %dx
    1660:	56                   	push   %si
    1661:	57                   	push   %di
    1662:	55                   	push   %bp
    1663:	1e                   	push   %ds
    1664:	06                   	push   %es
    1665:	16                   	push   %ss
    1666:	67 8b 45 08          	mov    0x8(%ebp),%ax
    166a:	cd 33                	int    $0x33
    166c:	17                   	pop    %ss
    166d:	07                   	pop    %es
    166e:	1f                   	pop    %ds
    166f:	5d                   	pop    %bp
    1670:	5f                   	pop    %di
    1671:	5e                   	pop    %si
    1672:	5a                   	pop    %dx
    1673:	59                   	pop    %cx
    1674:	5b                   	pop    %bx
    1675:	66 89 ec             	mov    %ebp,%esp
    1678:	66 5d                	pop    %ebp
    167a:	66 c3                	retl   

0000167c <write_memory_byte>:
write_memory_byte():
    167c:	66 55                	push   %ebp
    167e:	66 89 e5             	mov    %esp,%ebp
    1681:	50                   	push   %ax
    1682:	53                   	push   %bx
    1683:	52                   	push   %dx
    1684:	1e                   	push   %ds
    1685:	67 8b 5d 08          	mov    0x8(%ebp),%bx
    1689:	67 8b 45 0a          	mov    0xa(%ebp),%ax
    168d:	c1 e0 0c             	shl    $0xc,%ax
    1690:	67 8a 4d 0c          	mov    0xc(%ebp),%cl
    1694:	cd 36                	int    $0x36
    1696:	1f                   	pop    %ds
    1697:	5a                   	pop    %dx
    1698:	5b                   	pop    %bx
    1699:	58                   	pop    %ax
    169a:	66 89 ec             	mov    %ebp,%esp
    169d:	66 5d                	pop    %ebp
    169f:	66 c3                	retl   

000016a1 <read_memory_byte>:
read_memory_byte():
    16a1:	66 55                	push   %ebp
    16a3:	66 89 e5             	mov    %esp,%ebp
    16a6:	53                   	push   %bx
    16a7:	51                   	push   %cx
    16a8:	52                   	push   %dx
    16a9:	56                   	push   %si
    16aa:	57                   	push   %di
    16ab:	55                   	push   %bp
    16ac:	1e                   	push   %ds
    16ad:	06                   	push   %es
    16ae:	16                   	push   %ss
    16af:	67 8b 5d 08          	mov    0x8(%ebp),%bx
    16b3:	67 8b 45 0a          	mov    0xa(%ebp),%ax
    16b7:	c1 e0 0c             	shl    $0xc,%ax
    16ba:	cd 35                	int    $0x35
    16bc:	17                   	pop    %ss
    16bd:	07                   	pop    %es
    16be:	1f                   	pop    %ds
    16bf:	5d                   	pop    %bp
    16c0:	5f                   	pop    %di
    16c1:	5e                   	pop    %si
    16c2:	5a                   	pop    %dx
    16c3:	59                   	pop    %cx
    16c4:	5b                   	pop    %bx
    16c5:	66 89 ec             	mov    %ebp,%esp
    16c8:	66 5d                	pop    %ebp
    16ca:	66 c3                	retl   

000016cc <check_keyboard>:
check_keyboard():
    16cc:	b4 01                	mov    $0x1,%ah
    16ce:	cd 16                	int    $0x16
    16d0:	74 05                	je     16d7 <check_keyboard.have_key>
    16d2:	b8 00 00             	mov    $0x0,%ax
    16d5:	eb 03                	jmp    16da <check_keyboard.check_keyboard_return>

000016d7 <check_keyboard.have_key>:
check_keyboard.have_key():
    16d7:	b8 01 00             	mov    $0x1,%ax

000016da <check_keyboard.check_keyboard_return>:
check_keyboard.check_keyboard_return():
    16da:	66 c3                	retl   

000016dc <get_keyboard>:
get_keyboard():
    16dc:	b4 00                	mov    $0x0,%ah
    16de:	cd 16                	int    $0x16
    16e0:	66 c3                	retl   

000016e2 <clean_screen>:
clean_screen():
    16e2:	50                   	push   %ax
    16e3:	53                   	push   %bx
    16e4:	51                   	push   %cx
    16e5:	52                   	push   %dx
    16e6:	b4 06                	mov    $0x6,%ah
    16e8:	b0 00                	mov    $0x0,%al
    16ea:	b5 00                	mov    $0x0,%ch
    16ec:	b1 00                	mov    $0x0,%cl
    16ee:	b6 17                	mov    $0x17,%dh
    16f0:	b2 4f                	mov    $0x4f,%dl
    16f2:	b7 1f                	mov    $0x1f,%bh
    16f4:	cd 10                	int    $0x10
    16f6:	5a                   	pop    %dx
    16f7:	59                   	pop    %cx
    16f8:	5b                   	pop    %bx
    16f9:	58                   	pop    %ax
    16fa:	66 c3                	retl   

000016fc <scroll_screen>:
scroll_screen():
    16fc:	50                   	push   %ax
    16fd:	53                   	push   %bx
    16fe:	51                   	push   %cx
    16ff:	52                   	push   %dx
    1700:	b4 06                	mov    $0x6,%ah
    1702:	b0 01                	mov    $0x1,%al
    1704:	b5 00                	mov    $0x0,%ch
    1706:	b1 00                	mov    $0x0,%cl
    1708:	b6 17                	mov    $0x17,%dh
    170a:	b2 4f                	mov    $0x4f,%dl
    170c:	b7 10                	mov    $0x10,%bh
    170e:	cd 10                	int    $0x10
    1710:	5a                   	pop    %dx
    1711:	59                   	pop    %cx
    1712:	5b                   	pop    %bx
    1713:	58                   	pop    %ax
    1714:	66 c3                	retl   

00001716 <get_random>:
get_random():
    1716:	53                   	push   %bx
    1717:	b8 00 00             	mov    $0x0,%ax
    171a:	e6 43                	out    %al,$0x43
    171c:	e4 40                	in     $0x40,%al
    171e:	b3 08                	mov    $0x8,%bl
    1720:	f6 e3                	mul    %bl
    1722:	5b                   	pop    %bx
    1723:	66 c3                	retl   

00001725 <read_sector>:
read_sector():
    1725:	66 55                	push   %ebp
    1727:	66 89 e5             	mov    %esp,%ebp
    172a:	50                   	push   %ax
    172b:	53                   	push   %bx
    172c:	51                   	push   %cx
    172d:	52                   	push   %dx
    172e:	06                   	push   %es
    172f:	67 8b 45 14          	mov    0x14(%ebp),%ax
    1733:	8e c0                	mov    %ax,%es
    1735:	67 8b 5d 18          	mov    0x18(%ebp),%bx
    1739:	b4 02                	mov    $0x2,%ah
    173b:	b0 01                	mov    $0x1,%al
    173d:	b2 00                	mov    $0x0,%dl
    173f:	67 8a 75 08          	mov    0x8(%ebp),%dh
    1743:	67 8a 6d 0c          	mov    0xc(%ebp),%ch
    1747:	67 8a 4d 10          	mov    0x10(%ebp),%cl
    174b:	cd 13                	int    $0x13
    174d:	07                   	pop    %es
    174e:	5a                   	pop    %dx
    174f:	59                   	pop    %cx
    1750:	5b                   	pop    %bx
    1751:	58                   	pop    %ax
    1752:	66 89 ec             	mov    %ebp,%esp
    1755:	66 5d                	pop    %ebp
    1757:	66 c3                	retl   

00001759 <print_my_name>:
print_my_name():
    1759:	50                   	push   %ax
    175a:	53                   	push   %bx
    175b:	51                   	push   %cx
    175c:	52                   	push   %dx
    175d:	1e                   	push   %ds
    175e:	06                   	push   %es
    175f:	55                   	push   %bp
    1760:	b8 00 10             	mov    $0x1000,%ax
    1763:	8e c0                	mov    %ax,%es
    1765:	b8 08 40             	mov    $0x4008,%ax
    1768:	89 c5                	mov    %ax,%bp
    176a:	b4 13                	mov    $0x13,%ah
    176c:	b0 00                	mov    $0x0,%al
    176e:	b7 00                	mov    $0x0,%bh
    1770:	b3 0f                	mov    $0xf,%bl
    1772:	b9 19 00             	mov    $0x19,%cx
    1775:	b6 18                	mov    $0x18,%dh
    1777:	b2 01                	mov    $0x1,%dl
    1779:	cd 10                	int    $0x10
    177b:	5d                   	pop    %bp
    177c:	07                   	pop    %es
    177d:	1f                   	pop    %ds
    177e:	5a                   	pop    %dx
    177f:	59                   	pop    %cx
    1780:	5b                   	pop    %bx
    1781:	58                   	pop    %ax
    1782:	c3                   	ret    

00001783 <reboot>:
reboot():
    1783:	b4 06                	mov    $0x6,%ah
    1785:	b0 00                	mov    $0x0,%al
    1787:	b5 00                	mov    $0x0,%ch
    1789:	b1 00                	mov    $0x0,%cl
    178b:	b6 18                	mov    $0x18,%dh
    178d:	b2 4f                	mov    $0x4f,%dl
    178f:	b7 1f                	mov    $0x1f,%bh
    1791:	cd 10                	int    $0x10
    1793:	cd 19                	int    $0x19

00001795 <strlen>:
strlen():
/mnt/e/code/my_operating_system/os/service/../lib/string.c:3
#include "../include/type.h"

size_t strlen(char * str){
    1795:	67 66 8b 54 24 04    	mov    0x4(%esp),%edx
/mnt/e/code/my_operating_system/os/service/../lib/string.c:4
    u32 len = 0;
    179b:	66 b8 00 00 00 00    	mov    $0x0,%eax
/mnt/e/code/my_operating_system/os/service/../lib/string.c:5
    while (str[len] != 0){
    17a1:	eb 04                	jmp    17a7 <strlen+0x12>
/mnt/e/code/my_operating_system/os/service/../lib/string.c:6
        len++;
    17a3:	66 83 c0 01          	add    $0x1,%eax
/mnt/e/code/my_operating_system/os/service/../lib/string.c:5
#include "../include/type.h"

size_t strlen(char * str){
    u32 len = 0;
    while (str[len] != 0){
    17a7:	67 80 3c 02 00       	cmpb   $0x0,(%edx,%eax,1)
    17ac:	75 f5                	jne    17a3 <strlen+0xe>
/mnt/e/code/my_operating_system/os/service/../lib/string.c:9
        len++;
    }
    return len;
}
    17ae:	66 f3 c3             	repz retl 

000017b1 <strncpy>:
strncpy():
/mnt/e/code/my_operating_system/os/service/../lib/string.c:11

void strncpy(char * dest, char * src, u32 size){
    17b1:	66 56                	push   %esi
    17b3:	66 53                	push   %ebx
    17b5:	67 66 8b 5c 24 0c    	mov    0xc(%esp),%ebx
    17bb:	67 66 8b 74 24 10    	mov    0x10(%esp),%esi
    17c1:	67 66 8b 4c 24 14    	mov    0x14(%esp),%ecx
/mnt/e/code/my_operating_system/os/service/../lib/string.c:12
    for (int i = 0; i < size; i++){
    17c7:	66 b8 00 00 00 00    	mov    $0x0,%eax
    17cd:	eb 0e                	jmp    17dd <strncpy+0x2c>
/mnt/e/code/my_operating_system/os/service/../lib/string.c:13 (discriminator 3)
        dest[i] = src[i];
    17cf:	67 66 0f b6 14 06    	movzbl (%esi,%eax,1),%edx
    17d5:	67 88 14 03          	mov    %dl,(%ebx,%eax,1)
/mnt/e/code/my_operating_system/os/service/../lib/string.c:12 (discriminator 3)
    }
    return len;
}

void strncpy(char * dest, char * src, u32 size){
    for (int i = 0; i < size; i++){
    17d9:	66 83 c0 01          	add    $0x1,%eax
/mnt/e/code/my_operating_system/os/service/../lib/string.c:12 (discriminator 1)
    17dd:	66 39 c8             	cmp    %ecx,%eax
    17e0:	72 ed                	jb     17cf <strncpy+0x1e>
/mnt/e/code/my_operating_system/os/service/../lib/string.c:15
        dest[i] = src[i];
    }
    dest[size] = '\0';
    17e2:	67 c6 04 0b 00       	movb   $0x0,(%ebx,%ecx,1)
/mnt/e/code/my_operating_system/os/service/../lib/string.c:16
}
    17e7:	66 5b                	pop    %ebx
    17e9:	66 5e                	pop    %esi
    17eb:	66 c3                	retl   

000017ed <strcmp>:
strcmp():
/mnt/e/code/my_operating_system/os/service/../lib/string.c:18

int strcmp(char * lhs, char * rhs){
    17ed:	66 57                	push   %edi
    17ef:	66 56                	push   %esi
    17f1:	66 53                	push   %ebx
    17f3:	67 66 8b 74 24 10    	mov    0x10(%esp),%esi
    17f9:	67 66 8b 7c 24 14    	mov    0x14(%esp),%edi
/mnt/e/code/my_operating_system/os/service/../lib/string.c:19
    int lhs_len = strlen(lhs);
    17ff:	66 56                	push   %esi
    1801:	66 e8 8e ff ff ff    	calll  1795 <strlen>
    1807:	66 89 c3             	mov    %eax,%ebx
/mnt/e/code/my_operating_system/os/service/../lib/string.c:20
    int rhs_len = strlen(rhs);
    180a:	67 66 89 3c 24       	mov    %edi,(%esp)
    180f:	66 e8 80 ff ff ff    	calll  1795 <strlen>
    1815:	66 83 c4 04          	add    $0x4,%esp
/mnt/e/code/my_operating_system/os/service/../lib/string.c:21
    if (lhs_len != rhs_len){
    1819:	66 39 c3             	cmp    %eax,%ebx
    181c:	75 25                	jne    1843 <strcmp+0x56>
    181e:	66 b8 00 00 00 00    	mov    $0x0,%eax
    1824:	eb 10                	jmp    1836 <strcmp+0x49>
/mnt/e/code/my_operating_system/os/service/../lib/string.c:25
        return 1;
    }
    for (int i = 0; i < lhs_len; i++){
        if (lhs[i] != rhs[i])
    1826:	67 66 0f b6 14 07    	movzbl (%edi,%eax,1),%edx
    182c:	67 38 14 06          	cmp    %dl,(%esi,%eax,1)
    1830:	75 19                	jne    184b <strcmp+0x5e>
/mnt/e/code/my_operating_system/os/service/../lib/string.c:24 (discriminator 2)
    int lhs_len = strlen(lhs);
    int rhs_len = strlen(rhs);
    if (lhs_len != rhs_len){
        return 1;
    }
    for (int i = 0; i < lhs_len; i++){
    1832:	66 83 c0 01          	add    $0x1,%eax
/mnt/e/code/my_operating_system/os/service/../lib/string.c:24 (discriminator 1)
    1836:	66 39 d8             	cmp    %ebx,%eax
    1839:	7c eb                	jl     1826 <strcmp+0x39>
/mnt/e/code/my_operating_system/os/service/../lib/string.c:28
        if (lhs[i] != rhs[i])
            return 1;
    }
    return 0;
    183b:	66 b8 00 00 00 00    	mov    $0x0,%eax
    1841:	eb 0e                	jmp    1851 <strcmp+0x64>
/mnt/e/code/my_operating_system/os/service/../lib/string.c:22

int strcmp(char * lhs, char * rhs){
    int lhs_len = strlen(lhs);
    int rhs_len = strlen(rhs);
    if (lhs_len != rhs_len){
        return 1;
    1843:	66 b8 01 00 00 00    	mov    $0x1,%eax
    1849:	eb 06                	jmp    1851 <strcmp+0x64>
/mnt/e/code/my_operating_system/os/service/../lib/string.c:26
    }
    for (int i = 0; i < lhs_len; i++){
        if (lhs[i] != rhs[i])
            return 1;
    184b:	66 b8 01 00 00 00    	mov    $0x1,%eax
/mnt/e/code/my_operating_system/os/service/../lib/string.c:29
    }
    return 0;
}
    1851:	66 5b                	pop    %ebx
    1853:	66 5e                	pop    %esi
    1855:	66 5f                	pop    %edi
    1857:	66 c3                	retl   

00001859 <strncmp>:
strncmp():
/mnt/e/code/my_operating_system/os/service/../lib/string.c:31

int strncmp(char * lhs, char * rhs, int size){
    1859:	66 56                	push   %esi
    185b:	66 53                	push   %ebx
    185d:	67 66 8b 5c 24 0c    	mov    0xc(%esp),%ebx
    1863:	67 66 8b 4c 24 10    	mov    0x10(%esp),%ecx
    1869:	67 66 8b 74 24 14    	mov    0x14(%esp),%esi
/mnt/e/code/my_operating_system/os/service/../lib/string.c:32
    for (int i = 0; i < size; i++){
    186f:	66 b8 00 00 00 00    	mov    $0x0,%eax
    1875:	eb 10                	jmp    1887 <strncmp+0x2e>
/mnt/e/code/my_operating_system/os/service/../lib/string.c:33
        if (lhs[i] != rhs[i])
    1877:	67 66 0f b6 14 01    	movzbl (%ecx,%eax,1),%edx
    187d:	67 38 14 03          	cmp    %dl,(%ebx,%eax,1)
    1881:	75 11                	jne    1894 <strncmp+0x3b>
/mnt/e/code/my_operating_system/os/service/../lib/string.c:32 (discriminator 2)
    }
    return 0;
}

int strncmp(char * lhs, char * rhs, int size){
    for (int i = 0; i < size; i++){
    1883:	66 83 c0 01          	add    $0x1,%eax
/mnt/e/code/my_operating_system/os/service/../lib/string.c:32 (discriminator 1)
    1887:	66 39 f0             	cmp    %esi,%eax
    188a:	7c eb                	jl     1877 <strncmp+0x1e>
/mnt/e/code/my_operating_system/os/service/../lib/string.c:36
        if (lhs[i] != rhs[i])
            return 1;
    }
    return 0;
    188c:	66 b8 00 00 00 00    	mov    $0x0,%eax
    1892:	eb 06                	jmp    189a <strncmp+0x41>
/mnt/e/code/my_operating_system/os/service/../lib/string.c:34
}

int strncmp(char * lhs, char * rhs, int size){
    for (int i = 0; i < size; i++){
        if (lhs[i] != rhs[i])
            return 1;
    1894:	66 b8 01 00 00 00    	mov    $0x1,%eax
/mnt/e/code/my_operating_system/os/service/../lib/string.c:37
    }
    return 0;
    189a:	66 5b                	pop    %ebx
    189c:	66 5e                	pop    %esi
    189e:	66 c3                	retl   

000018a0 <move_name>:
move_name():
/mnt/e/code/my_operating_system/os/service/../lib/style.c:9

void move_name(){
    u16 *text_line = (u16*)(1920*2);
    // text_line 0-79
    // text_line[80]
    u16 last_char = text_line[79];
    18a0:	66 0f b7 0e 9e 0f    	movzwl 0xf9e,%ecx
/mnt/e/code/my_operating_system/os/service/../lib/style.c:10
    for (int i =78; i >= 0; i--){
    18a6:	66 b8 4e 00 00 00    	mov    $0x4e,%eax
    18ac:	eb 16                	jmp    18c4 <move_name+0x24>
/mnt/e/code/my_operating_system/os/service/../lib/style.c:11 (discriminator 3)
        text_line[i+1] = text_line[i];
    18ae:	67 66 0f b7 94 00 00 	movzwl 0xf00(%eax,%eax,1),%edx
    18b5:	0f 00 00 
    18b8:	67 89 94 00 02 0f 00 	mov    %dx,0xf02(%eax,%eax,1)
    18bf:	00 
/mnt/e/code/my_operating_system/os/service/../lib/style.c:10 (discriminator 3)
void move_name(){
    u16 *text_line = (u16*)(1920*2);
    // text_line 0-79
    // text_line[80]
    u16 last_char = text_line[79];
    for (int i =78; i >= 0; i--){
    18c0:	66 83 e8 01          	sub    $0x1,%eax
/mnt/e/code/my_operating_system/os/service/../lib/style.c:10 (discriminator 1)
    18c4:	66 85 c0             	test   %eax,%eax
    18c7:	79 e5                	jns    18ae <move_name+0xe>
/mnt/e/code/my_operating_system/os/service/../lib/style.c:13
        text_line[i+1] = text_line[i];
    }
    text_line[0] = last_char;
    18c9:	89 0e 00 0f          	mov    %cx,0xf00
    18cd:	66 c3                	retl   
