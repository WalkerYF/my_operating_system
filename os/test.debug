
kernel/kernel.debug:     file format elf32-i386


Disassembly of section .text:

00000000 <_start>:
       0:	e8 14 00             	call   17 <install_int40>
       3:	66 e8 4b 0d 00 00    	calll  d54 <cstart>

00000009 <start_tty>:
       9:	66 e8 ba 10 00 00    	calll  10c9 <tty>
       f:	b4 02                	mov    $0x2,%ah
      11:	cd 40                	int    $0x40
      13:	eb fe                	jmp    13 <user3_bound_x_up+0x6>
      15:	eb fe                	jmp    15 <user3_bound_x_up+0x8>

00000017 <install_int40>:
      17:	50                   	push   %ax
      18:	53                   	push   %bx
      19:	1e                   	push   %ds
      1a:	b8 00 00             	mov    $0x0,%ax
      1d:	8e d8                	mov    %ax,%ds
      1f:	8c c8                	mov    %cs,%ax
      21:	c7 06 00 01 2e 00    	movw   $0x2e,0x100
      27:	a3 02 01             	mov    %ax,0x102
      2a:	1f                   	pop    %ds
      2b:	5b                   	pop    %bx
      2c:	58                   	pop    %ax
      2d:	c3                   	ret    

0000002e <new_int40>:
      2e:	80 fc 4c             	cmp    $0x4c,%ah
      31:	74 11                	je     44 <new_int40.return_kernel>
      33:	88 e3                	mov    %ah,%bl
      35:	31 c0                	xor    %ax,%ax
      37:	b0 02                	mov    $0x2,%al
      39:	f6 e3                	mul    %bl
      3b:	89 c6                	mov    %ax,%si
      3d:	bb 20 28             	mov    $0x2820,%bx
      40:	66 ff 10             	calll  *(%bx,%si)
      43:	cf                   	iret   

00000044 <new_int40.return_kernel>:
      44:	59                   	pop    %cx
      45:	59                   	pop    %cx
      46:	59                   	pop    %cx
      47:	b8 00 10             	mov    $0x1000,%ax
      4a:	8e d8                	mov    %ax,%ds
      4c:	8e c0                	mov    %ax,%es
      4e:	8e d0                	mov    %ax,%ss
      50:	bc 00 50             	mov    $0x5000,%sp
      53:	51                   	push   %cx
      54:	68 00 10             	push   $0x1000
      57:	68 09 00             	push   $0x9
      5a:	fb                   	sti    
      5b:	cf                   	iret   

0000005c <install_int8>:
      5c:	50                   	push   %ax
      5d:	53                   	push   %bx
      5e:	51                   	push   %cx
      5f:	52                   	push   %dx
      60:	1e                   	push   %ds
      61:	06                   	push   %es
      62:	55                   	push   %bp
      63:	b0 34                	mov    $0x34,%al
      65:	e6 43                	out    %al,$0x43
      67:	b8 ff ff             	mov    $0xffff,%ax
      6a:	e6 40                	out    %al,$0x40
      6c:	88 e0                	mov    %ah,%al
      6e:	e6 40                	out    %al,$0x40
      70:	b8 00 00             	mov    $0x0,%ax
      73:	8e d8                	mov    %ax,%ds
      75:	8c c8                	mov    %cs,%ax
      77:	a3 22 00             	mov    %ax,0x22
      7a:	c7 06 20 00 88 00    	movw   $0x88,0x20
      80:	5d                   	pop    %bp
      81:	07                   	pop    %es
      82:	1f                   	pop    %ds
      83:	5a                   	pop    %dx
      84:	59                   	pop    %cx
      85:	5b                   	pop    %bx
      86:	58                   	pop    %ax
      87:	c3                   	ret    

00000088 <new_int8>:
      88:	06                   	push   %es
      89:	50                   	push   %ax
      8a:	53                   	push   %bx
      8b:	51                   	push   %cx
      8c:	52                   	push   %dx
      8d:	55                   	push   %bp
      8e:	1e                   	push   %ds
      8f:	b8 00 b8             	mov    $0xb800,%ax
      92:	8e d8                	mov    %ax,%ds
      94:	66 e8 2a 15 00 00    	calll  15c4 <move_name>
      9a:	b0 20                	mov    $0x20,%al
      9c:	e6 20                	out    %al,$0x20
      9e:	e6 a0                	out    %al,$0xa0
      a0:	1f                   	pop    %ds
      a1:	5d                   	pop    %bp
      a2:	5a                   	pop    %dx
      a3:	59                   	pop    %cx
      a4:	5b                   	pop    %bx
      a5:	58                   	pop    %ax
      a6:	07                   	pop    %es
      a7:	fb                   	sti    
      a8:	cf                   	iret   

000000a9 <_put_char>:
#include "../include/basic.h"
#include "../include/type.h"
#include "../include/string.h"

void _put_char(char c, u16 cursor_index){
      a9:	66 53                	push   %ebx
      ab:	66 83 ec 10          	sub    $0x10,%esp
    int _address = 0xb8000;
    int _offset = cursor_index * 2;
      af:	67 66 0f b7 5c 24 1c 	movzwl 0x1c(%esp),%ebx
      b6:	66 01 db             	add    %ebx,%ebx
    write_memory_byte(_address+_offset, c);
      b9:	67 66 8d 83 00 80 0b 	lea    0xb8000(%ebx),%eax
      c0:	00 
      c1:	67 66 0f b6 54 24 18 	movzbl 0x18(%esp),%edx
      c8:	66 52                	push   %edx
      ca:	66 50                	push   %eax
      cc:	66 e8 02 0a 00 00    	calll  ad4 <write_memory_byte>
    write_memory_byte(_address+_offset+1, 0x1f);
      d2:	66 81 c3 01 80 0b 00 	add    $0xb8001,%ebx
      d9:	66 83 c4 08          	add    $0x8,%esp
      dd:	66 6a 1f             	pushl  $0x1f
      e0:	66 53                	push   %ebx
      e2:	66 e8 ec 09 00 00    	calll  ad4 <write_memory_byte>
    return ;
}
      e8:	66 83 c4 18          	add    $0x18,%esp
      ec:	66 5b                	pop    %ebx
      ee:	66 c3                	retl   

000000f0 <set_cursor>:

void set_cursor(u16 cursor_index){
      f0:	66 56                	push   %esi
      f2:	66 53                	push   %ebx
      f4:	66 83 ec 0c          	sub    $0xc,%esp
      f8:	67 66 8b 5c 24 18    	mov    0x18(%esp),%ebx
    // short cursor_index = 80 * row + column;     // 计算光标寄存器的值
    u8 low_eight = cursor_index; // 取低八位，高位被截断
    u8 high_eight = cursor_index >> 8; // 取高八位
      fe:	66 89 d8             	mov    %ebx,%eax
     101:	c1 e8 08             	shr    $0x8,%ax
     104:	66 89 c6             	mov    %eax,%esi
    write_port_byte(0x3d4,0x0e);// 指定索引寄存器为光标寄存器的高八位
     107:	66 6a 0e             	pushl  $0xe
     10a:	66 68 d4 03 00 00    	pushl  $0x3d4
     110:	66 e8 6a 09 00 00    	calll  a80 <write_port_byte>
    write_port_byte(0x3d5, high_eight);// 将光标索引高八位写入端口
     116:	66 83 c4 08          	add    $0x8,%esp
     11a:	66 89 f0             	mov    %esi,%eax
     11d:	66 0f b6 f0          	movzbl %al,%esi
     121:	66 56                	push   %esi
     123:	66 68 d5 03 00 00    	pushl  $0x3d5
     129:	66 e8 51 09 00 00    	calll  a80 <write_port_byte>
    write_port_byte(0x3d4,0x0f);// 指定索引寄存器为光标寄存器的低八位
     12f:	66 83 c4 08          	add    $0x8,%esp
     133:	66 6a 0f             	pushl  $0xf
     136:	66 68 d4 03 00 00    	pushl  $0x3d4
     13c:	66 e8 3e 09 00 00    	calll  a80 <write_port_byte>
    write_port_byte(0x3d5, low_eight);// 将光标索引低八位写入端口
     142:	66 83 c4 08          	add    $0x8,%esp
     146:	66 0f b6 db          	movzbl %bl,%ebx
     14a:	66 53                	push   %ebx
     14c:	66 68 d5 03 00 00    	pushl  $0x3d5
     152:	66 e8 28 09 00 00    	calll  a80 <write_port_byte>
    return ;
}
     158:	66 83 c4 14          	add    $0x14,%esp
     15c:	66 5b                	pop    %ebx
     15e:	66 5e                	pop    %esi
     160:	66 c3                	retl   

00000162 <get_cursor>:

u16 get_cursor(){
     162:	66 53                	push   %ebx
     164:	66 83 ec 10          	sub    $0x10,%esp
    u8 low_eight = 0, high_eight = 0;
    u16 cursor_index = 0;
    write_port_byte(0x3d4,0x0e);// 指定索引寄存器为光标寄存器的高八位
     168:	66 6a 0e             	pushl  $0xe
     16b:	66 68 d4 03 00 00    	pushl  $0x3d4
     171:	66 e8 09 09 00 00    	calll  a80 <write_port_byte>
    high_eight = read_port_byte(0x3d5);// 将光标索引高八位写入端口
     177:	67 66 c7 04 24 d5 03 	movl   $0x3d5,(%esp)
     17e:	00 00 
     180:	66 e8 13 09 00 00    	calll  a99 <read_port_byte>
     186:	66 89 c3             	mov    %eax,%ebx
    write_port_byte(0x3d4,0x0f);// 指定索引寄存器为光标寄存器的低八位
     189:	66 83 c4 08          	add    $0x8,%esp
     18d:	66 6a 0f             	pushl  $0xf
     190:	66 68 d4 03 00 00    	pushl  $0x3d4
     196:	66 e8 e4 08 00 00    	calll  a80 <write_port_byte>
    low_eight = read_port_byte(0x3d5);// 将光标索引低八位写入端口
     19c:	67 66 c7 04 24 d5 03 	movl   $0x3d5,(%esp)
     1a3:	00 00 
     1a5:	66 e8 ee 08 00 00    	calll  a99 <read_port_byte>
    cursor_index = high_eight;
    cursor_index = (cursor_index << 8) + low_eight;
     1ab:	66 c1 e3 08          	shl    $0x8,%ebx
     1af:	66 0f b6 c0          	movzbl %al,%eax
     1b3:	66 01 d8             	add    %ebx,%eax
    return cursor_index;
}
     1b6:	66 83 c4 18          	add    $0x18,%esp
     1ba:	66 5b                	pop    %ebx
     1bc:	66 c3                	retl   

000001be <putc>:

void putc(char c){
     1be:	66 57                	push   %edi
     1c0:	66 56                	push   %esi
     1c2:	66 53                	push   %ebx
     1c4:	67 66 8b 7c 24 10    	mov    0x10(%esp),%edi
    u16 cursor_index = get_cursor();
     1ca:	66 e8 92 ff ff ff    	calll  162 <get_cursor>
     1d0:	66 89 c6             	mov    %eax,%esi
    u16 row = cursor_index / 80;
     1d3:	66 0f b7 d8          	movzwl %ax,%ebx
     1d7:	66 69 db cd cc 00 00 	imul   $0xcccd,%ebx,%ebx
     1de:	66 c1 eb 10          	shr    $0x10,%ebx
     1e2:	c1 eb 06             	shr    $0x6,%bx
    u16 col = cursor_index % 80;
    if (cursor_index >= 1920){
     1e5:	3d 7f 07             	cmp    $0x77f,%ax
     1e8:	76 0c                	jbe    1f6 <putc+0x38>
        scroll_screen();
     1ea:	66 e8 5e 09 00 00    	calll  b4e <scroll_screen>
        cursor_index = 1840;
     1f0:	66 be 30 07 00 00    	mov    $0x730,%esi
    }
    switch (c) {
     1f6:	66 89 f8             	mov    %edi,%eax
     1f9:	3c 0a                	cmp    $0xa,%al
     1fb:	74 06                	je     203 <putc+0x45>
     1fd:	3c 0d                	cmp    $0xd,%al
     1ff:	74 25                	je     226 <putc+0x68>
     201:	eb 45                	jmp    248 <putc+0x8a>
        case '\n':
            set_cursor((row+1)*80); // 回车，移到下一行
     203:	66 83 ec 0c          	sub    $0xc,%esp
     207:	67 66 8d 5c 9b 05    	lea    0x5(%ebx,%ebx,4),%ebx
     20d:	66 89 d8             	mov    %ebx,%eax
     210:	66 c1 e0 04          	shl    $0x4,%eax
     214:	66 0f b7 c0          	movzwl %ax,%eax
     218:	66 50                	push   %eax
     21a:	66 e8 d0 fe ff ff    	calll  f0 <set_cursor>
            break;
     220:	66 83 c4 10          	add    $0x10,%esp
     224:	eb 52                	jmp    278 <putc+0xba>
        case '\r':
            set_cursor(row*80);    // 移到本行开头处
     226:	66 83 ec 0c          	sub    $0xc,%esp
     22a:	67 66 8d 1c 9b       	lea    (%ebx,%ebx,4),%ebx
     22f:	66 89 d8             	mov    %ebx,%eax
     232:	66 c1 e0 04          	shl    $0x4,%eax
     236:	66 0f b7 c0          	movzwl %ax,%eax
     23a:	66 50                	push   %eax
     23c:	66 e8 ae fe ff ff    	calll  f0 <set_cursor>
            break;
     242:	66 83 c4 10          	add    $0x10,%esp
     246:	eb 30                	jmp    278 <putc+0xba>
        default:
            _put_char(c, cursor_index);
     248:	66 83 ec 08          	sub    $0x8,%esp
     24c:	66 0f b7 c6          	movzwl %si,%eax
     250:	66 50                	push   %eax
     252:	66 89 f8             	mov    %edi,%eax
     255:	66 0f be f8          	movsbl %al,%edi
     259:	66 57                	push   %edi
     25b:	66 e8 48 fe ff ff    	calll  a9 <_put_char>
            set_cursor(cursor_index+1);
     261:	66 83 c6 01          	add    $0x1,%esi
     265:	66 0f b7 f6          	movzwl %si,%esi
     269:	67 66 89 34 24       	mov    %esi,(%esp)
     26e:	66 e8 7c fe ff ff    	calll  f0 <set_cursor>
            break;
     274:	66 83 c4 10          	add    $0x10,%esp
    }
    return ;
}
     278:	66 5b                	pop    %ebx
     27a:	66 5e                	pop    %esi
     27c:	66 5f                	pop    %edi
     27e:	66 c3                	retl   

00000280 <_putc>:

void _putc(char c){
     280:	66 56                	push   %esi
     282:	66 53                	push   %ebx
     284:	66 83 ec 04          	sub    $0x4,%esp
     288:	67 66 8b 5c 24 10    	mov    0x10(%esp),%ebx
    u16 cursor_index = get_cursor();
     28e:	66 e8 ce fe ff ff    	calll  162 <get_cursor>
    u16 row = cursor_index / 80;
     294:	66 0f b7 d0          	movzwl %ax,%edx
     298:	66 69 d2 cd cc 00 00 	imul   $0xcccd,%edx,%edx
     29f:	66 c1 ea 10          	shr    $0x10,%edx
     2a3:	c1 ea 06             	shr    $0x6,%dx
    u16 col = cursor_index % 80;
     2a6:	67 66 8d 34 92       	lea    (%edx,%edx,4),%esi
     2ab:	66 c1 e6 04          	shl    $0x4,%esi
     2af:	66 89 f1             	mov    %esi,%ecx
     2b2:	66 89 c6             	mov    %eax,%esi
     2b5:	66 29 ce             	sub    %ecx,%esi
    switch (c) {
     2b8:	80 fb 0a             	cmp    $0xa,%bl
     2bb:	74 07                	je     2c4 <_putc+0x44>
     2bd:	80 fb 0d             	cmp    $0xd,%bl
     2c0:	74 2b                	je     2ed <_putc+0x6d>
     2c2:	eb 4b                	jmp    30f <_putc+0x8f>
     2c4:	66 89 f1             	mov    %esi,%ecx
        case '\n':
            set_cursor((row+1)*80+col); // 回车，移到下一行
     2c7:	66 83 ec 0c          	sub    $0xc,%esp
     2cb:	67 66 8d 54 92 05    	lea    0x5(%edx,%edx,4),%edx
     2d1:	66 89 d0             	mov    %edx,%eax
     2d4:	66 c1 e0 04          	shl    $0x4,%eax
     2d8:	66 01 c1             	add    %eax,%ecx
     2db:	66 0f b7 c9          	movzwl %cx,%ecx
     2df:	66 51                	push   %ecx
     2e1:	66 e8 09 fe ff ff    	calll  f0 <set_cursor>
            break;
     2e7:	66 83 c4 10          	add    $0x10,%esp
     2eb:	eb 3c                	jmp    329 <_putc+0xa9>
        case '\r':
            set_cursor(row*80);    // 移到本行开头处
     2ed:	66 83 ec 0c          	sub    $0xc,%esp
     2f1:	67 66 8d 14 92       	lea    (%edx,%edx,4),%edx
     2f6:	66 89 d0             	mov    %edx,%eax
     2f9:	66 c1 e0 04          	shl    $0x4,%eax
     2fd:	66 0f b7 c0          	movzwl %ax,%eax
     301:	66 50                	push   %eax
     303:	66 e8 e7 fd ff ff    	calll  f0 <set_cursor>
            break;
     309:	66 83 c4 10          	add    $0x10,%esp
     30d:	eb 1a                	jmp    329 <_putc+0xa9>
        default:
            _put_char(c, cursor_index);
     30f:	66 83 ec 08          	sub    $0x8,%esp
     313:	66 0f b7 c0          	movzwl %ax,%eax
     317:	66 50                	push   %eax
     319:	66 0f be db          	movsbl %bl,%ebx
     31d:	66 53                	push   %ebx
     31f:	66 e8 84 fd ff ff    	calll  a9 <_put_char>
            // set_cursor(cursor_index+1);
            break;
     325:	66 83 c4 10          	add    $0x10,%esp
    }
    return ;
}
     329:	66 83 c4 04          	add    $0x4,%esp
     32d:	66 5b                	pop    %ebx
     32f:	66 5e                	pop    %esi
     331:	66 c3                	retl   

00000333 <puti>:

void puti(u32 n){
     333:	66 56                	push   %esi
     335:	66 53                	push   %ebx
     337:	66 83 ec 44          	sub    $0x44,%esp
     33b:	67 66 8b 4c 24 50    	mov    0x50(%esp),%ecx
    int len = 0;
     341:	66 bb 00 00 00 00    	mov    $0x0,%ebx
    int num[INT_LENGTH];  // 临时存放各位数，从低位放到高位，之后倒序输出即可
    while (n != 0){
     347:	eb 2d                	jmp    376 <puti+0x43>
        num[len] = n % 10;
     349:	66 ba cd cc cc cc    	mov    $0xcccccccd,%edx
     34f:	66 89 c8             	mov    %ecx,%eax
     352:	66 f7 e2             	mul    %edx
     355:	66 c1 ea 03          	shr    $0x3,%edx
     359:	66 89 d6             	mov    %edx,%esi
     35c:	67 66 8d 14 92       	lea    (%edx,%edx,4),%edx
     361:	67 66 8d 04 12       	lea    (%edx,%edx,1),%eax
     366:	66 29 c1             	sub    %eax,%ecx
     369:	67 66 89 4c 9c 04    	mov    %ecx,0x4(%esp,%ebx,4)
        n = n / 10;
     36f:	66 89 f1             	mov    %esi,%ecx
        len++;
     372:	66 83 c3 01          	add    $0x1,%ebx
}

void puti(u32 n){
    int len = 0;
    int num[INT_LENGTH];  // 临时存放各位数，从低位放到高位，之后倒序输出即可
    while (n != 0){
     376:	66 85 c9             	test   %ecx,%ecx
     379:	75 ce                	jne    349 <puti+0x16>
        num[len] = n % 10;
        n = n / 10;
        len++;
    }
    for (int i = len-1; i >= 0; i--){
     37b:	66 83 eb 01          	sub    $0x1,%ebx
     37f:	eb 23                	jmp    3a4 <puti+0x71>
        putc(num[i]+'0');
     381:	66 83 ec 0c          	sub    $0xc,%esp
     385:	67 66 0f b6 44 9c 10 	movzbl 0x10(%esp,%ebx,4),%eax
     38c:	66 83 c0 30          	add    $0x30,%eax
     390:	66 0f be c0          	movsbl %al,%eax
     394:	66 50                	push   %eax
     396:	66 e8 22 fe ff ff    	calll  1be <putc>
    while (n != 0){
        num[len] = n % 10;
        n = n / 10;
        len++;
    }
    for (int i = len-1; i >= 0; i--){
     39c:	66 83 eb 01          	sub    $0x1,%ebx
     3a0:	66 83 c4 10          	add    $0x10,%esp
     3a4:	66 85 db             	test   %ebx,%ebx
     3a7:	79 d8                	jns    381 <puti+0x4e>
        putc(num[i]+'0');
    }
    return ;
}
     3a9:	66 83 c4 44          	add    $0x44,%esp
     3ad:	66 5b                	pop    %ebx
     3af:	66 5e                	pop    %esi
     3b1:	66 c3                	retl   

000003b3 <puts>:

void puts(char * str, int size){
     3b3:	66 57                	push   %edi
     3b5:	66 56                	push   %esi
     3b7:	66 53                	push   %ebx
     3b9:	67 66 8b 7c 24 10    	mov    0x10(%esp),%edi
     3bf:	67 66 8b 74 24 14    	mov    0x14(%esp),%esi
    int i = 0;
     3c5:	66 bb 00 00 00 00    	mov    $0x0,%ebx
    while (i < size){
     3cb:	eb 1a                	jmp    3e7 <puts+0x34>
        putc(str[i]);
     3cd:	66 83 ec 0c          	sub    $0xc,%esp
     3d1:	67 66 0f be 04 1f    	movsbl (%edi,%ebx,1),%eax
     3d7:	66 50                	push   %eax
     3d9:	66 e8 df fd ff ff    	calll  1be <putc>
        i++;
     3df:	66 83 c3 01          	add    $0x1,%ebx
     3e3:	66 83 c4 10          	add    $0x10,%esp
    return ;
}

void puts(char * str, int size){
    int i = 0;
    while (i < size){
     3e7:	66 39 f3             	cmp    %esi,%ebx
     3ea:	7c e1                	jl     3cd <puts+0x1a>
        putc(str[i]);
        i++;
    }
    return ;
}
     3ec:	66 5b                	pop    %ebx
     3ee:	66 5e                	pop    %esi
     3f0:	66 5f                	pop    %edi
     3f2:	66 c3                	retl   

000003f4 <sprintf>:



void sprintf(char * dest , char * format, ...){
     3f4:	66 55                	push   %ebp
     3f6:	66 57                	push   %edi
     3f8:	66 56                	push   %esi
     3fa:	66 53                	push   %ebx
     3fc:	66 83 ec 5c          	sub    $0x5c,%esp
     400:	67 66 8b 6c 24 70    	mov    0x70(%esp),%ebp
    int arg_num = 0;
    int src_index = 0;   // 源字符串索引，总是指向未读的一位
    int des_index = 0;   // 目标字符串索引，总是指向未写的一位。
     406:	66 bb 00 00 00 00    	mov    $0x0,%ebx



void sprintf(char * dest , char * format, ...){
    int arg_num = 0;
    int src_index = 0;   // 源字符串索引，总是指向未读的一位
     40c:	66 bf 00 00 00 00    	mov    $0x0,%edi
}



void sprintf(char * dest , char * format, ...){
    int arg_num = 0;
     412:	66 ba 00 00 00 00    	mov    $0x0,%edx
    int src_index = 0;   // 源字符串索引，总是指向未读的一位
    int des_index = 0;   // 目标字符串索引，总是指向未写的一位。
    int* arg_addr = &format+1; // 边长参数第一个参数的地址。
    while (format[src_index] != 0){
     418:	e9 33 01             	jmp    54e <sprintf+0x15a>
        if (format[src_index] == '%'){
     41b:	3c 25                	cmp    $0x25,%al
     41d:	0f 85 1b 01          	jne    53c <sprintf+0x148>
            src_index++;
            switch(format[src_index]){
     421:	67 66 0f b6 44 39 01 	movzbl 0x1(%ecx,%edi,1),%eax
     428:	3c 64                	cmp    $0x64,%al
     42a:	74 28                	je     454 <sprintf+0x60>
     42c:	3c 73                	cmp    $0x73,%al
     42e:	0f 84 b5 00          	je     4e7 <sprintf+0xf3>
     432:	3c 63                	cmp    $0x63,%al
     434:	0f 85 fe 00          	jne    536 <sprintf+0x142>
                case 'c':{
                    dest[des_index++] =*(arg_addr + arg_num++);
     438:	67 66 8b 44 94 78    	mov    0x78(%esp,%edx,4),%eax
     43e:	67 88 44 1d 00       	mov    %al,0x0(%ebp,%ebx,1)
                    src_index++;
     443:	66 83 c7 02          	add    $0x2,%edi
    while (format[src_index] != 0){
        if (format[src_index] == '%'){
            src_index++;
            switch(format[src_index]){
                case 'c':{
                    dest[des_index++] =*(arg_addr + arg_num++);
     447:	67 66 8d 5b 01       	lea    0x1(%ebx),%ebx
     44c:	67 66 8d 52 01       	lea    0x1(%edx),%edx
                    src_index++;
                    break;
     451:	e9 fa 00             	jmp    54e <sprintf+0x15a>
                }
                case 'd':{
                    int n = *(arg_addr + arg_num++);
     454:	67 66 8d 42 01       	lea    0x1(%edx),%eax
     459:	67 66 89 44 24 08    	mov    %eax,0x8(%esp)
     45f:	67 66 8b 4c 94 78    	mov    0x78(%esp,%edx,4),%ecx
                    int len = 0; 
     465:	66 be 00 00 00 00    	mov    $0x0,%esi
     46b:	67 66 89 7c 24 0c    	mov    %edi,0xc(%esp)
                    int num[INT_LENGTH];
                    while (n != 0){
     471:	eb 37                	jmp    4aa <sprintf+0xb6>
                        num[len] = n % 10;
     473:	66 ba 67 66 66 66    	mov    $0x66666667,%edx
     479:	66 89 c8             	mov    %ecx,%eax
     47c:	66 f7 ea             	imul   %edx
     47f:	66 c1 fa 02          	sar    $0x2,%edx
     483:	66 89 c8             	mov    %ecx,%eax
     486:	66 c1 f8 1f          	sar    $0x1f,%eax
     48a:	66 29 c2             	sub    %eax,%edx
     48d:	66 89 d7             	mov    %edx,%edi
     490:	67 66 8d 14 92       	lea    (%edx,%edx,4),%edx
     495:	67 66 8d 04 12       	lea    (%edx,%edx,1),%eax
     49a:	66 29 c1             	sub    %eax,%ecx
     49d:	67 66 89 4c b4 14    	mov    %ecx,0x14(%esp,%esi,4)
                        n = n / 10;
     4a3:	66 89 f9             	mov    %edi,%ecx
                        len++;
     4a6:	66 83 c6 01          	add    $0x1,%esi
                }
                case 'd':{
                    int n = *(arg_addr + arg_num++);
                    int len = 0; 
                    int num[INT_LENGTH];
                    while (n != 0){
     4aa:	66 85 c9             	test   %ecx,%ecx
     4ad:	75 c4                	jne    473 <sprintf+0x7f>
     4af:	67 66 8b 7c 24 0c    	mov    0xc(%esp),%edi
                        num[len] = n % 10;
                        n = n / 10;
                        len++;
                    }
                    for (int i = len-1; i >= 0; i--){
     4b5:	67 66 8d 46 ff       	lea    -0x1(%esi),%eax
     4ba:	eb 1a                	jmp    4d6 <sprintf+0xe2>
                        dest[des_index++] = num[i]+'0';
     4bc:	67 66 0f b6 74 84 14 	movzbl 0x14(%esp,%eax,4),%esi
     4c3:	67 66 8d 56 30       	lea    0x30(%esi),%edx
     4c8:	67 88 54 1d 00       	mov    %dl,0x0(%ebp,%ebx,1)
                    while (n != 0){
                        num[len] = n % 10;
                        n = n / 10;
                        len++;
                    }
                    for (int i = len-1; i >= 0; i--){
     4cd:	66 83 e8 01          	sub    $0x1,%eax
                        dest[des_index++] = num[i]+'0';
     4d1:	67 66 8d 5b 01       	lea    0x1(%ebx),%ebx
                    while (n != 0){
                        num[len] = n % 10;
                        n = n / 10;
                        len++;
                    }
                    for (int i = len-1; i >= 0; i--){
     4d6:	66 85 c0             	test   %eax,%eax
     4d9:	79 e1                	jns    4bc <sprintf+0xc8>
                        dest[des_index++] = num[i]+'0';
                    }
                    src_index++;
     4db:	66 83 c7 02          	add    $0x2,%edi
                    dest[des_index++] =*(arg_addr + arg_num++);
                    src_index++;
                    break;
                }
                case 'd':{
                    int n = *(arg_addr + arg_num++);
     4df:	67 66 8b 54 24 08    	mov    0x8(%esp),%edx
     4e5:	eb 67                	jmp    54e <sprintf+0x15a>
                    }
                    src_index++;
                    break;
                }
                case 's':{
                    char * str = *(arg_addr + arg_num++);
     4e7:	67 66 8d 42 01       	lea    0x1(%edx),%eax
     4ec:	67 66 89 44 24 08    	mov    %eax,0x8(%esp)
     4f2:	67 66 8b 74 94 78    	mov    0x78(%esp,%edx,4),%esi
                    u32 str_len = strlen(str);
     4f8:	66 83 ec 0c          	sub    $0xc,%esp
     4fc:	66 56                	push   %esi
     4fe:	66 e8 ea 06 00 00    	calll  bee <strlen>
                    u32 i = 0;
                    while (i < str_len){
     504:	66 83 c4 10          	add    $0x10,%esp
                    break;
                }
                case 's':{
                    char * str = *(arg_addr + arg_num++);
                    u32 str_len = strlen(str);
                    u32 i = 0;
     508:	66 ba 00 00 00 00    	mov    $0x0,%edx
                    while (i < str_len){
     50e:	eb 15                	jmp    525 <sprintf+0x131>
                        dest[des_index++] = str[i++];
     510:	67 66 0f b6 0c 16    	movzbl (%esi,%edx,1),%ecx
     516:	67 88 4c 1d 00       	mov    %cl,0x0(%ebp,%ebx,1)
     51b:	67 66 8d 52 01       	lea    0x1(%edx),%edx
     520:	67 66 8d 5b 01       	lea    0x1(%ebx),%ebx
                }
                case 's':{
                    char * str = *(arg_addr + arg_num++);
                    u32 str_len = strlen(str);
                    u32 i = 0;
                    while (i < str_len){
     525:	66 39 c2             	cmp    %eax,%edx
     528:	72 e6                	jb     510 <sprintf+0x11c>
                        dest[des_index++] = str[i++];
                    }
                    src_index++;
     52a:	66 83 c7 02          	add    $0x2,%edi
                    }
                    src_index++;
                    break;
                }
                case 's':{
                    char * str = *(arg_addr + arg_num++);
     52e:	67 66 8b 54 24 08    	mov    0x8(%esp),%edx
                    u32 i = 0;
                    while (i < str_len){
                        dest[des_index++] = str[i++];
                    }
                    src_index++;
                    break;
     534:	eb 18                	jmp    54e <sprintf+0x15a>
                }
                default :
                    src_index++;
     536:	66 83 c7 02          	add    $0x2,%edi
                    break;
     53a:	eb 12                	jmp    54e <sprintf+0x15a>
            }
        }
        else if (format[src_index] == '\\') {
     53c:	3c 5c                	cmp    $0x5c,%al
     53e:	74 0e                	je     54e <sprintf+0x15a>
                        break;
                }
            }
        }
        else {
            dest[des_index++] = format[src_index++];
     540:	66 83 c7 01          	add    $0x1,%edi
     544:	67 88 44 1d 00       	mov    %al,0x0(%ebp,%ebx,1)
     549:	67 66 8d 5b 01       	lea    0x1(%ebx),%ebx
void sprintf(char * dest , char * format, ...){
    int arg_num = 0;
    int src_index = 0;   // 源字符串索引，总是指向未读的一位
    int des_index = 0;   // 目标字符串索引，总是指向未写的一位。
    int* arg_addr = &format+1; // 边长参数第一个参数的地址。
    while (format[src_index] != 0){
     54e:	67 66 8b 4c 24 74    	mov    0x74(%esp),%ecx
     554:	67 66 0f b6 04 39    	movzbl (%ecx,%edi,1),%eax
     55a:	84 c0                	test   %al,%al
     55c:	0f 85 bb fe          	jne    41b <sprintf+0x27>
        }
        else {
            dest[des_index++] = format[src_index++];
        }
    }
    dest[des_index] = 0;
     560:	67 c6 44 1d 00 00    	movb   $0x0,0x0(%ebp,%ebx,1)
    return ;
}
     566:	66 83 c4 5c          	add    $0x5c,%esp
     56a:	66 5b                	pop    %ebx
     56c:	66 5e                	pop    %esi
     56e:	66 5f                	pop    %edi
     570:	66 5d                	pop    %ebp
     572:	66 c3                	retl   

00000574 <vprintf>:


void vprintf(char * format, va_list va){
     574:	66 55                	push   %ebp
     576:	66 57                	push   %edi
     578:	66 56                	push   %esi
     57a:	66 53                	push   %ebx
     57c:	66 81 ec 5c 04 00 00 	sub    $0x45c,%esp
     583:	67 66 8b ac 24 70 04 	mov    0x470(%esp),%ebp
     58a:	00 00 
    char buf[BUF_LENGTH];
    int arg_num = 0;
    int src_index = 0;   // 源字符串索引，总是指向未读的一位
    int des_index = 0;   // 目标字符串索引，总是指向未写的一位。
     58c:	66 bb 00 00 00 00    	mov    $0x0,%ebx


void vprintf(char * format, va_list va){
    char buf[BUF_LENGTH];
    int arg_num = 0;
    int src_index = 0;   // 源字符串索引，总是指向未读的一位
     592:	66 bf 00 00 00 00    	mov    $0x0,%edi
}


void vprintf(char * format, va_list va){
    char buf[BUF_LENGTH];
    int arg_num = 0;
     598:	66 ba 00 00 00 00    	mov    $0x0,%edx
    int src_index = 0;   // 源字符串索引，总是指向未读的一位
    int des_index = 0;   // 目标字符串索引，总是指向未写的一位。
    int* arg_addr = va; // 边长参数第一个参数的地址。
    while (format[src_index] != 0){
     59e:	e9 4c 01             	jmp    6ed <vprintf+0x179>
        if (format[src_index] == '%'){
     5a1:	3c 25                	cmp    $0x25,%al
     5a3:	0f 85 34 01          	jne    6db <vprintf+0x167>
            src_index++;
            switch(format[src_index]){
     5a7:	67 66 0f b6 44 3d 01 	movzbl 0x1(%ebp,%edi,1),%eax
     5ae:	3c 64                	cmp    $0x64,%al
     5b0:	74 30                	je     5e2 <vprintf+0x6e>
     5b2:	3c 73                	cmp    $0x73,%al
     5b4:	0f 84 c6 00          	je     67e <vprintf+0x10a>
     5b8:	3c 63                	cmp    $0x63,%al
     5ba:	0f 85 17 01          	jne    6d5 <vprintf+0x161>
                case 'c':{
                    buf[des_index++] =*(arg_addr + arg_num++);
     5be:	67 66 8b 84 24 74 04 	mov    0x474(%esp),%eax
     5c5:	00 00 
     5c7:	67 66 8b 04 90       	mov    (%eax,%edx,4),%eax
     5cc:	67 88 44 1c 50       	mov    %al,0x50(%esp,%ebx,1)
                    src_index++;
     5d1:	66 83 c7 02          	add    $0x2,%edi
    while (format[src_index] != 0){
        if (format[src_index] == '%'){
            src_index++;
            switch(format[src_index]){
                case 'c':{
                    buf[des_index++] =*(arg_addr + arg_num++);
     5d5:	67 66 8d 5b 01       	lea    0x1(%ebx),%ebx
     5da:	67 66 8d 52 01       	lea    0x1(%edx),%edx
                    src_index++;
                    break;
     5df:	e9 0b 01             	jmp    6ed <vprintf+0x179>
                }
                case 'd':{
                    int n = *(arg_addr + arg_num++);
     5e2:	67 66 8d 42 01       	lea    0x1(%edx),%eax
     5e7:	67 66 89 44 24 08    	mov    %eax,0x8(%esp)
     5ed:	67 66 8b 84 24 74 04 	mov    0x474(%esp),%eax
     5f4:	00 00 
     5f6:	67 66 8b 34 90       	mov    (%eax,%edx,4),%esi
                    int len = 0; 
     5fb:	66 b9 00 00 00 00    	mov    $0x0,%ecx
     601:	67 66 89 7c 24 0c    	mov    %edi,0xc(%esp)
                    int num[INT_LENGTH];
                    while (n != 0){
     607:	eb 3a                	jmp    643 <vprintf+0xcf>
                        num[len] = n % 10;
     609:	66 ba 67 66 66 66    	mov    $0x66666667,%edx
     60f:	66 89 f0             	mov    %esi,%eax
     612:	66 f7 ea             	imul   %edx
     615:	66 c1 fa 02          	sar    $0x2,%edx
     619:	66 89 f0             	mov    %esi,%eax
     61c:	66 c1 f8 1f          	sar    $0x1f,%eax
     620:	66 29 c2             	sub    %eax,%edx
     623:	66 89 d7             	mov    %edx,%edi
     626:	67 66 8d 14 92       	lea    (%edx,%edx,4),%edx
     62b:	67 66 8d 04 12       	lea    (%edx,%edx,1),%eax
     630:	66 89 f2             	mov    %esi,%edx
     633:	66 29 c2             	sub    %eax,%edx
     636:	67 66 89 54 8c 14    	mov    %edx,0x14(%esp,%ecx,4)
                        n = n / 10;
     63c:	66 89 fe             	mov    %edi,%esi
                        len++;
     63f:	66 83 c1 01          	add    $0x1,%ecx
                }
                case 'd':{
                    int n = *(arg_addr + arg_num++);
                    int len = 0; 
                    int num[INT_LENGTH];
                    while (n != 0){
     643:	66 85 f6             	test   %esi,%esi
     646:	75 c1                	jne    609 <vprintf+0x95>
     648:	67 66 8b 7c 24 0c    	mov    0xc(%esp),%edi
                        num[len] = n % 10;
                        n = n / 10;
                        len++;
                    }
                    for (int i = len-1; i >= 0; i--){
     64e:	66 83 e9 01          	sub    $0x1,%ecx
     652:	eb 19                	jmp    66d <vprintf+0xf9>
                        buf[des_index++] = num[i]+'0';
     654:	67 66 0f b6 44 8c 14 	movzbl 0x14(%esp,%ecx,4),%eax
     65b:	66 83 c0 30          	add    $0x30,%eax
     65f:	67 88 44 1c 50       	mov    %al,0x50(%esp,%ebx,1)
                    while (n != 0){
                        num[len] = n % 10;
                        n = n / 10;
                        len++;
                    }
                    for (int i = len-1; i >= 0; i--){
     664:	66 83 e9 01          	sub    $0x1,%ecx
                        buf[des_index++] = num[i]+'0';
     668:	67 66 8d 5b 01       	lea    0x1(%ebx),%ebx
                    while (n != 0){
                        num[len] = n % 10;
                        n = n / 10;
                        len++;
                    }
                    for (int i = len-1; i >= 0; i--){
     66d:	66 85 c9             	test   %ecx,%ecx
     670:	79 e2                	jns    654 <vprintf+0xe0>
                        buf[des_index++] = num[i]+'0';
                    }
                    src_index++;
     672:	66 83 c7 02          	add    $0x2,%edi
                    buf[des_index++] =*(arg_addr + arg_num++);
                    src_index++;
                    break;
                }
                case 'd':{
                    int n = *(arg_addr + arg_num++);
     676:	67 66 8b 54 24 08    	mov    0x8(%esp),%edx
     67c:	eb 6f                	jmp    6ed <vprintf+0x179>
                    }
                    src_index++;
                    break;
                }
                case 's':{
                    char * str = *(arg_addr + arg_num++);
     67e:	67 66 8d 42 01       	lea    0x1(%edx),%eax
     683:	67 66 89 44 24 08    	mov    %eax,0x8(%esp)
     689:	67 66 8b 84 24 74 04 	mov    0x474(%esp),%eax
     690:	00 00 
     692:	67 66 8b 34 90       	mov    (%eax,%edx,4),%esi
                    u32 str_len = strlen(str);
     697:	66 83 ec 0c          	sub    $0xc,%esp
     69b:	66 56                	push   %esi
     69d:	66 e8 4b 05 00 00    	calll  bee <strlen>
                    u32 i = 0;
                    while (i < str_len){
     6a3:	66 83 c4 10          	add    $0x10,%esp
                    break;
                }
                case 's':{
                    char * str = *(arg_addr + arg_num++);
                    u32 str_len = strlen(str);
                    u32 i = 0;
     6a7:	66 ba 00 00 00 00    	mov    $0x0,%edx
                    while (i < str_len){
     6ad:	eb 15                	jmp    6c4 <vprintf+0x150>
                        buf[des_index++] = str[i++];
     6af:	67 66 0f b6 0c 16    	movzbl (%esi,%edx,1),%ecx
     6b5:	67 88 4c 1c 50       	mov    %cl,0x50(%esp,%ebx,1)
     6ba:	67 66 8d 52 01       	lea    0x1(%edx),%edx
     6bf:	67 66 8d 5b 01       	lea    0x1(%ebx),%ebx
                }
                case 's':{
                    char * str = *(arg_addr + arg_num++);
                    u32 str_len = strlen(str);
                    u32 i = 0;
                    while (i < str_len){
     6c4:	66 39 c2             	cmp    %eax,%edx
     6c7:	72 e6                	jb     6af <vprintf+0x13b>
                        buf[des_index++] = str[i++];
                    }
                    src_index++;
     6c9:	66 83 c7 02          	add    $0x2,%edi
                    }
                    src_index++;
                    break;
                }
                case 's':{
                    char * str = *(arg_addr + arg_num++);
     6cd:	67 66 8b 54 24 08    	mov    0x8(%esp),%edx
                    u32 i = 0;
                    while (i < str_len){
                        buf[des_index++] = str[i++];
                    }
                    src_index++;
                    break;
     6d3:	eb 18                	jmp    6ed <vprintf+0x179>
                }
                default :
                    src_index++;
     6d5:	66 83 c7 02          	add    $0x2,%edi
                    break;
     6d9:	eb 12                	jmp    6ed <vprintf+0x179>
            }
        }
        else if (format[src_index] == '\\') {
     6db:	3c 5c                	cmp    $0x5c,%al
     6dd:	74 0e                	je     6ed <vprintf+0x179>
                        break;
                }
            }
        }
        else {
            buf[des_index++] = format[src_index++];
     6df:	66 83 c7 01          	add    $0x1,%edi
     6e3:	67 88 44 1c 50       	mov    %al,0x50(%esp,%ebx,1)
     6e8:	67 66 8d 5b 01       	lea    0x1(%ebx),%ebx
    char buf[BUF_LENGTH];
    int arg_num = 0;
    int src_index = 0;   // 源字符串索引，总是指向未读的一位
    int des_index = 0;   // 目标字符串索引，总是指向未写的一位。
    int* arg_addr = va; // 边长参数第一个参数的地址。
    while (format[src_index] != 0){
     6ed:	67 66 0f b6 44 3d 00 	movzbl 0x0(%ebp,%edi,1),%eax
     6f4:	84 c0                	test   %al,%al
     6f6:	0f 85 a7 fe          	jne    5a1 <vprintf+0x2d>
        }
        else {
            buf[des_index++] = format[src_index++];
        }
    }
    buf[des_index] = 0;
     6fa:	67 c6 44 1c 50 00    	movb   $0x0,0x50(%esp,%ebx,1)
    for (int i = 0; i < des_index; i++){
     700:	66 be 00 00 00 00    	mov    $0x0,%esi
     706:	eb 1b                	jmp    723 <vprintf+0x1af>
        putc(buf[i]);
     708:	66 83 ec 0c          	sub    $0xc,%esp
     70c:	67 66 0f be 44 34 5c 	movsbl 0x5c(%esp,%esi,1),%eax
     713:	66 50                	push   %eax
     715:	66 e8 a3 fa ff ff    	calll  1be <putc>
        else {
            buf[des_index++] = format[src_index++];
        }
    }
    buf[des_index] = 0;
    for (int i = 0; i < des_index; i++){
     71b:	66 83 c6 01          	add    $0x1,%esi
     71f:	66 83 c4 10          	add    $0x10,%esp
     723:	66 39 f3             	cmp    %esi,%ebx
     726:	7f e0                	jg     708 <vprintf+0x194>
        putc(buf[i]);
    }
    return ;
}
     728:	66 81 c4 5c 04 00 00 	add    $0x45c,%esp
     72f:	66 5b                	pop    %ebx
     731:	66 5e                	pop    %esi
     733:	66 5f                	pop    %edi
     735:	66 5d                	pop    %ebp
     737:	66 c3                	retl   

00000739 <printf>:

void printf(char * format, ...){
     739:	66 83 ec 14          	sub    $0x14,%esp
    vprintf(format, &format+1);// 其实这里由于format是个指针，是32位的，所以这里对format的地址+1，也会加4个字节。
     73d:	67 66 8d 44 24 1c    	lea    0x1c(%esp),%eax
     743:	66 50                	push   %eax
     745:	67 66 ff 74 24 1c    	pushl  0x1c(%esp)
     74b:	66 e8 23 fe ff ff    	calll  574 <vprintf>
    return ;
}
     751:	66 83 c4 1c          	add    $0x1c,%esp
     755:	66 c3                	retl   

00000757 <isalpha>:
//     return ;
// }



int isalpha (int ch){
     757:	67 66 8b 44 24 04    	mov    0x4(%esp),%eax
    if ('a' <= ch && ch <= 'z')
     75d:	67 66 8d 50 9f       	lea    -0x61(%eax),%edx
     762:	66 83 fa 19          	cmp    $0x19,%edx
     766:	76 12                	jbe    77a <isalpha+0x23>
        return 1;
    if ('A' <= ch && ch <= 'Z')
     768:	66 83 e8 41          	sub    $0x41,%eax
     76c:	66 83 f8 19          	cmp    $0x19,%eax
     770:	77 10                	ja     782 <isalpha+0x2b>
        return 1;
     772:	66 b8 01 00 00 00    	mov    $0x1,%eax
     778:	66 c3                	retl   



int isalpha (int ch){
    if ('a' <= ch && ch <= 'z')
        return 1;
     77a:	66 b8 01 00 00 00    	mov    $0x1,%eax
     780:	66 c3                	retl   
    if ('A' <= ch && ch <= 'Z')
        return 1;
    return 0;
     782:	66 b8 00 00 00 00    	mov    $0x0,%eax
}
     788:	66 c3                	retl   

0000078a <isdigit>:
int isdigit (int ch){
    if ('0' <= ch && ch <= '9')
     78a:	67 66 8b 44 24 04    	mov    0x4(%esp),%eax
     790:	66 83 e8 30          	sub    $0x30,%eax
     794:	66 83 f8 09          	cmp    $0x9,%eax
     798:	77 08                	ja     7a2 <isdigit+0x18>
        return 1;
     79a:	66 b8 01 00 00 00    	mov    $0x1,%eax
     7a0:	66 c3                	retl   
    return 0;
     7a2:	66 b8 00 00 00 00    	mov    $0x0,%eax
}
     7a8:	66 c3                	retl   

000007aa <isalnum>:

int isalnum (int ch){
     7aa:	66 53                	push   %ebx
     7ac:	67 66 8b 5c 24 08    	mov    0x8(%esp),%ebx
    if ( isalpha(ch) || isdigit(ch) ){
     7b2:	66 53                	push   %ebx
     7b4:	66 e8 9d ff ff ff    	calll  757 <isalpha>
     7ba:	66 83 c4 04          	add    $0x4,%esp
     7be:	66 85 c0             	test   %eax,%eax
     7c1:	75 13                	jne    7d6 <isalnum+0x2c>
     7c3:	66 53                	push   %ebx
     7c5:	66 e8 bf ff ff ff    	calll  78a <isdigit>
     7cb:	66 83 c4 04          	add    $0x4,%esp
     7cf:	66 85 c0             	test   %eax,%eax
     7d2:	75 0a                	jne    7de <isalnum+0x34>
     7d4:	eb 0e                	jmp    7e4 <isalnum+0x3a>
        return 1;
     7d6:	66 b8 01 00 00 00    	mov    $0x1,%eax
     7dc:	eb 06                	jmp    7e4 <isalnum+0x3a>
     7de:	66 b8 01 00 00 00    	mov    $0x1,%eax
    }
    return 0;
}
     7e4:	66 5b                	pop    %ebx
     7e6:	66 c3                	retl   

000007e8 <ispunct>:
int ispunct (int ch){
     7e8:	66 83 ec 30          	sub    $0x30,%esp
     7ec:	67 66 8b 4c 24 34    	mov    0x34(%esp),%ecx
    char punct[34] =  "!\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~";
     7f2:	67 66 c7 44 24 0e 21 	movl   $0x24232221,0xe(%esp)
     7f9:	22 23 24 
     7fc:	67 66 c7 44 24 12 25 	movl   $0x28272625,0x12(%esp)
     803:	26 27 28 
     806:	67 66 c7 44 24 16 29 	movl   $0x2c2b2a29,0x16(%esp)
     80d:	2a 2b 2c 
     810:	67 66 c7 44 24 1a 2d 	movl   $0x3a2f2e2d,0x1a(%esp)
     817:	2e 2f 3a 
     81a:	67 66 c7 44 24 1e 3b 	movl   $0x3e3d3c3b,0x1e(%esp)
     821:	3c 3d 3e 
     824:	67 66 c7 44 24 22 3f 	movl   $0x5c5b403f,0x22(%esp)
     82b:	40 5b 5c 
     82e:	67 66 c7 44 24 26 5d 	movl   $0x605f5e5d,0x26(%esp)
     835:	5e 5f 60 
     838:	67 66 c7 44 24 2a 7b 	movl   $0x7e7d7c7b,0x2a(%esp)
     83f:	7c 7d 7e 
     842:	67 c7 44 24 2e 00 00 	movw   $0x0,0x2e(%esp)
    for (int i = 0; i < 33; i++){
     849:	66 b8 00 00 00 00    	mov    $0x0,%eax
     84f:	eb 10                	jmp    861 <loader_code_segment+0x61>
        if (ch == punct[i])
     851:	67 66 0f be 54 04 0e 	movsbl 0xe(%esp,%eax,1),%edx
     858:	66 39 ca             	cmp    %ecx,%edx
     85b:	74 12                	je     86f <loader_code_segment+0x6f>
    }
    return 0;
}
int ispunct (int ch){
    char punct[34] =  "!\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~";
    for (int i = 0; i < 33; i++){
     85d:	66 83 c0 01          	add    $0x1,%eax
     861:	66 83 f8 20          	cmp    $0x20,%eax
     865:	7e ea                	jle    851 <loader_code_segment+0x51>
        if (ch == punct[i])
            return 1;
    }
    return 0;
     867:	66 b8 00 00 00 00    	mov    $0x0,%eax
     86d:	eb 06                	jmp    875 <loader_code_segment+0x75>
}
int ispunct (int ch){
    char punct[34] =  "!\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~";
    for (int i = 0; i < 33; i++){
        if (ch == punct[i])
            return 1;
     86f:	66 b8 01 00 00 00    	mov    $0x1,%eax
    }
    return 0;
}
     875:	66 83 c4 30          	add    $0x30,%esp
     879:	66 c3                	retl   

0000087b <isblank>:
int isblank (int ch){
    if (ch == ' ')
     87b:	67 66 83 7c 24 04 20 	cmpl   $0x20,0x4(%esp)
     882:	75 08                	jne    88c <isblank+0x11>
        return 1;
     884:	66 b8 01 00 00 00    	mov    $0x1,%eax
     88a:	66 c3                	retl   
    return 0;
     88c:	66 b8 00 00 00 00    	mov    $0x0,%eax
}
     892:	66 c3                	retl   

00000894 <isprint>:
int isprint (int ch){
     894:	66 53                	push   %ebx
     896:	67 66 8b 5c 24 08    	mov    0x8(%esp),%ebx
    if (isalpha(ch) || isdigit(ch) || isalnum(ch) || ispunct(ch) || isblank(ch)){
     89c:	66 53                	push   %ebx
     89e:	66 e8 b3 fe ff ff    	calll  757 <isalpha>
     8a4:	66 83 c4 04          	add    $0x4,%esp
     8a8:	66 85 c0             	test   %eax,%eax
     8ab:	75 46                	jne    8f3 <isprint+0x5f>
     8ad:	66 53                	push   %ebx
     8af:	66 e8 d5 fe ff ff    	calll  78a <isdigit>
     8b5:	66 83 c4 04          	add    $0x4,%esp
     8b9:	66 85 c0             	test   %eax,%eax
     8bc:	75 3d                	jne    8fb <isprint+0x67>
     8be:	66 53                	push   %ebx
     8c0:	66 e8 e4 fe ff ff    	calll  7aa <isalnum>
     8c6:	66 83 c4 04          	add    $0x4,%esp
     8ca:	66 85 c0             	test   %eax,%eax
     8cd:	75 34                	jne    903 <isprint+0x6f>
     8cf:	66 53                	push   %ebx
     8d1:	66 e8 11 ff ff ff    	calll  7e8 <ispunct>
     8d7:	66 83 c4 04          	add    $0x4,%esp
     8db:	66 85 c0             	test   %eax,%eax
     8de:	75 2b                	jne    90b <isprint+0x77>
     8e0:	66 53                	push   %ebx
     8e2:	66 e8 93 ff ff ff    	calll  87b <isblank>
     8e8:	66 83 c4 04          	add    $0x4,%esp
     8ec:	66 85 c0             	test   %eax,%eax
     8ef:	75 22                	jne    913 <isprint+0x7f>
     8f1:	eb 26                	jmp    919 <isprint+0x85>
        return 1;
     8f3:	66 b8 01 00 00 00    	mov    $0x1,%eax
     8f9:	eb 1e                	jmp    919 <isprint+0x85>
     8fb:	66 b8 01 00 00 00    	mov    $0x1,%eax
     901:	eb 16                	jmp    919 <isprint+0x85>
     903:	66 b8 01 00 00 00    	mov    $0x1,%eax
     909:	eb 0e                	jmp    919 <isprint+0x85>
     90b:	66 b8 01 00 00 00    	mov    $0x1,%eax
     911:	eb 06                	jmp    919 <isprint+0x85>
     913:	66 b8 01 00 00 00    	mov    $0x1,%eax
    }
    return 0;
}
     919:	66 5b                	pop    %ebx
     91b:	66 c3                	retl   

0000091d <iscntrl>:
int iscntrl (int ch){
     91d:	67 66 8b 44 24 04    	mov    0x4(%esp),%eax
    //he control characters are the characters with the codes 0x00-0x1F and 0x7F.
    if (0 <= ch && ch <= 0x1f)
     923:	66 83 f8 1f          	cmp    $0x1f,%eax
     927:	76 0e                	jbe    937 <iscntrl+0x1a>
        return 1;
    if (ch == 0x7f)
     929:	66 83 f8 7f          	cmp    $0x7f,%eax
     92d:	75 10                	jne    93f <iscntrl+0x22>
        return 1;
     92f:	66 b8 01 00 00 00    	mov    $0x1,%eax
     935:	66 c3                	retl   
    return 0;
}
int iscntrl (int ch){
    //he control characters are the characters with the codes 0x00-0x1F and 0x7F.
    if (0 <= ch && ch <= 0x1f)
        return 1;
     937:	66 b8 01 00 00 00    	mov    $0x1,%eax
     93d:	66 c3                	retl   
    if (ch == 0x7f)
        return 1;
    return 0;
     93f:	66 b8 00 00 00 00    	mov    $0x0,%eax
}
     945:	66 c3                	retl   

00000947 <read_n_sector>:

/* tested
读取指定逻辑扇区号的扇区到指定内存地址处
注意一次最多写一个段，也就是64k 最多读128个扇区。
够用了够用了 */
void read_n_sector(u16 sector_code, u16 number,  u16 segment, u16 offset){
     947:	66 55                	push   %ebp
     949:	66 57                	push   %edi
     94b:	66 56                	push   %esi
     94d:	66 53                	push   %ebx
     94f:	66 83 ec 1c          	sub    $0x1c,%esp
     953:	67 66 0f b7 7c 24 30 	movzwl 0x30(%esp),%edi
     95a:	67 66 0f b7 74 24 34 	movzwl 0x34(%esp),%esi
     961:	67 66 0f b7 44 24 38 	movzwl 0x38(%esp),%eax
     968:	67 89 44 24 0c       	mov    %ax,0xc(%esp)
     96d:	67 66 0f b7 44 24 3c 	movzwl 0x3c(%esp),%eax
     974:	67 89 44 24 0e       	mov    %ax,0xe(%esp)
    for (int i = 0; i < number; i++){
     979:	66 bb 00 00 00 00    	mov    $0x0,%ebx
     97f:	eb 7d                	jmp    9fe <read_n_sector+0xb7>
        int sector = (sector_code+i) % 18+1;
     981:	66 0f b7 ef          	movzwl %di,%ebp
     985:	66 01 dd             	add    %ebx,%ebp
     988:	66 ba 39 8e e3 38    	mov    $0x38e38e39,%edx
     98e:	66 89 e8             	mov    %ebp,%eax
     991:	66 f7 ea             	imul   %edx
     994:	66 c1 fa 02          	sar    $0x2,%edx
     998:	66 89 e8             	mov    %ebp,%eax
     99b:	66 c1 f8 1f          	sar    $0x1f,%eax
     99f:	66 29 c2             	sub    %eax,%edx
     9a2:	66 89 d1             	mov    %edx,%ecx
     9a5:	67 66 8d 14 d2       	lea    (%edx,%edx,8),%edx
     9aa:	67 66 8d 04 12       	lea    (%edx,%edx,1),%eax
     9af:	66 89 ea             	mov    %ebp,%edx
     9b2:	66 29 c2             	sub    %eax,%edx
     9b5:	66 83 c2 01          	add    $0x1,%edx
        int mid = (sector_code+i) / 18;
        int cylinder = mid >> 1;
     9b9:	66 89 cd             	mov    %ecx,%ebp
     9bc:	66 d1 fd             	sar    %ebp
        int head = mid & 1;
        read_sector(head, cylinder,sector,segment, offset + i*512);
     9bf:	66 83 ec 0c          	sub    $0xc,%esp
     9c3:	66 89 d8             	mov    %ebx,%eax
     9c6:	66 c1 e0 09          	shl    $0x9,%eax
     9ca:	67 03 44 24 1a       	add    0x1a(%esp),%ax
     9cf:	66 0f b7 c0          	movzwl %ax,%eax
     9d3:	66 50                	push   %eax
     9d5:	67 66 0f b7 44 24 1c 	movzwl 0x1c(%esp),%eax
     9dc:	66 50                	push   %eax
     9de:	66 0f b7 d2          	movzwl %dx,%edx
     9e2:	66 52                	push   %edx
     9e4:	66 0f b7 ed          	movzwl %bp,%ebp
     9e8:	66 55                	push   %ebp
     9ea:	66 83 e1 01          	and    $0x1,%ecx
     9ee:	66 51                	push   %ecx
     9f0:	66 e8 88 01 00 00    	calll  b7e <read_sector>
/* tested
读取指定逻辑扇区号的扇区到指定内存地址处
注意一次最多写一个段，也就是64k 最多读128个扇区。
够用了够用了 */
void read_n_sector(u16 sector_code, u16 number,  u16 segment, u16 offset){
    for (int i = 0; i < number; i++){
     9f6:	66 83 c3 01          	add    $0x1,%ebx
     9fa:	66 83 c4 20          	add    $0x20,%esp
     9fe:	66 0f b7 c6          	movzwl %si,%eax
     a02:	66 39 c3             	cmp    %eax,%ebx
     a05:	0f 8c 78 ff          	jl     981 <read_n_sector+0x3a>
        int cylinder = mid >> 1;
        int head = mid & 1;
        read_sector(head, cylinder,sector,segment, offset + i*512);
    }
    return ;
}
     a09:	66 83 c4 1c          	add    $0x1c,%esp
     a0d:	66 5b                	pop    %ebx
     a0f:	66 5e                	pop    %esi
     a11:	66 5f                	pop    %edi
     a13:	66 5d                	pop    %ebp
     a15:	66 c3                	retl   

00000a17 <read_memory>:


/* 
读取内存中指定地址起n字节的内容到指定指针处 */
void read_memory(u16 segment, u16 offset, u16 byte_size, u16 * ptr){
     a17:	66 55                	push   %ebp
     a19:	66 57                	push   %edi
     a1b:	66 56                	push   %esi
     a1d:	66 53                	push   %ebx
     a1f:	66 83 ec 0c          	sub    $0xc,%esp
     a23:	67 66 0f b7 6c 24 28 	movzwl 0x28(%esp),%ebp
    int addr = (segment << 4) + offset;
     a2a:	67 66 0f b7 7c 24 20 	movzwl 0x20(%esp),%edi
     a31:	66 c1 e7 04          	shl    $0x4,%edi
     a35:	67 66 0f b7 44 24 24 	movzwl 0x24(%esp),%eax
     a3c:	66 01 c7             	add    %eax,%edi
    for (int i = 0; i < byte_size; i++){
     a3f:	66 bb 00 00 00 00    	mov    $0x0,%ebx
     a45:	eb 22                	jmp    a69 <read_memory+0x52>
        *(ptr+i) = read_memory_word(addr);
     a47:	67 66 8b 44 24 2c    	mov    0x2c(%esp),%eax
     a4d:	67 66 8d 34 58       	lea    (%eax,%ebx,2),%esi
     a52:	66 83 ec 0c          	sub    $0xc,%esp
     a56:	66 57                	push   %edi
     a58:	66 e8 9e 00 00 00    	calll  afc <read_memory_word>
     a5e:	67 89 06             	mov    %ax,(%esi)

/* 
读取内存中指定地址起n字节的内容到指定指针处 */
void read_memory(u16 segment, u16 offset, u16 byte_size, u16 * ptr){
    int addr = (segment << 4) + offset;
    for (int i = 0; i < byte_size; i++){
     a61:	66 83 c3 01          	add    $0x1,%ebx
     a65:	66 83 c4 10          	add    $0x10,%esp
     a69:	66 0f b7 c5          	movzwl %bp,%eax
     a6d:	66 39 c3             	cmp    %eax,%ebx
     a70:	7c d5                	jl     a47 <read_memory+0x30>
        *(ptr+i) = read_memory_word(addr);
    }
     a72:	66 83 c4 0c          	add    $0xc,%esp
     a76:	66 5b                	pop    %ebx
     a78:	66 5e                	pop    %esi
     a7a:	66 5f                	pop    %edi
     a7c:	66 5d                	pop    %ebp
     a7e:	66 c3                	retl   

00000a80 <write_port_byte>:
     a80:	66 55                	push   %ebp
     a82:	66 89 e5             	mov    %esp,%ebp
     a85:	50                   	push   %ax
     a86:	52                   	push   %dx
     a87:	67 8b 55 08          	mov    0x8(%ebp),%dx
     a8b:	67 8a 45 0c          	mov    0xc(%ebp),%al
     a8f:	ee                   	out    %al,(%dx)
     a90:	5a                   	pop    %dx
     a91:	58                   	pop    %ax
     a92:	66 89 ec             	mov    %ebp,%esp
     a95:	66 5d                	pop    %ebp
     a97:	66 c3                	retl   

00000a99 <read_port_byte>:
     a99:	66 55                	push   %ebp
     a9b:	66 89 e5             	mov    %esp,%ebp
     a9e:	52                   	push   %dx
     a9f:	67 8b 55 08          	mov    0x8(%ebp),%dx
     aa3:	ec                   	in     (%dx),%al
     aa4:	5a                   	pop    %dx
     aa5:	66 89 ec             	mov    %ebp,%esp
     aa8:	66 5d                	pop    %ebp
     aaa:	66 c3                	retl   

00000aac <write_memory_word>:
     aac:	66 55                	push   %ebp
     aae:	66 89 e5             	mov    %esp,%ebp
     ab1:	50                   	push   %ax
     ab2:	53                   	push   %bx
     ab3:	52                   	push   %dx
     ab4:	1e                   	push   %ds
     ab5:	67 8b 5d 08          	mov    0x8(%ebp),%bx
     ab9:	67 8b 45 0a          	mov    0xa(%ebp),%ax
     abd:	c1 e0 0c             	shl    $0xc,%ax
     ac0:	8e d8                	mov    %ax,%ds
     ac2:	67 8b 55 0c          	mov    0xc(%ebp),%dx
     ac6:	3e 89 17             	mov    %dx,%ds:(%bx)
     ac9:	1f                   	pop    %ds
     aca:	5a                   	pop    %dx
     acb:	5b                   	pop    %bx
     acc:	58                   	pop    %ax
     acd:	66 89 ec             	mov    %ebp,%esp
     ad0:	66 5d                	pop    %ebp
     ad2:	66 c3                	retl   

00000ad4 <write_memory_byte>:
     ad4:	66 55                	push   %ebp
     ad6:	66 89 e5             	mov    %esp,%ebp
     ad9:	50                   	push   %ax
     ada:	53                   	push   %bx
     adb:	52                   	push   %dx
     adc:	1e                   	push   %ds
     add:	67 8b 5d 08          	mov    0x8(%ebp),%bx
     ae1:	67 8b 45 0a          	mov    0xa(%ebp),%ax
     ae5:	c1 e0 0c             	shl    $0xc,%ax
     ae8:	8e d8                	mov    %ax,%ds
     aea:	67 8a 55 0c          	mov    0xc(%ebp),%dl
     aee:	3e 88 17             	mov    %dl,%ds:(%bx)
     af1:	1f                   	pop    %ds
     af2:	5a                   	pop    %dx
     af3:	5b                   	pop    %bx
     af4:	58                   	pop    %ax
     af5:	66 89 ec             	mov    %ebp,%esp
     af8:	66 5d                	pop    %ebp
     afa:	66 c3                	retl   

00000afc <read_memory_word>:
     afc:	66 55                	push   %ebp
     afe:	66 89 e5             	mov    %esp,%ebp
     b01:	53                   	push   %bx
     b02:	52                   	push   %dx
     b03:	1e                   	push   %ds
     b04:	67 8b 5d 08          	mov    0x8(%ebp),%bx
     b08:	67 8b 45 0a          	mov    0xa(%ebp),%ax
     b0c:	c1 e0 0c             	shl    $0xc,%ax
     b0f:	8e d8                	mov    %ax,%ds
     b11:	3e 8b 07             	mov    %ds:(%bx),%ax
     b14:	1f                   	pop    %ds
     b15:	5a                   	pop    %dx
     b16:	5b                   	pop    %bx
     b17:	66 89 ec             	mov    %ebp,%esp
     b1a:	66 5d                	pop    %ebp
     b1c:	66 c3                	retl   

00000b1e <check_keyboard>:
     b1e:	b4 01                	mov    $0x1,%ah
     b20:	cd 16                	int    $0x16
     b22:	74 05                	je     b29 <check_keyboard.have_key>
     b24:	b8 00 00             	mov    $0x0,%ax
     b27:	eb 03                	jmp    b2c <check_keyboard.check_keyboard_return>

00000b29 <check_keyboard.have_key>:
     b29:	b8 01 00             	mov    $0x1,%ax

00000b2c <check_keyboard.check_keyboard_return>:
     b2c:	66 c3                	retl   

00000b2e <get_keyboard>:
     b2e:	b4 00                	mov    $0x0,%ah
     b30:	cd 16                	int    $0x16
     b32:	66 c3                	retl   

00000b34 <clean_screen>:
     b34:	50                   	push   %ax
     b35:	53                   	push   %bx
     b36:	51                   	push   %cx
     b37:	52                   	push   %dx
     b38:	b4 06                	mov    $0x6,%ah
     b3a:	b0 00                	mov    $0x0,%al
     b3c:	b5 00                	mov    $0x0,%ch
     b3e:	b1 00                	mov    $0x0,%cl
     b40:	b6 17                	mov    $0x17,%dh
     b42:	b2 4f                	mov    $0x4f,%dl
     b44:	b7 1f                	mov    $0x1f,%bh
     b46:	cd 10                	int    $0x10
     b48:	5a                   	pop    %dx
     b49:	59                   	pop    %cx
     b4a:	5b                   	pop    %bx
     b4b:	58                   	pop    %ax
     b4c:	66 c3                	retl   

00000b4e <scroll_screen>:
     b4e:	50                   	push   %ax
     b4f:	53                   	push   %bx
     b50:	51                   	push   %cx
     b51:	52                   	push   %dx
     b52:	b4 06                	mov    $0x6,%ah
     b54:	b0 01                	mov    $0x1,%al
     b56:	b5 00                	mov    $0x0,%ch
     b58:	b1 00                	mov    $0x0,%cl
     b5a:	b6 17                	mov    $0x17,%dh
     b5c:	b2 4f                	mov    $0x4f,%dl
     b5e:	b7 10                	mov    $0x10,%bh
     b60:	cd 10                	int    $0x10
     b62:	5a                   	pop    %dx
     b63:	59                   	pop    %cx
     b64:	5b                   	pop    %bx
     b65:	58                   	pop    %ax
     b66:	66 c3                	retl   

00000b68 <get_random>:
     b68:	53                   	push   %bx
     b69:	b8 00 00             	mov    $0x0,%ax
     b6c:	e6 43                	out    %al,$0x43
     b6e:	e4 40                	in     $0x40,%al
     b70:	b3 08                	mov    $0x8,%bl
     b72:	f6 f3                	div    %bl
     b74:	88 e0                	mov    %ah,%al
     b76:	b4 00                	mov    $0x0,%ah
     b78:	83 c0 72             	add    $0x72,%ax
     b7b:	5b                   	pop    %bx
     b7c:	66 c3                	retl   

00000b7e <read_sector>:
     b7e:	66 55                	push   %ebp
     b80:	66 89 e5             	mov    %esp,%ebp
     b83:	50                   	push   %ax
     b84:	53                   	push   %bx
     b85:	51                   	push   %cx
     b86:	52                   	push   %dx
     b87:	06                   	push   %es
     b88:	67 8b 45 14          	mov    0x14(%ebp),%ax
     b8c:	8e c0                	mov    %ax,%es
     b8e:	67 8b 5d 18          	mov    0x18(%ebp),%bx
     b92:	b4 02                	mov    $0x2,%ah
     b94:	b0 01                	mov    $0x1,%al
     b96:	b2 00                	mov    $0x0,%dl
     b98:	67 8a 75 08          	mov    0x8(%ebp),%dh
     b9c:	67 8a 6d 0c          	mov    0xc(%ebp),%ch
     ba0:	67 8a 4d 10          	mov    0x10(%ebp),%cl
     ba4:	cd 13                	int    $0x13
     ba6:	07                   	pop    %es
     ba7:	5a                   	pop    %dx
     ba8:	59                   	pop    %cx
     ba9:	5b                   	pop    %bx
     baa:	58                   	pop    %ax
     bab:	66 89 ec             	mov    %ebp,%esp
     bae:	66 5d                	pop    %ebp
     bb0:	66 c3                	retl   

00000bb2 <print_my_name>:
     bb2:	50                   	push   %ax
     bb3:	53                   	push   %bx
     bb4:	51                   	push   %cx
     bb5:	52                   	push   %dx
     bb6:	1e                   	push   %ds
     bb7:	06                   	push   %es
     bb8:	55                   	push   %bp
     bb9:	b8 00 10             	mov    $0x1000,%ax
     bbc:	8e c0                	mov    %ax,%es
     bbe:	b8 08 21             	mov    $0x2108,%ax
     bc1:	89 c5                	mov    %ax,%bp
     bc3:	b4 13                	mov    $0x13,%ah
     bc5:	b0 00                	mov    $0x0,%al
     bc7:	b7 00                	mov    $0x0,%bh
     bc9:	b3 0f                	mov    $0xf,%bl
     bcb:	b9 19 00             	mov    $0x19,%cx
     bce:	b6 18                	mov    $0x18,%dh
     bd0:	b2 01                	mov    $0x1,%dl
     bd2:	cd 10                	int    $0x10
     bd4:	5d                   	pop    %bp
     bd5:	07                   	pop    %es
     bd6:	1f                   	pop    %ds
     bd7:	5a                   	pop    %dx
     bd8:	59                   	pop    %cx
     bd9:	5b                   	pop    %bx
     bda:	58                   	pop    %ax
     bdb:	c3                   	ret    

00000bdc <reboot>:
     bdc:	b4 06                	mov    $0x6,%ah
     bde:	b0 00                	mov    $0x0,%al
     be0:	b5 00                	mov    $0x0,%ch
     be2:	b1 00                	mov    $0x0,%cl
     be4:	b6 18                	mov    $0x18,%dh
     be6:	b2 4f                	mov    $0x4f,%dl
     be8:	b7 1f                	mov    $0x1f,%bh
     bea:	cd 10                	int    $0x10
     bec:	cd 19                	int    $0x19

00000bee <strlen>:
#include "../include/type.h"

size_t strlen(char * str){
     bee:	67 66 8b 54 24 04    	mov    0x4(%esp),%edx
    u32 len = 0;
     bf4:	66 b8 00 00 00 00    	mov    $0x0,%eax
    while (str[len] != 0){
     bfa:	eb 04                	jmp    c00 <strlen+0x12>
        len++;
     bfc:	66 83 c0 01          	add    $0x1,%eax
#include "../include/type.h"

size_t strlen(char * str){
    u32 len = 0;
    while (str[len] != 0){
     c00:	67 80 3c 02 00       	cmpb   $0x0,(%edx,%eax,1)
     c05:	75 f5                	jne    bfc <strlen+0xe>
        len++;
    }
    return len;
}
     c07:	66 f3 c3             	repz retl 

00000c0a <strncpy>:

void strncpy(char * dest, char * src, u32 size){
     c0a:	66 56                	push   %esi
     c0c:	66 53                	push   %ebx
     c0e:	67 66 8b 5c 24 0c    	mov    0xc(%esp),%ebx
     c14:	67 66 8b 74 24 10    	mov    0x10(%esp),%esi
     c1a:	67 66 8b 4c 24 14    	mov    0x14(%esp),%ecx
    for (int i = 0; i < size; i++){
     c20:	66 b8 00 00 00 00    	mov    $0x0,%eax
     c26:	eb 0e                	jmp    c36 <strncpy+0x2c>
        dest[i] = src[i];
     c28:	67 66 0f b6 14 06    	movzbl (%esi,%eax,1),%edx
     c2e:	67 88 14 03          	mov    %dl,(%ebx,%eax,1)
    }
    return len;
}

void strncpy(char * dest, char * src, u32 size){
    for (int i = 0; i < size; i++){
     c32:	66 83 c0 01          	add    $0x1,%eax
     c36:	66 39 c8             	cmp    %ecx,%eax
     c39:	72 ed                	jb     c28 <strncpy+0x1e>
        dest[i] = src[i];
    }
    dest[size] = '\0';
     c3b:	67 c6 04 0b 00       	movb   $0x0,(%ebx,%ecx,1)
}
     c40:	66 5b                	pop    %ebx
     c42:	66 5e                	pop    %esi
     c44:	66 c3                	retl   

00000c46 <strcmp>:

int strcmp(char * lhs, char * rhs){
     c46:	66 57                	push   %edi
     c48:	66 56                	push   %esi
     c4a:	66 53                	push   %ebx
     c4c:	67 66 8b 74 24 10    	mov    0x10(%esp),%esi
     c52:	67 66 8b 7c 24 14    	mov    0x14(%esp),%edi
    int lhs_len = strlen(lhs);
     c58:	66 56                	push   %esi
     c5a:	66 e8 8e ff ff ff    	calll  bee <strlen>
     c60:	66 89 c3             	mov    %eax,%ebx
    int rhs_len = strlen(rhs);
     c63:	67 66 89 3c 24       	mov    %edi,(%esp)
     c68:	66 e8 80 ff ff ff    	calll  bee <strlen>
     c6e:	66 83 c4 04          	add    $0x4,%esp
    if (lhs_len != rhs_len){
     c72:	66 39 c3             	cmp    %eax,%ebx
     c75:	75 25                	jne    c9c <strcmp+0x56>
     c77:	66 b8 00 00 00 00    	mov    $0x0,%eax
     c7d:	eb 10                	jmp    c8f <strcmp+0x49>
        return 1;
    }
    for (int i = 0; i < lhs_len; i++){
        if (lhs[i] != rhs[i])
     c7f:	67 66 0f b6 14 07    	movzbl (%edi,%eax,1),%edx
     c85:	67 38 14 06          	cmp    %dl,(%esi,%eax,1)
     c89:	75 19                	jne    ca4 <strcmp+0x5e>
    int lhs_len = strlen(lhs);
    int rhs_len = strlen(rhs);
    if (lhs_len != rhs_len){
        return 1;
    }
    for (int i = 0; i < lhs_len; i++){
     c8b:	66 83 c0 01          	add    $0x1,%eax
     c8f:	66 39 d8             	cmp    %ebx,%eax
     c92:	7c eb                	jl     c7f <strcmp+0x39>
        if (lhs[i] != rhs[i])
            return 1;
    }
    return 0;
     c94:	66 b8 00 00 00 00    	mov    $0x0,%eax
     c9a:	eb 0e                	jmp    caa <strcmp+0x64>

int strcmp(char * lhs, char * rhs){
    int lhs_len = strlen(lhs);
    int rhs_len = strlen(rhs);
    if (lhs_len != rhs_len){
        return 1;
     c9c:	66 b8 01 00 00 00    	mov    $0x1,%eax
     ca2:	eb 06                	jmp    caa <strcmp+0x64>
    }
    for (int i = 0; i < lhs_len; i++){
        if (lhs[i] != rhs[i])
            return 1;
     ca4:	66 b8 01 00 00 00    	mov    $0x1,%eax
    }
    return 0;
}
     caa:	66 5b                	pop    %ebx
     cac:	66 5e                	pop    %esi
     cae:	66 5f                	pop    %edi
     cb0:	66 c3                	retl   

00000cb2 <strncmp>:

int strncmp(char * lhs, char * rhs, int size){
     cb2:	66 56                	push   %esi
     cb4:	66 53                	push   %ebx
     cb6:	67 66 8b 5c 24 0c    	mov    0xc(%esp),%ebx
     cbc:	67 66 8b 4c 24 10    	mov    0x10(%esp),%ecx
     cc2:	67 66 8b 74 24 14    	mov    0x14(%esp),%esi
    for (int i = 0; i < size; i++){
     cc8:	66 b8 00 00 00 00    	mov    $0x0,%eax
     cce:	eb 10                	jmp    ce0 <strncmp+0x2e>
        if (lhs[i] != rhs[i])
     cd0:	67 66 0f b6 14 01    	movzbl (%ecx,%eax,1),%edx
     cd6:	67 38 14 03          	cmp    %dl,(%ebx,%eax,1)
     cda:	75 11                	jne    ced <strncmp+0x3b>
    }
    return 0;
}

int strncmp(char * lhs, char * rhs, int size){
    for (int i = 0; i < size; i++){
     cdc:	66 83 c0 01          	add    $0x1,%eax
     ce0:	66 39 f0             	cmp    %esi,%eax
     ce3:	7c eb                	jl     cd0 <strncmp+0x1e>
        if (lhs[i] != rhs[i])
            return 1;
    }
    return 0;
     ce5:	66 b8 00 00 00 00    	mov    $0x0,%eax
     ceb:	eb 06                	jmp    cf3 <strncmp+0x41>
}

int strncmp(char * lhs, char * rhs, int size){
    for (int i = 0; i < size; i++){
        if (lhs[i] != rhs[i])
            return 1;
     ced:	66 b8 01 00 00 00    	mov    $0x1,%eax
    }
    return 0;
     cf3:	66 5b                	pop    %ebx
     cf5:	66 5e                	pop    %esi
     cf7:	66 c3                	retl   

00000cf9 <install_system_call>:
#include "../include/type.h"
#include "../include/stdio.h"
#include "../include/global.h"

void install_system_call(int system_call_number, void (*function)() ){
    system_call[system_call_number] = (u16) function;
     cf9:	67 66 8b 54 24 08    	mov    0x8(%esp),%edx
     cff:	67 66 8b 44 24 04    	mov    0x4(%esp),%eax
     d05:	67 89 94 00 20 28 00 	mov    %dx,0x2820(%eax,%eax,1)
     d0c:	00 
     d0d:	66 c3                	retl   

00000d0f <test_system_call>:

    // while (1){}
    return 0;
}

void test_system_call(){
     d0f:	66 53                	push   %ebx
     d11:	66 83 ec 08          	sub    $0x8,%esp
    int origin = get_cursor();
     d15:	66 e8 47 f4 ff ff    	calll  162 <get_cursor>
     d1b:	66 89 c3             	mov    %eax,%ebx
    set_cursor(1800);
     d1e:	66 83 ec 0c          	sub    $0xc,%esp
     d22:	66 68 08 07 00 00    	pushl  $0x708
     d28:	66 e8 c2 f3 ff ff    	calll  f0 <set_cursor>
    printf("test custom system call!!! ");
     d2e:	67 66 c7 04 24 18 1e 	movl   $0x1e18,(%esp)
     d35:	00 00 
     d37:	66 e8 fc f9 ff ff    	calll  739 <printf>
    set_cursor(origin);
     d3d:	66 0f b7 db          	movzwl %bx,%ebx
     d41:	67 66 89 1c 24       	mov    %ebx,(%esp)
     d46:	66 e8 a4 f3 ff ff    	calll  f0 <set_cursor>
}
     d4c:	66 83 c4 18          	add    $0x18,%esp
     d50:	66 5b                	pop    %ebx
     d52:	66 c3                	retl   

00000d54 <cstart>:
#include "../include/fsystem.h"

void (**my_program)();
void test_system_call();

int cstart(){
     d54:	66 83 ec 14          	sub    $0x14,%esp
    install_system_call(2, test_system_call);
     d58:	66 68 0f 0d 00 00    	pushl  $0xd0f
     d5e:	66 6a 02             	pushl  $0x2
     d61:	66 e8 92 ff ff ff    	calll  cf9 <install_system_call>
    clean_screen();
     d67:	66 e8 c7 fd ff ff    	calll  b34 <clean_screen>
    set_cursor(0);
     d6d:	67 66 c7 04 24 00 00 	movl   $0x0,(%esp)
     d74:	00 00 
     d76:	66 e8 74 f3 ff ff    	calll  f0 <set_cursor>
    init_fsystem();
     d7c:	66 e8 0c 05 00 00    	calll  128e <init_fsystem>

    fs_show_root_file_table();
     d82:	66 e8 af 07 00 00    	calll  1537 <fs_show_root_file_table>
    // fs_load_by_name("stone1.bin", *my_program);
    // (*my_program)();

    // while (1){}
    return 0;
}
     d88:	66 b8 00 00 00 00    	mov    $0x0,%eax
     d8e:	66 83 c4 1c          	add    $0x1c,%esp
     d92:	66 c3                	retl   

00000d94 <parser>:
    }
    return ;
}


void parser(){
     d94:	66 56                	push   %esi
     d96:	66 53                	push   %ebx
     d98:	66 83 ec 74          	sub    $0x74,%esp
    char arguments[10][10];
    int input_start = 0;
    int input_end = 0;
    int arguments_num = 0;
     d9c:	66 be 00 00 00 00    	mov    $0x0,%esi


void parser(){
    char arguments[10][10];
    int input_start = 0;
    int input_end = 0;
     da2:	66 bb 00 00 00 00    	mov    $0x0,%ebx
}


void parser(){
    char arguments[10][10];
    int input_start = 0;
     da8:	66 ba 00 00 00 00    	mov    $0x0,%edx
    int input_end = 0;
    int arguments_num = 0;
    // 使用空格作为分隔符，将输入缓冲区的内容分割成几个参数分别存进arguments数组中
    while (input_end <= command_line_cursor){
     dae:	eb 64                	jmp    e14 <parser+0x80>
        if(input_buf[input_end] == ' ' || input_buf[input_end] == '\0'){
     db0:	67 66 0f b6 83 60 21 	movzbl 0x2160(%ebx),%eax
     db7:	00 00 
     db9:	3c 20                	cmp    $0x20,%al
     dbb:	0f 94 c1             	sete   %cl
     dbe:	84 c0                	test   %al,%al
     dc0:	0f 94 c0             	sete   %al
     dc3:	08 c1                	or     %al,%cl
     dc5:	74 49                	je     e10 <parser+0x7c>
            if (input_start == input_end){ // 如果并没有参数，那么继续
     dc7:	66 39 da             	cmp    %ebx,%edx
     dca:	75 0a                	jne    dd6 <parser+0x42>
                input_start++;
     dcc:	66 83 c2 01          	add    $0x1,%edx
                input_end++;
     dd0:	66 83 c3 01          	add    $0x1,%ebx
                continue;
     dd4:	eb 3e                	jmp    e14 <parser+0x80>
            }
            else {// 如果有参数，并且已经读到末尾了，那就复制到相应的区域
                strncpy(arguments[arguments_num], input_buf+input_start, input_end-input_start);
     dd6:	66 89 d9             	mov    %ebx,%ecx
     dd9:	66 29 d1             	sub    %edx,%ecx
     ddc:	67 66 8d 04 b6       	lea    (%esi,%esi,4),%eax
     de1:	67 66 8d 44 44 0c    	lea    0xc(%esp,%eax,2),%eax
     de7:	66 83 ec 04          	sub    $0x4,%esp
     deb:	66 51                	push   %ecx
     ded:	66 81 c2 60 21 00 00 	add    $0x2160,%edx
     df4:	66 52                	push   %edx
     df6:	66 50                	push   %eax
     df8:	66 e8 0c fe ff ff    	calll  c0a <strncpy>
                input_end++;
     dfe:	67 66 8d 53 01       	lea    0x1(%ebx),%edx
                input_start = input_end;
                arguments_num++;
     e03:	66 83 c6 01          	add    $0x1,%esi
     e07:	66 83 c4 10          	add    $0x10,%esp
                input_end++;
                continue;
            }
            else {// 如果有参数，并且已经读到末尾了，那就复制到相应的区域
                strncpy(arguments[arguments_num], input_buf+input_start, input_end-input_start);
                input_end++;
     e0b:	66 89 d3             	mov    %edx,%ebx
     e0e:	eb 04                	jmp    e14 <parser+0x80>
                input_start = input_end;
                arguments_num++;
            }
        }
        else {// 有参数，还没有读到末尾
            input_end++;
     e10:	66 83 c3 01          	add    $0x1,%ebx
    char arguments[10][10];
    int input_start = 0;
    int input_end = 0;
    int arguments_num = 0;
    // 使用空格作为分隔符，将输入缓冲区的内容分割成几个参数分别存进arguments数组中
    while (input_end <= command_line_cursor){
     e14:	66 3b 1e 40 21       	cmp    0x2140,%ebx
     e19:	7e 95                	jle    db0 <parser+0x1c>
        }
    }

    // 完成分词，开始进行解析。

    if(!strcmp(arguments[0],"run")){// 如果返回0，就是相等了
     e1b:	66 83 ec 08          	sub    $0x8,%esp
     e1f:	66 68 34 1e 00 00    	pushl  $0x1e34
     e25:	67 66 8d 44 24 18    	lea    0x18(%esp),%eax
     e2b:	66 50                	push   %eax
     e2d:	66 e8 13 fe ff ff    	calll  c46 <strcmp>
     e33:	66 83 c4 10          	add    $0x10,%esp
     e37:	66 85 c0             	test   %eax,%eax
     e3a:	75 31                	jne    e6d <parser+0xd9>
        // 运行一个用户程序。
        // 先从软盘中加载一个指定程序到内存处，然后开始执行。
        // 考虑维护一个空闲空间的指针，然后每加载一个程序，如果可行的话。
        void (**my_program)();
        *my_program = 0x4000;
     e3c:	66 bb 00 00 00 00    	mov    $0x0,%ebx
     e42:	67 66 c7 03 00 40 00 	movl   $0x4000,(%ebx)
     e49:	00 
        fs_load_by_name(arguments[1],*my_program);
     e4a:	66 83 ec 08          	sub    $0x8,%esp
     e4e:	66 68 00 40 00 00    	pushl  $0x4000
     e54:	67 66 8d 44 24 22    	lea    0x22(%esp),%eax
     e5a:	66 50                	push   %eax
     e5c:	66 e8 6f 06 00 00    	calll  14d1 <fs_load_by_name>
        (*my_program)();
     e62:	67 66 ff 13          	calll  *(%ebx)
     e66:	66 83 c4 10          	add    $0x10,%esp
     e6a:	e9 1b 01             	jmp    f88 <parser+0x1f4>
    }
    else if(!strcmp(arguments[0],"ls") && arguments_num == 1){
     e6d:	66 83 ec 08          	sub    $0x8,%esp
     e71:	66 68 38 1e 00 00    	pushl  $0x1e38
     e77:	67 66 8d 44 24 18    	lea    0x18(%esp),%eax
     e7d:	66 50                	push   %eax
     e7f:	66 e8 c1 fd ff ff    	calll  c46 <strcmp>
     e85:	66 83 c4 10          	add    $0x10,%esp
     e89:	66 85 c0             	test   %eax,%eax
     e8c:	75 23                	jne    eb1 <parser+0x11d>
     e8e:	66 83 fe 01          	cmp    $0x1,%esi
     e92:	75 1d                	jne    eb1 <parser+0x11d>
        printf("\n\n");
     e94:	66 83 ec 0c          	sub    $0xc,%esp
     e98:	66 68 3b 1e 00 00    	pushl  $0x1e3b
     e9e:	66 e8 95 f8 ff ff    	calll  739 <printf>
        fs_show_root_file_table();
     ea4:	66 e8 8d 06 00 00    	calll  1537 <fs_show_root_file_table>
        void (**my_program)();
        *my_program = 0x4000;
        fs_load_by_name(arguments[1],*my_program);
        (*my_program)();
    }
    else if(!strcmp(arguments[0],"ls") && arguments_num == 1){
     eaa:	66 83 c4 10          	add    $0x10,%esp
     eae:	e9 d7 00             	jmp    f88 <parser+0x1f4>
        printf("\n\n");
        fs_show_root_file_table();
    }
    else if(!strcmp(arguments[0],"reboot") && arguments_num == 1){
     eb1:	66 83 ec 08          	sub    $0x8,%esp
     eb5:	66 68 3e 1e 00 00    	pushl  $0x1e3e
     ebb:	67 66 8d 44 24 18    	lea    0x18(%esp),%eax
     ec1:	66 50                	push   %eax
     ec3:	66 e8 7d fd ff ff    	calll  c46 <strcmp>
     ec9:	66 83 c4 10          	add    $0x10,%esp
     ecd:	66 85 c0             	test   %eax,%eax
     ed0:	75 23                	jne    ef5 <parser+0x161>
     ed2:	66 83 fe 01          	cmp    $0x1,%esi
     ed6:	75 1d                	jne    ef5 <parser+0x161>
        printf("\n\n");
     ed8:	66 83 ec 0c          	sub    $0xc,%esp
     edc:	66 68 3b 1e 00 00    	pushl  $0x1e3b
     ee2:	66 e8 51 f8 ff ff    	calll  739 <printf>
        reboot();
     ee8:	66 e8 ee fc ff ff    	calll  bdc <reboot>
    }
    else if(!strcmp(arguments[0],"ls") && arguments_num == 1){
        printf("\n\n");
        fs_show_root_file_table();
    }
    else if(!strcmp(arguments[0],"reboot") && arguments_num == 1){
     eee:	66 83 c4 10          	add    $0x10,%esp
     ef2:	e9 93 00             	jmp    f88 <parser+0x1f4>
        printf("\n\n");
        reboot();
    }
    else if(!strcmp(arguments[0],"help") && arguments_num == 1){
     ef5:	66 83 ec 08          	sub    $0x8,%esp
     ef9:	66 68 45 1e 00 00    	pushl  $0x1e45
     eff:	67 66 8d 44 24 18    	lea    0x18(%esp),%eax
     f05:	66 50                	push   %eax
     f07:	66 e8 39 fd ff ff    	calll  c46 <strcmp>
     f0d:	66 83 c4 10          	add    $0x10,%esp
     f11:	66 85 c0             	test   %eax,%eax
     f14:	75 58                	jne    f6e <parser+0x1da>
     f16:	66 83 fe 01          	cmp    $0x1,%esi
     f1a:	75 52                	jne    f6e <parser+0x1da>
        printf("\n\n");
     f1c:	66 83 ec 0c          	sub    $0xc,%esp
     f20:	66 68 3b 1e 00 00    	pushl  $0x1e3b
     f26:	66 e8 0d f8 ff ff    	calll  739 <printf>
        printf("ls        : show the file in the root folder.\n");
     f2c:	67 66 c7 04 24 b0 1e 	movl   $0x1eb0,(%esp)
     f33:	00 00 
     f35:	66 e8 fe f7 ff ff    	calll  739 <printf>
        printf("run [name]: run the file in the root folder.\n");
     f3b:	67 66 c7 04 24 e0 1e 	movl   $0x1ee0,(%esp)
     f42:	00 00 
     f44:	66 e8 ef f7 ff ff    	calll  739 <printf>
        printf("help      : show the help message.\n");
     f4a:	67 66 c7 04 24 10 1f 	movl   $0x1f10,(%esp)
     f51:	00 00 
     f53:	66 e8 e0 f7 ff ff    	calll  739 <printf>
        printf("reboot    : reboot the machine.\n");
     f59:	67 66 c7 04 24 34 1f 	movl   $0x1f34,(%esp)
     f60:	00 00 
     f62:	66 e8 d1 f7 ff ff    	calll  739 <printf>
     f68:	66 83 c4 10          	add    $0x10,%esp
     f6c:	eb 1a                	jmp    f88 <parser+0x1f4>
    }
    else {
        printf("\n%s : command not found! \n", input_buf);
     f6e:	66 83 ec 08          	sub    $0x8,%esp
     f72:	66 68 60 21 00 00    	pushl  $0x2160
     f78:	66 68 4a 1e 00 00    	pushl  $0x1e4a
     f7e:	66 e8 b5 f7 ff ff    	calll  739 <printf>
     f84:	66 83 c4 10          	add    $0x10,%esp
    }
    int current_cursor = get_cursor();
     f88:	66 e8 d4 f1 ff ff    	calll  162 <get_cursor>
     f8e:	66 0f b7 c0          	movzwl %ax,%eax
    command_line_row = (current_cursor / 80);
     f92:	66 ba 67 66 66 66    	mov    $0x66666667,%edx
     f98:	66 f7 ea             	imul   %edx
     f9b:	66 c1 fa 05          	sar    $0x5,%edx
     f9f:	66 89 16 04 21       	mov    %edx,0x2104
    // printf("arguments: %d|%s|%s|",arguments_num, arguments[0],arguments[1]);
    return ;
}
     fa4:	66 83 c4 74          	add    $0x74,%esp
     fa8:	66 5b                	pop    %ebx
     faa:	66 5e                	pop    %esi
     fac:	66 c3                	retl   

00000fae <create_a_line>:

// 转移光标到命令行下一行,更新缓冲区，并且打印信息
void create_a_line(){
     fae:	66 83 ec 2c          	sub    $0x2c,%esp
    char message[30] = "walker@walker-pc ~ $ \0";
     fb2:	66 a1 80 1f          	mov    0x1f80,%eax
     fb6:	67 66 89 44 24 02    	mov    %eax,0x2(%esp)
     fbc:	66 a1 84 1f          	mov    0x1f84,%eax
     fc0:	67 66 89 44 24 06    	mov    %eax,0x6(%esp)
     fc6:	66 a1 88 1f          	mov    0x1f88,%eax
     fca:	67 66 89 44 24 0a    	mov    %eax,0xa(%esp)
     fd0:	66 a1 8c 1f          	mov    0x1f8c,%eax
     fd4:	67 66 89 44 24 0e    	mov    %eax,0xe(%esp)
     fda:	66 a1 90 1f          	mov    0x1f90,%eax
     fde:	67 66 89 44 24 12    	mov    %eax,0x12(%esp)
     fe4:	66 0f b7 06 94 1f    	movzwl 0x1f94,%eax
     fea:	67 89 44 24 16       	mov    %ax,0x16(%esp)
     fef:	66 0f b6 06 96 1f    	movzbl 0x1f96,%eax
     ff5:	67 88 44 24 18       	mov    %al,0x18(%esp)
     ffa:	67 66 c7 44 24 19 00 	movl   $0x0,0x19(%esp)
    1001:	00 00 00 
    1004:	67 c7 44 24 1d 00 00 	movw   $0x0,0x1d(%esp)
    100b:	67 c6 44 24 1f 00    	movb   $0x0,0x1f(%esp)
    for (int i = 0; i < MAX_BUF; i++){
    1011:	66 b8 00 00 00 00    	mov    $0x0,%eax
    1017:	eb 0c                	jmp    1025 <core_header_data_segment+0x25>
        input_buf[i] = 0;
    1019:	67 c6 80 60 21 00 00 	movb   $0x0,0x2160(%eax)
    1020:	00 
}

// 转移光标到命令行下一行,更新缓冲区，并且打印信息
void create_a_line(){
    char message[30] = "walker@walker-pc ~ $ \0";
    for (int i = 0; i < MAX_BUF; i++){
    1021:	66 83 c0 01          	add    $0x1,%eax
    1025:	66 83 f8 63          	cmp    $0x63,%eax
    1029:	7e ee                	jle    1019 <core_header_data_segment+0x19>
        input_buf[i] = 0;
    }
    message_length = strlen(message);
    102b:	66 83 ec 0c          	sub    $0xc,%esp
    102f:	67 66 8d 44 24 0e    	lea    0xe(%esp),%eax
    1035:	66 50                	push   %eax
    1037:	66 e8 b1 fb ff ff    	calll  bee <strlen>
    103d:	66 a3 44 21          	mov    %eax,0x2144
    command_line_row = command_line_row + (command_line_cursor + message_length)/80 + 1;
    1041:	66 03 06 40 21       	add    0x2140,%eax
    1046:	66 89 c1             	mov    %eax,%ecx
    1049:	66 ba 67 66 66 66    	mov    $0x66666667,%edx
    104f:	66 f7 ea             	imul   %edx
    1052:	66 c1 fa 05          	sar    $0x5,%edx
    1056:	66 c1 f9 1f          	sar    $0x1f,%ecx
    105a:	66 29 ca             	sub    %ecx,%edx
    105d:	66 89 d0             	mov    %edx,%eax
    1060:	66 03 06 04 21       	add    0x2104,%eax
    1065:	66 83 c0 01          	add    $0x1,%eax
    1069:	66 a3 04 21          	mov    %eax,0x2104
    while(command_line_row > 23){
    106d:	66 83 c4 10          	add    $0x10,%esp
    1071:	eb 0c                	jmp    107f <core_header_data_segment+0x7f>
        scroll_screen();
    1073:	66 e8 d5 fa ff ff    	calll  b4e <scroll_screen>
        command_line_row--;
    1079:	66 83 2e 04 21 01    	subl   $0x1,0x2104
    for (int i = 0; i < MAX_BUF; i++){
        input_buf[i] = 0;
    }
    message_length = strlen(message);
    command_line_row = command_line_row + (command_line_cursor + message_length)/80 + 1;
    while(command_line_row > 23){
    107f:	66 a1 04 21          	mov    0x2104,%eax
    1083:	66 83 f8 17          	cmp    $0x17,%eax
    1087:	7f ea                	jg     1073 <core_header_data_segment+0x73>
        scroll_screen();
        command_line_row--;
    }
    command_line_cursor = 0;
    1089:	66 c7 06 40 21 00 00 	movl   $0x0,0x2140
    1090:	00 00 
    set_cursor(command_line_row * 80);
    1092:	66 83 ec 0c          	sub    $0xc,%esp
    1096:	67 66 8d 04 80       	lea    (%eax,%eax,4),%eax
    109b:	66 c1 e0 04          	shl    $0x4,%eax
    109f:	66 0f b7 d0          	movzwl %ax,%edx
    10a3:	66 52                	push   %edx
    10a5:	66 e8 45 f0 ff ff    	calll  f0 <set_cursor>
    // printf("%d", command_line_row);
    printf("%s", message);
    10ab:	66 83 c4 08          	add    $0x8,%esp
    10af:	67 66 8d 44 24 0a    	lea    0xa(%esp),%eax
    10b5:	66 50                	push   %eax
    10b7:	66 68 65 1e 00 00    	pushl  $0x1e65
    10bd:	66 e8 76 f6 ff ff    	calll  739 <printf>
}
    10c3:	66 83 c4 3c          	add    $0x3c,%esp
    10c7:	66 c3                	retl   

000010c9 <tty>:
int message_length = 0;
int command_line_cursor = 0; // 光标在输入区的偏移量
char input_buf[MAX_BUF]; // 输入缓存区


void tty(){
    10c9:	66 56                	push   %esi
    10cb:	66 53                	push   %ebx
    10cd:	66 83 ec 04          	sub    $0x4,%esp
    int keyboard_flag = 0;
    new_line_flag = 1;
    10d1:	66 c7 06 00 21 01 00 	movl   $0x1,0x2100
    10d8:	00 00 
    command_line_row = -1;
    10da:	66 c7 06 04 21 ff ff 	movl   $0xffffffff,0x2104
    10e1:	ff ff 
    clean_screen();
    10e3:	66 e8 4b fa ff ff    	calll  b34 <clean_screen>
    set_cursor(1974);
    10e9:	66 83 ec 0c          	sub    $0xc,%esp
    10ed:	66 68 b6 07 00 00    	pushl  $0x7b6
    10f3:	66 e8 f7 ef ff ff    	calll  f0 <set_cursor>
    set_cursor(0);
    10f9:	67 66 c7 04 24 00 00 	movl   $0x0,(%esp)
    1100:	00 00 
    1102:	66 e8 e8 ef ff ff    	calll  f0 <set_cursor>
    print_my_name();
    1108:	66 e8 a4 fa ff ff    	calll  bb2 <print_my_name>
    110e:	66 83 c4 10          	add    $0x10,%esp
    while (1){
        // 使用缓冲区数据更新
        if (new_line_flag){
    1112:	66 83 3e 00 21 00    	cmpl   $0x0,0x2100
    1118:	74 0f                	je     1129 <tty+0x60>
            create_a_line();
    111a:	66 e8 8e fe ff ff    	calll  fae <create_a_line>
            new_line_flag = 0;
    1120:	66 c7 06 00 21 00 00 	movl   $0x0,0x2100
    1127:	00 00 
        }

        if(command_line_row == 23 && message_length + command_line_cursor > 80){
    1129:	66 83 3e 04 21 17    	cmpl   $0x17,0x2104
    112f:	75 2f                	jne    1160 <tty+0x97>
    1131:	66 a1 40 21          	mov    0x2140,%eax
    1135:	66 03 06 44 21       	add    0x2144,%eax
    113a:	66 83 f8 50          	cmp    $0x50,%eax
    113e:	7e 20                	jle    1160 <tty+0x97>
            scroll_screen();
    1140:	66 e8 08 fa ff ff    	calll  b4e <scroll_screen>
            command_line_row--;
    1146:	66 83 2e 04 21 01    	subl   $0x1,0x2104
            set_cursor(1840);
    114c:	66 83 ec 0c          	sub    $0xc,%esp
    1150:	66 68 30 07 00 00    	pushl  $0x730
    1156:	66 e8 94 ef ff ff    	calll  f0 <set_cursor>
    115c:	66 83 c4 10          	add    $0x10,%esp
        }
        putc(' ');// 用来删除光标处的文字，与输入退格的时候光标-1配合使用
    1160:	66 83 ec 0c          	sub    $0xc,%esp
    1164:	66 6a 20             	pushl  $0x20
    1167:	66 e8 51 f0 ff ff    	calll  1be <putc>

        // command_line_row = get_cursor() / 80;
        set_cursor(80*command_line_row + message_length);
    116d:	66 8b 16 04 21       	mov    0x2104,%edx
    1172:	67 66 8d 14 92       	lea    (%edx,%edx,4),%edx
    1177:	66 89 d0             	mov    %edx,%eax
    117a:	66 c1 e0 04          	shl    $0x4,%eax
    117e:	03 06 44 21          	add    0x2144,%ax
    1182:	66 0f b7 c0          	movzwl %ax,%eax
    1186:	67 66 89 04 24       	mov    %eax,(%esp)
    118b:	66 e8 5f ef ff ff    	calll  f0 <set_cursor>
        puts(input_buf, command_line_cursor);
    1191:	66 83 c4 08          	add    $0x8,%esp
    1195:	66 ff 36 40 21       	pushl  0x2140
    119a:	66 68 60 21 00 00    	pushl  $0x2160
    11a0:	66 e8 0d f2 ff ff    	calll  3b3 <puts>

        // 更新完了 检测键盘
        keyboard_flag = check_keyboard();
    11a6:	66 e8 72 f9 ff ff    	calll  b1e <check_keyboard>

        // 如果返回1，则有输入，处理输入信息，否则继续循环。
        if (keyboard_flag){
    11ac:	66 83 c4 10          	add    $0x10,%esp
    11b0:	85 c0                	test   %ax,%ax
    11b2:	0f 84 5c ff          	je     1112 <tty+0x49>
            // 处理键盘事件
            u16 keyboard_code =  get_keyboard();
    11b6:	66 e8 72 f9 ff ff    	calll  b2e <get_keyboard>
            u8 ascii_code = keyboard_code;
    11bc:	66 89 c3             	mov    %eax,%ebx
            u8 scan_code = keyboard_code >> 8;
            if (isprint(ascii_code)){
    11bf:	66 83 ec 0c          	sub    $0xc,%esp
    11c3:	66 0f b6 c0          	movzbl %al,%eax
    11c7:	66 50                	push   %eax
    11c9:	66 e8 c5 f6 ff ff    	calll  894 <isprint>
    11cf:	66 83 c4 10          	add    $0x10,%esp
    11d3:	66 85 c0             	test   %eax,%eax
    11d6:	74 20                	je     11f8 <tty+0x12f>
                if (command_line_cursor <= MAX_BUF){
    11d8:	66 a1 40 21          	mov    0x2140,%eax
    11dc:	66 83 f8 64          	cmp    $0x64,%eax
    11e0:	0f 8f 2e ff          	jg     1112 <tty+0x49>
                    input_buf[command_line_cursor++] = ascii_code;
    11e4:	67 66 8d 50 01       	lea    0x1(%eax),%edx
    11e9:	66 89 16 40 21       	mov    %edx,0x2140
    11ee:	67 88 98 60 21 00 00 	mov    %bl,0x2160(%eax)
    11f5:	e9 1a ff             	jmp    1112 <tty+0x49>
                }
            }
            else if (ascii_code == 13){
    11f8:	80 fb 0d             	cmp    $0xd,%bl
    11fb:	75 1e                	jne    121b <tty+0x152>
                new_line_flag = 1;
    11fd:	66 c7 06 00 21 01 00 	movl   $0x1,0x2100
    1204:	00 00 
                input_buf[command_line_cursor] = '\0';
    1206:	66 a1 40 21          	mov    0x2140,%eax
    120a:	67 c6 80 60 21 00 00 	movb   $0x0,0x2160(%eax)
    1211:	00 
                parser();
    1212:	66 e8 7c fb ff ff    	calll  d94 <parser>
    1218:	e9 f7 fe             	jmp    1112 <tty+0x49>
            }
            else if (ascii_code == 8){
    121b:	80 fb 08             	cmp    $0x8,%bl
    121e:	75 3e                	jne    125e <tty+0x195>
                if(command_line_cursor){
    1220:	66 a1 40 21          	mov    0x2140,%eax
    1224:	66 85 c0             	test   %eax,%eax
    1227:	0f 84 e7 fe          	je     1112 <tty+0x49>
                    input_buf[--command_line_cursor] = 0;
    122b:	67 66 8d 50 ff       	lea    -0x1(%eax),%edx
    1230:	66 89 16 40 21       	mov    %edx,0x2140
    1235:	67 c6 80 5f 21 00 00 	movb   $0x0,0x215f(%eax)
    123c:	00 
                    // 将光标设置为前一个位置，方便删除
                    int cur_cursor = get_cursor();
    123d:	66 e8 1f ef ff ff    	calll  162 <get_cursor>
                    set_cursor(cur_cursor-1);
    1243:	66 83 ec 0c          	sub    $0xc,%esp
    1247:	66 83 e8 01          	sub    $0x1,%eax
    124b:	66 0f b7 c0          	movzwl %ax,%eax
    124f:	66 50                	push   %eax
    1251:	66 e8 99 ee ff ff    	calll  f0 <set_cursor>
    1257:	66 83 c4 10          	add    $0x10,%esp
    125b:	e9 b4 fe             	jmp    1112 <tty+0x49>
                }
            }
            else if (ascii_code == 27){
    125e:	80 fb 1b             	cmp    $0x1b,%bl
    1261:	0f 85 ad fe          	jne    1112 <tty+0x49>
                __asm__("mov $0x4c00, %ax");
    1265:	b8 00 4c             	mov    $0x4c00,%ax
                __asm__("int $0x40");
    1268:	cd 40                	int    $0x40
    126a:	e9 a5 fe             	jmp    1112 <tty+0x49>

0000126d <tty_scroll_screen>:
    // printf("%d", command_line_row);
    printf("%s", message);
}


void tty_scroll_screen(){
    126d:	66 83 ec 0c          	sub    $0xc,%esp
    if (get_cursor()/80 > 24){
    1271:	66 e8 eb ee ff ff    	calll  162 <get_cursor>
    1277:	3d cf 07             	cmp    $0x7cf,%ax
    127a:	76 0c                	jbe    1288 <tty_scroll_screen+0x1b>
        scroll_screen();
    127c:	66 e8 cc f8 ff ff    	calll  b4e <scroll_screen>
        command_line_row--;
    1282:	66 83 2e 04 21 01    	subl   $0x1,0x2104
    }
    return ;
    1288:	66 83 c4 0c          	add    $0xc,%esp
    128c:	66 c3                	retl   

0000128e <init_fsystem>:
FileDescriptor root[32];
u16 root_sector;
u16 first_cluster_by_sector;
u16 cluster2sector;

void init_fsystem(){
    128e:	66 83 ec 0c          	sub    $0xc,%esp
    cluster2sector = 1;
    1292:	c7 06 00 28 01 00    	movw   $0x1,0x2800
    root_sector = 37;
    1298:	c7 06 e0 21 25 00    	movw   $0x25,0x21e0
    first_cluster_by_sector = root_sector + 1;  
    129e:	c7 06 02 28 26 00    	movw   $0x26,0x2802
    read_n_sector(root_sector,1, 0x1000, root);
    12a4:	66 b8 00 24 00 00    	mov    $0x2400,%eax
    12aa:	66 0f b7 c0          	movzwl %ax,%eax
    12ae:	66 50                	push   %eax
    12b0:	66 68 00 10 00 00    	pushl  $0x1000
    12b6:	66 6a 01             	pushl  $0x1
    12b9:	66 6a 25             	pushl  $0x25
    12bc:	66 e8 85 f6 ff ff    	calll  947 <read_n_sector>
    read_n_sector(1,1,0x1000, FAT_table);// 这个会覆盖掉root吗？
    12c2:	66 b8 00 22 00 00    	mov    $0x2200,%eax
    12c8:	66 0f b7 c0          	movzwl %ax,%eax
    12cc:	66 50                	push   %eax
    12ce:	66 68 00 10 00 00    	pushl  $0x1000
    12d4:	66 6a 01             	pushl  $0x1
    12d7:	66 6a 01             	pushl  $0x1
    12da:	66 e8 67 f6 ff ff    	calll  947 <read_n_sector>
    // puti(FAT_table[0]);
    // puti(root[0].cluster_number);
    // puts(&root[0], 10);
    // puts(&root[1], 10);
    // puts(&root[2], 10);
}
    12e0:	66 83 c4 2c          	add    $0x2c,%esp
    12e4:	66 c3                	retl   

000012e6 <_fs_find_descriptor_number_by_name>:

u16 _fs_find_descriptor_number_by_name(char * file_name){
    12e6:	66 57                	push   %edi
    12e8:	66 56                	push   %esi
    12ea:	66 53                	push   %ebx
    12ec:	67 66 8b 7c 24 10    	mov    0x10(%esp),%edi
    int file_name_length = strlen(file_name);
    12f2:	66 83 ec 0c          	sub    $0xc,%esp
    12f6:	66 57                	push   %edi
    12f8:	66 e8 f0 f8 ff ff    	calll  bee <strlen>
    12fe:	66 89 c6             	mov    %eax,%esi
    if (file_name_length >= 11) file_name_length = 11;
    1301:	66 83 c4 10          	add    $0x10,%esp
    1305:	66 83 f8 0a          	cmp    $0xa,%eax
    1309:	7e 06                	jle    1311 <_fs_find_descriptor_number_by_name+0x2b>
    130b:	66 be 0b 00 00 00    	mov    $0xb,%esi
    // TODO:这里的10是文件数，需要使用常量代替
    for (int i = 0; i < 10; i++){
    1311:	66 bb 00 00 00 00    	mov    $0x0,%ebx
    1317:	eb 2f                	jmp    1348 <_fs_find_descriptor_number_by_name+0x62>
        if (!strncmp(&root[i], file_name, file_name_length)){
    1319:	66 89 d8             	mov    %ebx,%eax
    131c:	66 c1 e0 05          	shl    $0x5,%eax
    1320:	66 05 00 24 00 00    	add    $0x2400,%eax
    1326:	66 83 ec 04          	sub    $0x4,%esp
    132a:	66 56                	push   %esi
    132c:	66 57                	push   %edi
    132e:	66 50                	push   %eax
    1330:	66 e8 7c f9 ff ff    	calll  cb2 <strncmp>
    1336:	66 83 c4 10          	add    $0x10,%esp
    133a:	66 85 c0             	test   %eax,%eax
    133d:	75 05                	jne    1344 <_fs_find_descriptor_number_by_name+0x5e>
            return i;
    133f:	66 89 d8             	mov    %ebx,%eax
    1342:	eb 10                	jmp    1354 <_fs_find_descriptor_number_by_name+0x6e>

u16 _fs_find_descriptor_number_by_name(char * file_name){
    int file_name_length = strlen(file_name);
    if (file_name_length >= 11) file_name_length = 11;
    // TODO:这里的10是文件数，需要使用常量代替
    for (int i = 0; i < 10; i++){
    1344:	66 83 c3 01          	add    $0x1,%ebx
    1348:	66 83 fb 09          	cmp    $0x9,%ebx
    134c:	7e cb                	jle    1319 <_fs_find_descriptor_number_by_name+0x33>
        if (!strncmp(&root[i], file_name, file_name_length)){
            return i;
        }
    }
    return -1;
    134e:	66 b8 ff ff ff ff    	mov    $0xffffffff,%eax
}
    1354:	66 5b                	pop    %ebx
    1356:	66 5e                	pop    %esi
    1358:	66 5f                	pop    %edi
    135a:	66 c3                	retl   

0000135c <_fs_find_cluster_code_by_name>:

u16 _fs_find_cluster_code_by_name(char * file_name){
    135c:	66 83 ec 18          	sub    $0x18,%esp
    int index = _fs_find_descriptor_number_by_name(file_name);
    1360:	67 66 ff 74 24 1c    	pushl  0x1c(%esp)
    1366:	66 e8 7a ff ff ff    	calll  12e6 <_fs_find_descriptor_number_by_name>
    136c:	66 0f b7 c0          	movzwl %ax,%eax
    if (index != -1)
        return root[index].cluster_code;
    1370:	66 c1 e0 05          	shl    $0x5,%eax
    1374:	67 66 0f b7 80 1a 24 	movzwl 0x241a(%eax),%eax
    137b:	00 00 
    return 0;
}
    137d:	66 83 c4 1c          	add    $0x1c,%esp
    1381:	66 c3                	retl   

00001383 <_fs_get_file_size_by_cluster_code>:

u16 _fs_get_file_size_by_cluster_code(u16 cluster_code){
    1383:	67 66 0f b7 54 24 04 	movzwl 0x4(%esp),%edx
    int size = 0;
    138a:	66 b8 00 00 00 00    	mov    $0x0,%eax
    while (0x0002 <= cluster_code && cluster_code <= 0xFFEF){
    1390:	eb 1b                	jmp    13ad <_fs_get_file_size_by_cluster_code+0x2a>
        size += 512*cluster2sector;
    1392:	66 0f b7 0e 00 28    	movzwl 0x2800,%ecx
    1398:	66 c1 e1 09          	shl    $0x9,%ecx
    139c:	66 01 c8             	add    %ecx,%eax
        int sector_number = first_cluster_by_sector + (cluster_code-2)*cluster2sector;
    139f:	66 0f b7 d2          	movzwl %dx,%edx
        cluster_code = FAT_table[cluster_code];
    13a3:	67 66 0f b7 94 12 00 	movzwl 0x2200(%edx,%edx,1),%edx
    13aa:	22 00 00 
    return 0;
}

u16 _fs_get_file_size_by_cluster_code(u16 cluster_code){
    int size = 0;
    while (0x0002 <= cluster_code && cluster_code <= 0xFFEF){
    13ad:	67 66 8d 4a fe       	lea    -0x2(%edx),%ecx
    13b2:	83 f9 ed             	cmp    $0xffed,%cx
    13b5:	76 db                	jbe    1392 <_fs_get_file_size_by_cluster_code+0xf>
        size += 512*cluster2sector;
        int sector_number = first_cluster_by_sector + (cluster_code-2)*cluster2sector;
        cluster_code = FAT_table[cluster_code];
    }
    return size;
}
    13b7:	66 f3 c3             	repz retl 

000013ba <_fs_show_file_by_descriptor_number>:

void _fs_show_file_by_descriptor_number(u16 index){
    13ba:	66 56                	push   %esi
    13bc:	66 53                	push   %ebx
    13be:	66 83 ec 04          	sub    $0x4,%esp
    int cluster_code = root[index].cluster_code;
    13c2:	67 66 0f b7 74 24 10 	movzwl 0x10(%esp),%esi
    13c9:	66 c1 e6 05          	shl    $0x5,%esi
    13cd:	67 66 0f b7 9e 1a 24 	movzwl 0x241a(%esi),%ebx
    13d4:	00 00 
    13d6:	66 81 c6 00 24 00 00 	add    $0x2400,%esi
    printf("%s   | %d byte |", (char *)&root[index],
                             _fs_get_file_size_by_cluster_code(cluster_code));
    13dd:	66 53                	push   %ebx
    13df:	66 e8 9e ff ff ff    	calll  1383 <_fs_get_file_size_by_cluster_code>
    return size;
}

void _fs_show_file_by_descriptor_number(u16 index){
    int cluster_code = root[index].cluster_code;
    printf("%s   | %d byte |", (char *)&root[index],
    13e5:	66 0f b7 c0          	movzwl %ax,%eax
    13e9:	66 50                	push   %eax
    13eb:	66 56                	push   %esi
    13ed:	66 68 68 1e 00 00    	pushl  $0x1e68
    13f3:	66 e8 40 f3 ff ff    	calll  739 <printf>
                             _fs_get_file_size_by_cluster_code(cluster_code));
    while (0x0002 <= cluster_code && cluster_code <= 0xFFEF){
    13f9:	66 83 c4 10          	add    $0x10,%esp
    13fd:	eb 20                	jmp    141f <_fs_show_file_by_descriptor_number+0x65>
        printf("-%d", cluster_code);
    13ff:	66 83 ec 08          	sub    $0x8,%esp
    1403:	66 53                	push   %ebx
    1405:	66 68 79 1e 00 00    	pushl  $0x1e79
    140b:	66 e8 28 f3 ff ff    	calll  739 <printf>
        cluster_code = FAT_table[cluster_code];
    1411:	67 66 0f b7 9c 1b 00 	movzwl 0x2200(%ebx,%ebx,1),%ebx
    1418:	22 00 00 
    141b:	66 83 c4 10          	add    $0x10,%esp

void _fs_show_file_by_descriptor_number(u16 index){
    int cluster_code = root[index].cluster_code;
    printf("%s   | %d byte |", (char *)&root[index],
                             _fs_get_file_size_by_cluster_code(cluster_code));
    while (0x0002 <= cluster_code && cluster_code <= 0xFFEF){
    141f:	67 66 8d 43 fe       	lea    -0x2(%ebx),%eax
    1424:	66 3d ed ff 00 00    	cmp    $0xffed,%eax
    142a:	76 d3                	jbe    13ff <_fs_show_file_by_descriptor_number+0x45>
        printf("-%d", cluster_code);
        cluster_code = FAT_table[cluster_code];
    }
    printf("-|\n");
    142c:	66 83 ec 0c          	sub    $0xc,%esp
    1430:	66 68 7d 1e 00 00    	pushl  $0x1e7d
    1436:	66 e8 fd f2 ff ff    	calll  739 <printf>
    return ;
}
    143c:	66 83 c4 14          	add    $0x14,%esp
    1440:	66 5b                	pop    %ebx
    1442:	66 5e                	pop    %esi
    1444:	66 c3                	retl   

00001446 <_fs_load_by_cluster_code>:

u16 _fs_load_by_cluster_code(u16 cluster_code, void(*program)()){
    1446:	66 57                	push   %edi
    1448:	66 56                	push   %esi
    144a:	66 53                	push   %ebx
    144c:	67 66 8b 74 24 14    	mov    0x14(%esp),%esi
    1452:	67 66 0f b7 5c 24 10 	movzwl 0x10(%esp),%ebx
    int size = 0;
    1459:	66 bf 00 00 00 00    	mov    $0x0,%edi
    while (0x0002 <= cluster_code && cluster_code <= 0xFFEF){
    145f:	eb 5b                	jmp    14bc <_fs_load_by_cluster_code+0x76>
        size += 512*cluster2sector;
    1461:	66 0f b7 16 00 28    	movzwl 0x2800,%edx
    1467:	66 89 d0             	mov    %edx,%eax
    146a:	66 c1 e0 09          	shl    $0x9,%eax
    146e:	66 01 c7             	add    %eax,%edi
        int sector_number = first_cluster_by_sector + (cluster_code-2)*cluster2sector;
    1471:	66 0f b7 0e 02 28    	movzwl 0x2802,%ecx
    1477:	66 0f b7 db          	movzwl %bx,%ebx
    147b:	67 66 8d 43 fe       	lea    -0x2(%ebx),%eax
    1480:	66 0f af c2          	imul   %edx,%eax
    1484:	66 01 c8             	add    %ecx,%eax
        read_n_sector(sector_number, cluster2sector, 0x1000, program);
    1487:	66 0f b7 ce          	movzwl %si,%ecx
    148b:	66 51                	push   %ecx
    148d:	66 68 00 10 00 00    	pushl  $0x1000
    1493:	66 52                	push   %edx
    1495:	66 0f b7 c0          	movzwl %ax,%eax
    1499:	66 50                	push   %eax
    149b:	66 e8 a6 f4 ff ff    	calll  947 <read_n_sector>
        program = program+cluster2sector*512;
    14a1:	66 0f b7 06 00 28    	movzwl 0x2800,%eax
    14a7:	66 c1 e0 09          	shl    $0x9,%eax
    14ab:	66 01 c6             	add    %eax,%esi
        cluster_code = FAT_table[cluster_code];
    14ae:	67 66 0f b7 9c 1b 00 	movzwl 0x2200(%ebx,%ebx,1),%ebx
    14b5:	22 00 00 
    14b8:	66 83 c4 10          	add    $0x10,%esp
    return ;
}

u16 _fs_load_by_cluster_code(u16 cluster_code, void(*program)()){
    int size = 0;
    while (0x0002 <= cluster_code && cluster_code <= 0xFFEF){
    14bc:	67 66 8d 43 fe       	lea    -0x2(%ebx),%eax
    14c1:	83 f8 ed             	cmp    $0xffed,%ax
    14c4:	76 9b                	jbe    1461 <_fs_load_by_cluster_code+0x1b>
        read_n_sector(sector_number, cluster2sector, 0x1000, program);
        program = program+cluster2sector*512;
        cluster_code = FAT_table[cluster_code];
    }
    return size;
}
    14c6:	66 89 f8             	mov    %edi,%eax
    14c9:	66 5b                	pop    %ebx
    14cb:	66 5e                	pop    %esi
    14cd:	66 5f                	pop    %edi
    14cf:	66 c3                	retl   

000014d1 <fs_load_by_name>:


u16 fs_load_by_name(char * file_name, void (*program)()){
    14d1:	66 83 ec 18          	sub    $0x18,%esp
    int cluster_code = _fs_find_cluster_code_by_name(file_name);
    14d5:	67 66 ff 74 24 1c    	pushl  0x1c(%esp)
    14db:	66 e8 7b fe ff ff    	calll  135c <_fs_find_cluster_code_by_name>
    14e1:	66 0f b7 c0          	movzwl %ax,%eax
    if (cluster_code){
    14e5:	66 83 c4 10          	add    $0x10,%esp
    14e9:	66 85 c0             	test   %eax,%eax
    14ec:	74 18                	je     1506 <fs_load_by_name+0x35>
        return _fs_load_by_cluster_code(cluster_code, program);
    14ee:	66 83 ec 08          	sub    $0x8,%esp
    14f2:	67 66 ff 74 24 1c    	pushl  0x1c(%esp)
    14f8:	66 50                	push   %eax
    14fa:	66 e8 46 ff ff ff    	calll  1446 <_fs_load_by_cluster_code>
    1500:	66 83 c4 10          	add    $0x10,%esp
    1504:	eb 06                	jmp    150c <fs_load_by_name+0x3b>
    }
    else {
        return 0;
    1506:	66 b8 00 00 00 00    	mov    $0x0,%eax
    }
}
    150c:	66 83 c4 0c          	add    $0xc,%esp
    1510:	66 c3                	retl   

00001512 <fs_get_file_size>:


u16 fs_get_file_size(char * file_name){
    1512:	66 83 ec 18          	sub    $0x18,%esp
    int cluster_code = _fs_find_cluster_code_by_name(file_name);
    1516:	67 66 ff 74 24 1c    	pushl  0x1c(%esp)
    151c:	66 e8 3a fe ff ff    	calll  135c <_fs_find_cluster_code_by_name>
    return _fs_get_file_size_by_cluster_code(cluster_code);
    1522:	66 0f b7 c0          	movzwl %ax,%eax
    1526:	67 66 89 04 24       	mov    %eax,(%esp)
    152b:	66 e8 52 fe ff ff    	calll  1383 <_fs_get_file_size_by_cluster_code>
}
    1531:	66 83 c4 1c          	add    $0x1c,%esp
    1535:	66 c3                	retl   

00001537 <fs_show_root_file_table>:

void fs_show_root_file_table(){
    1537:	66 53                	push   %ebx
    1539:	66 83 ec 08          	sub    $0x8,%esp
    printf("%s   | %s | %s\n", "file name ", "file size", "cluster");
    153d:	66 68 81 1e 00 00    	pushl  $0x1e81
    1543:	66 68 89 1e 00 00    	pushl  $0x1e89
    1549:	66 68 93 1e 00 00    	pushl  $0x1e93
    154f:	66 68 9e 1e 00 00    	pushl  $0x1e9e
    1555:	66 e8 de f1 ff ff    	calll  739 <printf>
    printf("------------------------------------\n\r");
    155b:	67 66 c7 04 24 58 1f 	movl   $0x1f58,(%esp)
    1562:	00 00 
    1564:	66 e8 cf f1 ff ff    	calll  739 <printf>
    int file_number = 3;// TODO:文件数量需要设置！
    for(int i = 0; i < file_number; i++){
    156a:	66 83 c4 10          	add    $0x10,%esp
    156e:	66 bb 00 00 00 00    	mov    $0x0,%ebx
    1574:	eb 18                	jmp    158e <fs_show_root_file_table+0x57>
        _fs_show_file_by_descriptor_number(i);
    1576:	66 83 ec 0c          	sub    $0xc,%esp
    157a:	66 0f b7 c3          	movzwl %bx,%eax
    157e:	66 50                	push   %eax
    1580:	66 e8 34 fe ff ff    	calll  13ba <_fs_show_file_by_descriptor_number>

void fs_show_root_file_table(){
    printf("%s   | %s | %s\n", "file name ", "file size", "cluster");
    printf("------------------------------------\n\r");
    int file_number = 3;// TODO:文件数量需要设置！
    for(int i = 0; i < file_number; i++){
    1586:	66 83 c3 01          	add    $0x1,%ebx
    158a:	66 83 c4 10          	add    $0x10,%esp
    158e:	66 83 fb 02          	cmp    $0x2,%ebx
    1592:	7e e2                	jle    1576 <fs_show_root_file_table+0x3f>
        _fs_show_file_by_descriptor_number(i);
    }
    return ;
}
    1594:	66 83 c4 08          	add    $0x8,%esp
    1598:	66 5b                	pop    %ebx
    159a:	66 c3                	retl   

0000159c <fs_show_file_by_name>:

void fs_show_file_by_name(char * file_name){
    159c:	66 83 ec 18          	sub    $0x18,%esp
    int descriptor_index = _fs_find_descriptor_number_by_name(file_name);
    15a0:	67 66 ff 74 24 1c    	pushl  0x1c(%esp)
    15a6:	66 e8 3a fd ff ff    	calll  12e6 <_fs_find_descriptor_number_by_name>
    _fs_show_file_by_descriptor_number(descriptor_index);
    15ac:	66 0f b7 c0          	movzwl %ax,%eax
    15b0:	67 66 89 04 24       	mov    %eax,(%esp)
    15b5:	66 e8 ff fd ff ff    	calll  13ba <_fs_show_file_by_descriptor_number>
    return ;
}
    15bb:	66 83 c4 1c          	add    $0x1c,%esp
    15bf:	66 c3                	retl   

000015c1 <fs_show_floppy_infomation>:


void fs_show_floppy_infomation(){
    15c1:	66 f3 c3             	repz retl 

000015c4 <move_name>:

void move_name(){
    u16 *text_line = 1920*2;
    // text_line 0-79
    // text_line[80]
    u16 last_char = text_line[79];
    15c4:	66 0f b7 0e 9e 0f    	movzwl 0xf9e,%ecx
    for (int i =78; i >= 0; i--){
    15ca:	66 b8 4e 00 00 00    	mov    $0x4e,%eax
    15d0:	eb 16                	jmp    15e8 <move_name+0x24>
        text_line[i+1] = text_line[i];
    15d2:	67 66 0f b7 94 00 00 	movzwl 0xf00(%eax,%eax,1),%edx
    15d9:	0f 00 00 
    15dc:	67 89 94 00 02 0f 00 	mov    %dx,0xf02(%eax,%eax,1)
    15e3:	00 
void move_name(){
    u16 *text_line = 1920*2;
    // text_line 0-79
    // text_line[80]
    u16 last_char = text_line[79];
    for (int i =78; i >= 0; i--){
    15e4:	66 83 e8 01          	sub    $0x1,%eax
    15e8:	66 85 c0             	test   %eax,%eax
    15eb:	79 e5                	jns    15d2 <move_name+0xe>
        text_line[i+1] = text_line[i];
    }
    text_line[0] = last_char;
    15ed:	89 0e 00 0f          	mov    %cx,0xf00
    15f1:	66 c3                	retl   
